[
  {
    "objectID": "IntroToJulia.html",
    "href": "IntroToJulia.html",
    "title": "Quick Introduction to Julia",
    "section": "",
    "text": "Now that we have Julia running, we can learn how to enter expressions that Julia will evaluate.\nThe simplest expressions are just a single number or string of text, e.g.¬†try entering something like:\n\n5\n\n5\n\n\nAfter you type 5 at the julia&gt; prompt and press enter, Julia responds with 5, the returned value of your expression.\nYou can do a little more complex expression:\n\n7 * (6 - 1)\n\n35\n\n\n\nArithmetic operators\nPlay around with other simple mathematical expressions. These are some of the main arithmetic operators, which you are likely familiar with: + , -, *, /, ^\nOne that you might be less familiar with is the remainder operator % which gives the remainder of a division, Try playing with these:\n\n7 % 2\n\n1\n\n\nAnother is the √∑ operator, which produces just the integer part of a division (without the decimal part). You aren‚Äôt likely to use √∑ very often, but I include it here as an example of Julia‚Äôs use of unicode characters (more on this below). To type that character at the Julia prompt, enter \\div followed by the tab key.\n\n\nFunctions\nWe can also use some functions in our expressions. A function is something that does a specific thing defined by code already loaded into memory. You can recognize a function in Julia by the fact that it will be a string of text followed immediately by parentheses, perhaps with inputs to the function inside the parentheses. Here we use the sqrt() function, which produces a square root of the number in the parentheses.\n\nsqrt(16)\n\n4.0\n\n\n\n\nAssigning values to variable names\nEach of the above expressions returns a value that we can give a name and store in memory, using the equal sign =, the assignment operator. We can then use variable names in subsequent expressions:\n\npop1 = 50; pop2 = 200; totalPop = pop1 + pop2\n\n250\n\n\nThe semicolons above are used to separate distinct expressions that Julia should evaluate before continuing to the next. This is called a compound expresssion and is a convenient to enter several commands on the same line. Another way to enter a compound expression is with a begin-end block:\n\nbegin\n  x = 17\n  y = x^2\nend\n\n289\n\n\nTry this: Pick a number for the radius of a circle, and assign that to a variable name and store that in Julia‚Äôs memory. Then in a separate command, use that variable to calculate the area of the circle (which is given by œÄ\\(r^{2}\\); to write the exponent of ‚Äò2‚Äô though, you‚Äôll need to use ‚Äò^2‚Äô). A neat thing is that Julia already knows the value of œÄ; to get it, just type pi or alternatively \\pi then tab.\n\n\nDifferent Types of numbers\nWhen computers store numbers, they can do it in different ways, each with their advantages and disadvantages. Two main ways that Julia can store numbers are as integers or as floating-point numbers. Integers have exact values but are quite limited in the values they can take, whereas floating-point numbers can take many more values but have a disadvantage that they are not exact.\nWe can learn about the Type that Julia uses to store values by using the typeof() function:\n\ntypeof(3)\n\nInt64\n\n\nJulia responds by saying that the value 3 is of the Int64 type. This means that it is an integer stored in memory using 64 bits. (No worries if you don‚Äôt know what this means.) Now compare to this:\n\ntypeof(3.0)\n\nFloat64\n\n\nJulia responds by sayng 3.0 is of the Float64 type. This means a 64-bit floating-point number.\nMuch of the time, we don‚Äôt need to think about variable types, because Julia is smart and handles types through somethign called dynamic typing. Here‚Äôs an example:\n\na = 2\nb = 3.0\nc = a + b\ntypeof(c)\n\nFloat64\n\n\nAbove, Julia figures that by entering b = 3.0 you are indicating that you want b treated as a floating-point number, so when it adds the integer 2 to this, it returns a floating-point number.\nJulia has all sort of other useful Types of numbers. One that I will point out here is the Rational number type, which you can construct with the // operator and do exact calculations using ratios:\n\nratio1 = 1//3\nratio2 = 5//7\nproduct = ratio1 * ratio2\n\n5//21\n\n\nAs your Julia skills increase, there are large benefits to being somewhat aware of types‚Äìthis can help you write efficient programs and help with debugging your code. You can even define your own Types.\n\n\nRanges\nJulia has a neat data structure (i.e.¬†a type) to store arithmetic series of numbers:\n\nrangeOfNums = 1:100\nprintln(rangeOfNums)\ntypeof(rangeOfNums)\n\n1:100\n\n\nUnitRange{Int64}\n\n\nJulia stores this range efficiently, until the actual numbers are needed. If we want to actually convert it to the numbers themselves, we could enter something like collect(rangeOfNums)\nIf we want only the even numbers, we enter something like collect(0:2:30).\nTry this: Assign a vector containing the numbers counting down from 15 to -15, by 3.\n\n\nCharacters and Strings\nProgramming in biology often involves manipulating text such as ‚ÄúACGT‚Äù. For this, we can use two other variable types in Julia: characters (officially Char) and strings (officially String), which are usually made up of a series of characters (imagine beads of letters on a string, ha ha).\nWe enter characters with single quotes, and can combine them to make strings:\n\nnucleotide1 = 'T'\nnucleotide2 = 'C'\ndinucleotide = nucleotide1 * nucleotide2\n\n\"TC\"\n\n\nAbove, we create two variables of type Char and combined them (yes, Julia views combining characters or strings as a form of multiplication, ha ha) to produce a String.\nTry this: If Julia uses the * symbol for combining two characters or strings into a longer string, what do you think it might use the ^ symbol for, when applied to a character or string? Make a guess, and then play around and find out.\nWhen you enter a String into Julia, you need to use double quotes (unlike a Char with single quotes).\n\noligo1 = \"ACGCAT\"\noligo2 = \"CCCTG\"\nligation = string(oligo1, oligo2)\n\n\"ACGCATCCCTG\"\n\n\nThe function string above concatenates different strings together.\nTry this: Assign a few of your favorite species to different variable names, and then combine them into a single string, with commas separating their names.\n\n\nUnicode characters\nOne fun thing about Julia is that you can use unicode variables in variable names, strings, function names, and some operators. The motivator for this is to make code read more like humans tend to write mathematics. For example:\n\nœá¬≤ = 30.4\nŒ≤ = 2œá¬≤\n\n60.8\n\n\nTo make the unicode symbols above, you would type \\chi tab \\^2 tab, and on the next line \\beta tab. Notice also that the expression 2œá¬≤ is the same as 2*œá¬≤ or 2 * œá¬≤.\nUnicode also allows some fun.\nTry this: Assign a variable a the value of a Char given by typing \\:seedling: tab. Assign a variable b the value of a Char given by typing \\:deciduous_tree: tab. Then execute this line:\nstring(a, \" grows into \", b)\nWe can also use unicode symbols in variable names:\n\nüê¨ = 47    # write with: \\:dolphin: tab\nüê≥ = 5     # write with: \\:whale: tab\ntotalMarineMammals = üê¨ + üê≥\n\n52\n\n\nNote the use of the # symbol to make comments to the right of code.\nYou can find how to write a whole bunch of unicode symbols here: https://docs.julialang.org/en/v1/manual/unicode-input/\n\n\nComparisons and Booleans\nIn programming it is often important to check if certain conditions are true or false. These are called Booleans (of type Bool in Julia).\nThese operators are used to compare two values (place to left and right of the operator), resulting in true or false: == : equal? != : not equal? &lt; : less than? &lt;= : less than or equal? &gt; : greater than? &gt;= : greater than or equal?\nTry this: Try a bunch of comparisons of values using the above. These are called Boolean expressions.\nWe can use Boolean operators to combine multiple comparisons. These are used as follows, where x and y are Boolean expression: !x : not x x && y : x and y x || y : x or y\nFor example:\n\n5 &lt;= 3 && 7 == 14/2\n\nfalse\n\n\n\n5 &lt;= 3 || 7 == 14/2\n\ntrue\n\n\nTry this: Write a short program in which you assign a numerical value to a variable, then determine whether that value is greater than 5 or less than -3. Your program should return ‚Äòtrue‚Äô or ‚Äòfalse‚Äô.\n\n\nCollections, e.g.¬†Arrays\nVariables can contain more than a single item in them. A general term for such a data structure is a collection. An array is a common type of collection used in Julia: It can be thought of as an n-dimensional lattice of boxes, where you can store something in each box. Here we declare some kinds of arrays:\n\narrayA = [7.3, 3, 11.2, -5, 3.2]\n\n5-element Vector{Float64}:\n  7.3\n  3.0\n 11.2\n -5.0\n  3.2\n\n\n\narrayB = [6 5 4; 3 2 1]\n\n2√ó3 Matrix{Int64}:\n 6  5  4\n 3  2  1\n\n\nBecause these variables are more complex data structures that the simple ones we‚Äôve looked at so far, Julia tells you the type of the returned value, before showing you the actual values.\nNote that a Vector is another name (an alias) for a 1-dimensional array, and a Matrix is another name for a 2-dimensional array.\nWe can ask Julia to return the values in parts of an array by indexing into the array. For example:\n\narrayA[3]\n\n11.2\n\n\n\narrayB[2, 2:3]\n\n2-element Vector{Int64}:\n 2\n 1\n\n\nWe‚Äôre going to eventually learn a lot more about arrays, as they are super useful in data science, bioinformatics, and simulations.\n\n\nBroadcasting\nWe often want to apply an operation or function to each element of an array. In Julia this is called ‚Äúbroadcasting‚Äù and is accomplished by the humble ‚Äúdot‚Äù operator: ‚Äò.‚Äô\nWe can put this dot in front of any arithmetic operator to make the operator apply to each element of a collection:\n\narrayB.^2\n\n2√ó3 Matrix{Int64}:\n 36  25  16\n  9   4   1\n\n\n\n3 .* arrayA\n\n5-element Vector{Float64}:\n  21.9\n   9.0\n  33.599999999999994\n -15.0\n   9.600000000000001\n\n\nWe can also put this dot right after a function to have the function apply to each element in a collection:\n\nsqrt.([64 25 36])\n\n1√ó3 Matrix{Float64}:\n 8.0  5.0  6.0\n\n\n\n\nMacros\nMacros are a kind of function that takes text as input and converts it to code that is then evaluated. They are a somewhat advanced topic in terms of developing a full undertanding. For now, I just want to mention them because some are hugely useful even when starting out. As an example, if you are doing a lot of ‚Äúdot‚Äù operations, you can use the ‚Äò@.‚Äô macro to convert all the operators in a line to dot operators:\n\nbegin\n  data = [3 7 -4 9]\n  results = @. 2data + data^2\nend\n\n1√ó4 Matrix{Int64}:\n 15  63  8  99\n\n\nThe above produces the same output as:\n\nresults = 2 .* data .+ data.^2\n\n1√ó4 Matrix{Int64}:\n 15  63  8  99\n\n\nAnother useful macro is @time :\n\n@time sum(rand(1000))\n\n  0.000016 seconds (1 allocation: 7.938 KiB)\n\n\n492.01962605365014\n\n\nThe ‚Äòrand(x)‚Äô function produces ‚Äòx‚Äô random numbers between 0 and 1. The above returns the sum of 1000 such numbers. Julia tells you the time it took, followed by the sum.\nTry this: Modify the above code so that it takes the square root of one million random numbers between 0 and 1, and then adds them up.\n\n\nDefining your own functions\nJulia facilitates the writing of your own functions. This can have huge benefits in terms of organizing your programs and making them efficient. There are several ways to define them:\n\nsumSqrtRands(x) = sum(sqrt.(rand(x)))\n\nsumSqrtRands (generic function with 1 method)\n\n\nWe‚Äôve defined that function. Now we can use it:\n\n@time sumSqrtRands(1_000_000)\n\n  0.007558 seconds (4 allocations: 15.259 MiB)\n\n\n666644.705449628\n\n\nBelow demonstrates another way to write functions, in this case with two arguments (things you pass into the function):\n\nfunction xSquaredPlusY(x, y)\n  x^2 + y\nend\n\nxSquaredPlusY (generic function with 1 method)\n\n\nTry calling that function a few times, with different values of x and y, e.g.:\n\nxSquaredPlusY(3, -2)\n\n7\n\n\nTry this: Can you figure out how to call the function in a way where you can input a series of numbers as the first argument (for example, ‚Äòx = [1, 3, 7]‚Äô), and ‚Äò-2‚Äô as the second argument? (if you get an error, reviewing the Broadcasting section above might help)\n\n\nPackages\nThousands of people around the world have contributed over 10,000 packages that extend functionality of Julia. Installing these packages is easy.\nFirst, enter the package mode of the REPL by typing ‚Äò]‚Äô . You will then see the ‚Äòjulia&gt;‚Äô prompt change into a prompt that looks something like ‚Äò(@v1.10) pkg&gt;‚Äô . Then, type a command to add a package, e.g.:\nadd Plots\nThis tells Julia to download and install the officially registered package with that name. The Plots package is a big one, so this can take some time.\nTo get out of package mode, press ‚Äòdelete‚Äô and this will return you to the normal Julia REPL mode.\nTo actually use the Plots package, we need to load it into the memory for this Julia session. To do that, simply write:\n\nusing Plots\n\nNow, let‚Äôs use a function called ‚Äòplot()‚Äô that is included in this Plots package. Try:\n\nx = -5:5\ny = x .^ 2\nplot(x, y)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis will likely open another window on your computer, and show a plot. (If not, don‚Äôt worry‚Äìwe‚Äôre going to set up another good way to plot in the next page.)\nIf the above worked, you can see another way to run the plot() function here:\n\nf(x) = x^2\nplot(f)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn our first use of the plot() function above, we passed in two argument, both vectors of numbers. In the second, we passed in just a mathematical function, and plot() figured out a good way to show us the mathematical relationship represented by that function.\nThis flexibility in function calls is an example of multiple dispatch, a key feature of Julia. We‚Äôll come back to this topic in the future.\n\n\nNext steps\nWe‚Äôve now learned a lot of basic concepts related to Julia programming, and it is now time to put them together in more complex ways. For that, we‚Äôll learn how to use Pluto notebooks on the next page. This will enable to write longer programs and organize and save them."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site:\nI am a Professor of Zoology at the University of British Columbia. To learn more about my research, go to: https://www.zoology.ubc.ca/~irwin/irwinlab/\nDisclaimer: I am mostly self-taught in the areas of programming and computer science, so there are definitely better sources to learn about those topics. My goal here is to convey the usefulness of Julia to other biologists.\nThanks: I have benefitted greatly from many excellent courses available from organizations such as Compute Canada, the Digital Alliance of Canada, and UBC Advanced Research Computing. I also thank the many YouTubers, bloggers, and book authors who provide excellent information about Julia and other languages. And of course I thank the inventors of Julia (you can learn more at https://en.wikipedia.org/wiki/Julia_(programming_language)).\nThis whole website was generated using Quarto, which allows embedding of runnable Julia code.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Julia Programming For Biologists",
    "section": "",
    "text": "Welcome! I am starting this website on January 11, 2024, for the purpose of teaching tutorials about the Julia programming language, in the context of biology.\nJulia is a relatively new programming language (started around 2012; first official release in 2018) that is both highly readable (by humans) and fast. This is intended to solve the ‚Äú2-language‚Äù problem, a common workflow in which development of a new program is done first in a highly readable language and then converted by an expert programmer into a fast language. This though results in a program that is difficult to read by non-experts.\nI have used Julia in my own work for about 2 years now, after having much experience with Matlab and then R, and dabbling a bit in Python, C, C++, and Java. The developers of Julia have praise for aspects of all of these languages, and their goal was to combine all the good aspects into one efficient and readable language. I think they have succeeded marvelously.\nMy intended audience with these tutorials is biologists with no or little previous programming experience, who are interested in building their data science, bioinformatic, and statistics skills, or who even want to design their own mathematical models and simulations. My goal is to get you programming quickly, givig just enough underlying explanation of computer science principles to enable fast progress.\nThis is a work in progress, and we‚Äôll see where it goes . . .\nTo advance through pages of the tutorial, click on the right arrow below."
  },
  {
    "objectID": "InstallJulia.html",
    "href": "InstallJulia.html",
    "title": "Download and Install Julia",
    "section": "",
    "text": "To download and install Julia, go to this URL and follow instructions: https://julialang.org/downloads/\nThat website will likely detect your operating system and suggest the right approach.\nIf you have a Mac, the above will direct you to simply open a Terminal window (look for the Terminal application in your Applications/Utilities directory) and type the command below at the Terminal prompt:\ncurl -fsSL https://install.julialang.org | sh\nThe above command installs the Juliaup installation manager, which is a wonderful tool to help update Julia and keep different versions (if you wish) available on your computer.\n\nNow, run Julia!\nIn the Terminal window, type julia at the prompt. After some time (only the first time you do this), you should see a julia logo and a prompt saying julia&gt; . This means Julia is installed and running.\nTry typing a simple calculation, e.g.¬†1 + 3 then Enter or Return, and see what happens.\nNow try entering \"Hello, nice to meet you\" (make sure you put the quotes).\nWith the above, you are using the REPL, the Read-Evaluate-Print-Loop. This is a common way of running Julia. (Another way is to save scripts and execute them, but that is usually for more advanced use.)\nNow, go to the next page to learn more about interacting with Julia."
  }
]