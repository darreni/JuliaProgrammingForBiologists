[
  {
    "objectID": "IntroToJulia.html",
    "href": "IntroToJulia.html",
    "title": "Quick Introduction to Julia",
    "section": "",
    "text": "Now that we have Julia running, we can learn how to enter expressions that Julia will evaluate.\nThe simplest expressions are just a single number or string of text, e.g.¬†try entering something like:\n\n5\n\n5\n\n\nAfter you type 5 at the julia&gt; prompt and press enter, Julia responds with 5, the returned value of your expression.\nYou can do a little more complex expression:\n\n7 * (6 - 1)\n\n35\n\n\n\nArithmetic operators\nPlay around with other simple mathematical expressions. These are some of the main arithmetic operators, which you are likely familiar with: + , -, *, /, ^\nOne that you might be less familiar with is the remainder operator % which gives the remainder of a division, Try playing with these:\n\n7 % 2\n\n1\n\n\nAnother is the √∑ operator, which produces just the integer part of a division (without the decimal part). You aren‚Äôt likely to use √∑ very often, but I include it here as an example of Julia‚Äôs use of unicode characters (more on this below). To type that character at the Julia prompt, enter \\div followed by the tab key.\n\n\nFunctions\nWe can also use some functions in our expressions. A function is something that does a specific thing defined by code already loaded into memory. You can recognize a function in Julia by the fact that it will be a string of text followed immediately by parentheses, perhaps with inputs to the function inside the parentheses. Here we use the sqrt() function, which produces a square root of the number in the parentheses.\n\nsqrt(16)\n\n4.0\n\n\n\n\nAssigning values to variable names\nEach of the above expressions returns a value that we can give a name and store in memory, using the equal sign =, the assignment operator. We can then use variable names in subsequent expressions:\n\npop1 = 50; pop2 = 200; totalPop = pop1 + pop2\n\n250\n\n\nThe semicolons above are used to separate distinct expressions that Julia should evaluate before continuing to the next. This is called a compound expresssion and is a convenient to enter several commands on the same line. Another way to enter a compound expression is with a begin-end block:\n\nbegin\n  x = 17\n  y = x^2\nend\n\n289\n\n\n\n\n\n\n\n\nCalculate the area of a circular forest patch\n\n\n\nPick a number for the radius (in km) of a circle, and assign that to a variable name and store that in Julia‚Äôs memory. Then in a separate command, use that variable to calculate the area of the circle (which is given by œÄ\\(r^{2}\\); to write the exponent of ‚Äò2‚Äô though, you‚Äôll need to use ‚Äò^2‚Äô). A neat thing is that Julia already knows the value of œÄ; to get it, just type pi or alternatively \\pi then tab.\n\n\n\n\nDifferent Types of numbers\nWhen computers store numbers, they can do it in different ways, each with their advantages and disadvantages. Two main ways that Julia can store numbers are as integers or as floating-point numbers. Integers have exact values but are quite limited in the values they can take, whereas floating-point numbers can take many more values but have a disadvantage that they are not exact.\nWe can learn about the Type that Julia uses to store values by using the typeof() function:\n\ntypeof(3)\n\nInt64\n\n\nJulia responds by saying that the value 3 is of the Int64 type. This means that it is an integer stored in memory using 64 bits. (No worries if you don‚Äôt know what this means.) Now compare to this:\n\ntypeof(3.0)\n\nFloat64\n\n\nJulia responds by sayng 3.0 is of the Float64 type. This means a 64-bit floating-point number.\nMuch of the time, we don‚Äôt need to think about variable types, because Julia is smart and handles types through somethign called dynamic typing. Here‚Äôs an example:\n\na = 2\nb = 3.0\nc = a + b\ntypeof(c)\n\nFloat64\n\n\nAbove, Julia figures that by entering b = 3.0 you are indicating that you want b treated as a floating-point number, so when it adds the integer 2 to this, it returns a floating-point number.\nJulia has all sort of other useful Types of numbers. One that I will point out here is the Rational number type, which you can construct with the // operator and do exact calculations using ratios:\n\nratio1 = 1//3\nratio2 = 5//7\nproduct = ratio1 * ratio2\n\n5//21\n\n\nAs your Julia skills increase, there are large benefits to being somewhat aware of types‚Äìthis can help you write efficient programs and help with debugging your code. You can even define your own Types.\n\n\nRanges\nJulia has a neat data structure (i.e.¬†a type) to store arithmetic series of numbers:\n\nrangeOfNums = 1:100\nprintln(rangeOfNums)\ntypeof(rangeOfNums)\n\n1:100\n\n\nUnitRange{Int64}\n\n\nJulia stores this range efficiently, until the actual numbers are needed. If we want to actually convert it to the numbers themselves, we could enter something like collect(rangeOfNums)\nIf we want only the even numbers, we enter something like collect(0:2:30).\n\n\n\n\n\n\nCreate a descending vector\n\n\n\nYou have a population of 30 individuals that is declining by 3 individuals in each time step. Create a vector containing the numbers containing the population sizes at each time step.\n\n\n\n\nCharacters and Strings\nProgramming in biology often involves manipulating text such as ‚ÄúACGT‚Äù. For this, we can use two other variable types in Julia: characters (officially Char) and strings (officially String), which are usually made up of a series of characters (imagine beads of letters on a string, ha ha).\nWe enter characters with single quotes, and can combine them to make strings:\n\nnucleotide1 = 'T'\nnucleotide2 = 'C'\ndinucleotide = nucleotide1 * nucleotide2\n\n\"TC\"\n\n\nAbove, we create two variables of type Char and combined them (yes, Julia views combining characters or strings as a form of multiplication, ha ha) to produce a String.\n\n\n\n\n\n\nExponents on Strings\n\n\n\nIf Julia uses the * symbol for combining two characters or strings into a longer string, what do you think it might use the ^ symbol for, when applied to a character or string? Make a guess, and then play around and find out.\n\n\nWhen you enter a String into Julia, you need to use double quotes (unlike a Char with single quotes).\n\noligo1 = \"ACGCAT\"\noligo2 = \"CCCTG\"\nligation = string(oligo1, oligo2)\n\n\"ACGCATCCCTG\"\n\n\nThe function string above concatenates different strings together.\n\n\n\n\n\n\nYour favourite species\n\n\n\nAssign a few of your favorite species to different variable names, and then combine them into a single string, with commas separating their names.\n\n\n\n\nUnicode characters\nOne fun thing about Julia is that you can use unicode variables in variable names, strings, function names, and some operators. The motivator for this is to make code read more like humans tend to write mathematics. For example:\n\nœá¬≤ = 30.4\nŒ≤ = 2œá¬≤\n\n60.8\n\n\nTo make the unicode symbols above, you would type \\chi tab \\^2 tab, and on the next line \\beta tab. Notice also that the expression 2œá¬≤ is evaluated the same as 2*œá¬≤ or 2 * œá¬≤.\nUnicode also allows some fun.\n\n\n\n\n\n\nPlant biology using Unicode\n\n\n\nAssign a variable a the value of a Char given by typing \\:seedling: tab. Assign a variable b the value of a Char given by typing \\:deciduous_tree: tab. Then execute this line:\nstring(a, \" grows into \", b)\n\n\nWe can also use unicode symbols in variable names:\n\nüê¨ = 47    # write with: \\:dolphin: tab\nüê≥ = 5     # write with: \\:whale: tab\ntotalMarineMammals = üê¨ + üê≥\n\n52\n\n\nNote the use of the # symbol to make comments to the right of code.\nYou can find how to write a whole bunch of unicode symbols here: https://docs.julialang.org/en/v1/manual/unicode-input/\n\n\nComparisons and Booleans\nIn programming it is often important to check if certain conditions are true or false. These are called Booleans (of type Bool in Julia).\nThese operators are used to compare two values (place to left and right of the operator), resulting in true or false: == : equal? != : not equal? &lt; : less than? &lt;= : less than or equal? &gt; : greater than? &gt;= : greater than or equal?\nTry a bunch of comparisons of values using the above. These are called Boolean expressions.\nWe can use Boolean operators to combine multiple comparisons. These are used as follows, where x and y are Boolean expression: !x : not x x && y : x and y x || y : x or y\nFor example:\n\n5 &lt;= 3 && 7 == 14/2\n\nfalse\n\n\n\n5 &lt;= 3 || 7 == 14/2\n\ntrue\n\n\n\n\n\n\n\n\nSelect the extremes\n\n\n\nWrite a series of commands in which you pick a random number between 0 and 1 with the rand() function, and then return true if that number is either above 0.75 or below 0.25, and false otherwise.\n\n\n\n\nCollections, e.g.¬†Arrays\nVariables can contain more than a single item in them. A general term for such a data structure is a collection. An array is a common type of collection used in Julia: It can be thought of as an n-dimensional lattice of boxes, where you can store something in each box. Here we declare some kinds of arrays:\n\narrayA = [7.3, 3, 11.2, -5, 3.2]\n\n5-element Vector{Float64}:\n  7.3\n  3.0\n 11.2\n -5.0\n  3.2\n\n\n\narrayB = [6 5 4; 3 2 1]\n\n2√ó3 Matrix{Int64}:\n 6  5  4\n 3  2  1\n\n\nBecause these variables are more complex data structures that the simple ones we‚Äôve looked at so far, Julia tells you the type of the returned value, before showing you the actual values.\nNote that a Vector is another name (an alias) for a 1-dimensional array, and a Matrix is another name for a 2-dimensional array.\nWe can ask Julia to return the values in parts of an array by indexing into the array. For example:\n\narrayA[3]\n\n11.2\n\n\n\narrayA[end]\n\n3.2\n\n\n\narrayB[2, 2:3]\n\n2-element Vector{Int64}:\n 2\n 1\n\n\nWe can even use such indexing to change the value stored one of the ‚Äúboxes‚Äù in an array:\n\narrayB[2, 2] = -129\narrayB\n\n2√ó3 Matrix{Int64}:\n 6     5  4\n 3  -129  1\n\n\nWe‚Äôre going to eventually learn a lot more about arrays, as they are super useful in data science, bioinformatics, and simulations.\n\nTuples\nAnother kind of collection is called a tuple. It is a lot like a vector (a 1-dimensional array) but is immutable. This means that once defined, you cannot change specific values stored in a particular tuple. We create them using parentheses and commas:\n\nmyTuple = (1.3, 2.7, -12)\ntypeof(myTuple)\n\nTuple{Float64, Float64, Int64}\n\n\nTuples are useful for efficiency‚Äìbecause they are not mutable, Julia can store and use them in a more efficient way than arrays. They are also used when calling functions (we‚Äôll explore this later).\n\n\n\nBroadcasting\nWe often want to apply an operation or function to each element of an array. In Julia this is called ‚Äúbroadcasting‚Äù and is accomplished by the humble ‚Äúdot‚Äù operator: .\nWe can put this dot in front of any arithmetic operator to make the operator apply to each element of a collection:\n\narrayB.^2\n\n2√ó3 Matrix{Int64}:\n 36     25  16\n  9  16641   1\n\n\n\n3 .* arrayA\n\n5-element Vector{Float64}:\n  21.9\n   9.0\n  33.599999999999994\n -15.0\n   9.600000000000001\n\n\nWe can also put this dot right after a function to have the function apply to each element in a collection:\n\nsqrt.([64 25 36])\n\n1√ó3 Matrix{Float64}:\n 8.0  5.0  6.0\n\n\n\n\nMacros\nMacros are a kind of function that takes text as input and converts it to code that is then evaluated. They are a somewhat advanced topic in terms of developing a full undertanding. For now, I just want to mention them because some are hugely useful even when starting out. As an example, if you are doing a lot of ‚Äúdot‚Äù operations, you can use the @. macro to convert all the operators in a line to dot operators:\n\nbegin\n  data = [3 7 -4 9]\n  results = @. 2data + data^2\nend\n\n1√ó4 Matrix{Int64}:\n 15  63  8  99\n\n\nThe above produces the same output as:\n\nresults = 2 .* data .+ data.^2\n\n1√ó4 Matrix{Int64}:\n 15  63  8  99\n\n\nAnother useful macro is @time :\n\n@time sum(rand(1000))\n\n  0.000014 seconds (1 allocation: 7.938 KiB)\n\n\n509.37673166237687\n\n\nThe rand(x) function produces x random numbers between 0 and 1. The above returns the sum of 1000 such numbers. Julia tells you the time it took, followed by the sum.\n\n\n\n\n\n\nEven more numbers!\n\n\n\nModify the above code so that it takes the square root of each of one million random numbers between 0 and 1, and then adds them up.\n\n\n\n\nDefining your own functions\nJulia facilitates the writing of your own functions. This can have huge benefits in terms of organizing your programs and making them efficient. There are several ways to define them:\n\nsumSqrtRands(x) = sum(sqrt.(rand(x)))\n\nsumSqrtRands (generic function with 1 method)\n\n\nWe‚Äôve defined that function. Now we can use it:\n\n@time sumSqrtRands(1_000_000)\n\n  0.006793 seconds (4 allocations: 15.259 MiB)\n\n\n666863.9352958458\n\n\nBelow demonstrates another way to write functions, in this case with two arguments (things you pass into the function, called parameters inside the function):\n\nfunction xSquaredPlusY(x, y)\n  x^2 + y\nend\n\nxSquaredPlusY (generic function with 1 method)\n\n\nTry calling that function a few times, with different values of x and y, e.g.:\n\nxSquaredPlusY(3, -2)\n\n7\n\n\n\n\n\n\n\n\nApply your function to many elements at once\n\n\n\nCan you figure out how to call the above function in a way where you can input a series of numbers as the first argument (for example, x = [1, 3, 7]), and -2 as the second argument? (Hint: if you get an error, reviewing the Broadcasting section above might help)\n\n\n\n\nPackages\nThousands of people around the world have contributed over 10,000 packages that extend functionality of Julia. Installing these packages is easy.\nFirst, enter the package mode of the REPL by typing the right square bracket symbol ] . You will then see the julia&gt; prompt change into a prompt that looks something like (@v1.10) pkg&gt; . Then, type a command to add a package, e.g.:\nadd Plots\nThis tells Julia to download and install the officially registered package with that name. The Plots package is a big one, so this can take some time.\nTo get out of package mode, press the ‚Äúdelete‚Äù key and this will return you to the normal Julia REPL mode.\nTo actually use the Plots package, we need to load it into the memory for this Julia session. To do that, simply write:\n\nusing Plots\n\nNow, let‚Äôs use a function called plot() that is included in this Plots package. Try:\n\nx = -5:5\ny = x .^ 2\nplot(x, y)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis will likely open another window on your computer, and show a plot. (If not, don‚Äôt worry‚Äìwe‚Äôre going to set up another good way to plot in the next page.)\nIf the above worked, you can see another way to run the plot() function here:\n\nf(x) = x^2\nplot(f)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn our first use of the plot() function above, we passed in two argument, both vectors of numbers. In the second, we passed in just a mathematical function, and plot() figured out a good way to show us the mathematical relationship represented by that function.\nThis flexibility in function calls is an example of multiple dispatch, a key feature of Julia. We‚Äôll come back to this topic in the future.\n\n\nNext steps\nWe‚Äôve now learned a lot of basic concepts related to Julia programming, and it is now time to put them together in more complex ways. For that, we‚Äôll learn how to use Pluto notebooks on the next page. This will enable to write longer programs and organize and save them."
  },
  {
    "objectID": "InstallJulia.html",
    "href": "InstallJulia.html",
    "title": "Download and Install Julia",
    "section": "",
    "text": "To download and install Julia, go to this URL and follow instructions: https://julialang.org/downloads/\nThat website will likely detect your operating system and suggest the right approach.\nIf you have a Mac, the above will direct you to simply open a Terminal window (look for the Terminal application in your Applications/Utilities directory) and type the command below at the Terminal prompt:\ncurl -fsSL https://install.julialang.org | sh\nThe above command installs the Juliaup installation manager, which is a wonderful tool to help update Julia and keep different versions (if you wish) available on your computer.\n\nNow, run Julia!\nIn the Terminal window, type julia at the prompt. After some time (only the first time you do this), you should see a julia logo and a prompt saying julia&gt; . This means Julia is installed and running.\nTry typing a simple calculation, e.g.¬†1 + 3 then Enter or Return, and see what happens.\nNow try entering \"Hello, nice to meet you\" (make sure you put the quotes).\nWith the above, you are using the REPL, the Read-Evaluate-Print-Loop. This is a common way of running Julia. (Another way is to save scripts and execute them, but that is usually for more advanced use.)\nNow, go to the next page to learn more about interacting with Julia."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site:\nI am a Professor of Zoology at the University of British Columbia. To learn more about my research, go to: https://www.zoology.ubc.ca/~irwin/irwinlab/\nDisclaimer: I am mostly self-taught in the areas of programming and computer science, so there are definitely better sources to learn about those topics. My goal here is to convey the usefulness of Julia to other biologists.\nThanks: I have benefitted greatly from many excellent courses available from organizations such as Compute Canada, the Digital Alliance of Canada, and UBC Advanced Research Computing. I also thank the many YouTubers, bloggers, and book authors who provide excellent information about Julia and other languages. And of course I thank the inventors of Julia (you can learn more at https://en.wikipedia.org/wiki/Julia_(programming_language)).\nThis whole website was generated using Quarto, which allows embedding of runnable Julia code.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "ControlFlow.html",
    "href": "ControlFlow.html",
    "title": "Control Flow: Loops and Ifs",
    "section": "",
    "text": "So far, what we have learned might be called coding, the way your write commands that do a fixed set of instructions. To do true programming we need to know how to write scripts in which the exact sequence of commands is determined dynamically. This is called control flow.\n\nLoops: for and while\nLoops are very useful in programming, because we often want to do a set of commands multiple times. For example:\n\nfor ice in 1:10\n  iceCubed = ice^3\n  println(\"The cube of \", ice, \" is \", iceCubed)\nend\n\nThe cube of 1 is 1\nThe cube of 2 is 8\nThe cube of 3 is 27\nThe cube of 4 is 64\nThe cube of 5 is 125\nThe cube of 6 is 216\nThe cube of 7 is 343\nThe cube of 8 is 512\nThe cube of 9 is 729\nThe cube of 10 is 1000\n\n\nHere we‚Äôll use a random integer to determine how many times to do a loop:\n\nrand_times = rand(1:10)  # This returns a random integer in the range 1 to 10\nfor i in 1:rand_times\n  println(i)\nend\nprintln(\"I counted to $rand_times\")\n\n1\n2\n3\n4\nI counted to 4\n\n\nNote that the $ in the last line above causes string interpolation of the expression to the right of it.\n\n\n\n\n\n\nTeach Julia to Sing\n\n\n\nWrite a script that produces the song ‚Äú99 bottles of beer on the wall.‚Äù This song goes like ‚Äú99 bottles of beer on the wall, 99 bottle of beer, you take one down and pass it around, 98 bottles of beer on the wall; 98 bottles of beer on the wall, 98 bottles of ‚Ä¶‚Äù and so forth that all the way down. (I don‚Äôt think anyone has ever completed the song . . . Can your program succeed in doing so?)\n\n\nAn interesting thing about for loops is that the iterator variable is internal to the loop (not ‚Äúknown‚Äù outside of the loop):\n\ni = 27\nprintln(\"Before the loop, i = $i\")\nfor i in 1:3\n  println(\"Inside the loop, i = $i\")\nend\nprintln(\"After the loop, i = $i\")\n\nBefore the loop, i = 27\nInside the loop, i = 1\nInside the loop, i = 2\nInside the loop, i = 3\nAfter the loop, i = 27\n\n\n\nfor loops can iterate across many kinds of collections\nYou can iterate across all sorts of things, for example a matrix of strings:\n\nspeciesGrid = [\"warblers\" \"flamebacks\" \"sticklebacks\"; \n              \"sparrows\"  \"guppies\" \"digital organisms\"] \nfor i in speciesGrid\n  println(\"We study $i.\")\nend\n\nWe study warblers.\nWe study sparrows.\nWe study flamebacks.\nWe study guppies.\nWe study sticklebacks.\nWe study digital organisms.\n\n\nInstead of the in in the for line, you can use the unicode character ‚àà (produced by typing \\in tab), which is a mathematical symbol meaning ‚Äúis an element of‚Äù. :\n\nmySet = [\"banana\", 5.3, 'üê¨']  # get the dolphin with \\:dolphin: tab\nfor thing ‚àà mySet\n  println(thing)\nend\n\nbanana\n5.3\nüê¨\n\n\n\n\nNested loops\nOften it is useful to have nested loops. For instance, to produce all dinucleotide combinations:\n\nbases = ['A', 'C', 'G', 'T']\nfor i in bases\n  for j in bases\n    print(i, j, \", \")\n  end\nend\n\nAA, AC, AG, AT, CA, CC, CG, CT, GA, GC, GG, GT, TA, TC, TG, TT, \n\n\nYou can produce the above more concisely by putting both iterator statements on the same line:\n\nbases = ['A', 'C', 'G', 'T']\nfor i in bases, j in bases\n  print(i, j, \", \")\nend \n\nAA, AC, AG, AT, CA, CC, CG, CT, GA, GC, GG, GT, TA, TC, TG, TT, \n\n\n\n\n\n\n\n\nProduce all trinucleotides\n\n\n\nCan you modify the above to produce all possible trinucleotides (i.e., 3-base nucleotides)?\n\n\n\n\nwhile loops\nLet‚Äôs say you don‚Äôt know in advance how many times you want to go through a loop. Rather, you want to stop the loop when some condition is met. The while loop is perfect for that:\n\nsum = 0\nwhile sum &lt;= 21  # inspired by a card game\n  sum = sum + rand(1:10)\n  println(sum)\nend\n\n8\n15\n19\n24\n\n\n\n\n\n\n\n\nSimulate dispersal of an organism\n\n\n\nYou are writing a simulation in which individuals move from their birth site to their breeding site, along a continuous range of length 1. The dispersal distance is drawn from a standard normal distribution, given by randn(), with the constraint that they are not allowed to move outside of the range. If an individual is born at location 0.7, write a script that determines its breeding location within the range (lowest possible value = 0; highest possible value = 1).\n\n\n\n\n\nCompound expressions\nA compound expression is a single large expression that is made up of multiple sub-expressions that are evaluated in order. When the compoud expression is evaluated, only the value generated by the last sub-expression is returned. There are basically two ways to generate compound expressions:\n\nUse a semicolon (;) chain\n\nx = 4; y = 3; x + y\n\n7\n\n\nThe above returns the value of the last subexpression, but it does remember values assigned in the earlier subexpressions. (To prove this to yourself, enter x to see its value.)\nYou can use compound expressions as part of even larger expressions, e.g.:\n\nmyVar = (x = 4; y = 3; x + y)\n\n7\n\n\nThere, the compound expression in parentheses is evaluated and the resulting value is assigned to myVar.\n\n\nUse a begin block\nThe above compound expression is equivalent to the one below:\n\nmyVar2 = begin x = 4; y = 3; x + y end\n\n7\n\n\nThe use of begin blocks is particularly useful when dividing expressions between multiple lines:\n\nbegin\n  string1 = \"Phylloscopus\"\n  string2 = \"trochiloides\"\n  string1 * \" \" * string2\nend\n\n\"Phylloscopus trochiloides\"\n\n\n\n\n\nConditional evaluation: if and ? :\nOften in our programs we want to execute some commands only if a condition is met. For this, we can use an if - elseif - else block:\n\ncoinflip = rand([\"heads\", \"tails\"])\nif coinflip == \"heads\"\n  println(\"Heads--You win!\")\nelseif coinflip == \"tails\"\n  println(\"Tails--You lose :(\")\nelse \n  println(\"The coin has a strange value\")\nend\n\nTails--You lose :(\n\n\nIn an if block, the elseif and else parts are optional, but the end is essential. The indentation is customary and makes the code easier to read, but is not required. The value of the conditional expressions (e.g., just to the right of if) must be of type Bool, meaning either true or false.\n\n\n\n\n\n\nDetermine homozygote or heterozygote\n\n\n\nWrite a script in which you assign a diploid genotype to a variable, with the genotype encoded as a 2-element vector containing strings (e.g., [\"A\", \"C\"] or [\"A\", \"A\"]), and then the script tells you whether the genotype is homozygous (the two elements are the same) or heterozygous (the two elements are different). (Hint: Remember how to access one element of a vector, e.g.¬†x[1] gives just the first element of x; Remember how to ask if two things are equal: ==)\n\n\nIn Julia, if blocks return a value. You can make use if that to do something like this:\n\nhomozygote = true\ngenotype = if homozygote\n             \"TT\"\n           else\n             \"TG\"\n           end\n\n\"TT\"\n\n\n\nTernary operators\nThe ternary operator, consisting of a ? and : separating three expressions (hence ‚Äúternary‚Äù), can be thought of as a consise form of an if - else block. For instance, this is equivalent to the above:\n\nhomozygote ? \"TT\" : \"TG\"\n\n\"TT\"\n\n\nThis can be thought of as ‚ÄúTrue or false‚Äù ? ‚ÄúDo this if true‚Äù : ‚ÄúDo this if false‚Äù\n\n\n\n\n\n\nDetermine whether a number is positive or negative\n\n\n\nAssign a non-zero number to a variable, and then use a ternary operater to report whether the number is positive or negative.\n\n\n\n\n\nShort-circuit evaluation\nAnother way of constructing conditional evaluations is to use the && and || operators (which mean logical ‚Äúand‚Äù and logical ‚Äúor‚Äù). These operators come between two sub-expressions which are evaluated in order from left to right. Julia is efficient and only evaluates the rightmost sub-expression if it needs to (this is why it is called short-circuit evaluation: the evaluation doesn‚Äôt always extend to the right sub-expression). Hence:\n\nIn a && b, b is evaluated only if a is true (because otherwise the whole statement is definitely false)\nIn a || b, b is evaluated only if a is false (because otherwise the whole statement is definitely true)\n\nThe interesting thing is that the b subexpression does not have to produce true or false. Rather, it can do anything you want, and is only executed depending on whether a is true. For example:\n\nx = 5\nx &gt; 0 && println(\"x is positive\")\n\nx is positive\n\n\nTry changing x above to a negative value and run the above again.\nI think of the above construction as ‚ÄúCheck if true AND (only if true) do this thing.‚Äù\n\ny = 3.2\ny &lt;= 0 || println(\"x is positive\")\n\nx is positive\n\n\nAgain, try changing the value of y to a negative value and run again.\nI think of the above as ‚ÄúCheck if true OR (only if not true) do this thing.‚Äù\nThe above expressions may take a while to get used to. You don‚Äôt have to use them, as you might find the if block a lot more intuitive. But you may see these expressions in code that others have written, so it is good to understand them.\n\n\nNext steps\nNow that we have have developed an understanding of loops and conditional evaluation, we are ready to learn more about functions, types, and multiple dispatch in Julia. Together, these concepts can be thought of as methods of control flow. They enable powerful and fascinating approaches to programming."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Julia Programming For Biologists",
    "section": "",
    "text": "Welcome! I am starting this website on January 11, 2024, for the purpose of teaching tutorials about the Julia programming language, in the context of biology.\nJulia is a relatively new programming language (started around 2012; first official release in 2018) that is both highly readable (by humans) and fast. This is intended to solve the ‚Äú2-language‚Äù problem, a common workflow in which development of a new program is done first in a highly readable language (e.g., R or Python) and then converted by an expert programmer into a fast language (e.g., C), such that the resulting code can be difficult to read by non-experts. Hence Julia aims to be a language that provides easy entry for new programmers while also having the power and efficiency to appeal to experts. It is used by NASA, Moderna, Pfizer, and many other organizations, and is used widely by scientists doing climate modelling of Earth and imaging black holes in distant galaxies.\nIf you are in doubt that you need a faster or more readable language than the one you are using, ask yourself this: Have you ever heard other scientists mention how long their bioinformatic processing or evolutionary simulations can take? It is often on the scale of days, weeks, months. What if that were instead minutes, hours, days? How might that accelerate your research, and allow you to expand the scope of your science? Have you ever heard someone say ‚ÄúI can‚Äôt program‚Äù? Did they decide that because they are fundamentally unable to learn the logic of programming, or because many of the languages often taught in programming are really difficult to learn?\nI have used Julia in my own work for about 2 years now, after having much experience with Matlab and then R, and dabbling a bit in Python, C, C++, and Java. The developers of Julia have praise for aspects of all of these languages, and their goal was to combine all the good aspects into one efficient and readable language. I think they have succeeded marvelously.\nMy intended audience with these tutorials is biologists with no or little previous programming experience, who are interested in building their data science, bioinformatic, and statistics skills, or who even want to design their own mathematical models and simulations. My goal is to get you programming quickly, givig just enough underlying explanation of computer science principles to enable fast progress.\nThis is a work in progress, and we‚Äôll see where it goes . . .\nTo advance through pages of the tutorial, click on the right arrow below."
  },
  {
    "objectID": "PlutoNotebooks.html",
    "href": "PlutoNotebooks.html",
    "title": "Pluto Notebooks",
    "section": "",
    "text": "Now that we know how to use the Julia REPL to interact with Julia and are building our understanding of programming, we likely want an environment in which we can compose programs and save them for use later. Pluto notebooks provides a reactive notebook environment for doing this.\n\nInstall Pluto\nPluto is a package that we install into Julia in the same way as we did with the Plots package (on the last page):\nType ] to enter the package mode, then input this:\nadd Pluto\nThis downloads and installs everything needed for Pluto to run (which is quite a bit, so may take some time).\nWhen done, press ‚Äúdelete‚Äù to return from package mode to the REPL. Then type these two commands:\nimport Pluto\nPluto.run()\nEventually (and if your computer works the same as mine), a browser window will open that says ‚Äúwelcome to Pluto.jl‚Äù at the top.\n\n\nCreate your first notebook\nClick on ‚ÄúCreate a new notebook‚Äù (Under the heading ‚ÄúMy Work‚Äù).\nYou will then see a mostly blank page that says ‚ÄúPluto.jl‚Äù in the upper left. Below that there is a line with faint text that says ‚ÄúEnter cell code‚Äù. Try entering a simple Julia expression there to assign a value to a variable (e.g.¬†something like a = 7^2) and then press Shift + Enter to tell Pluto to evaluate the cell.\nPluto then returns the result of your expression above the cell.\nLet‚Äôs add another cell by clicking the little ‚Äú+‚Äù sign below the first cell. In this new cell, enter an expression that creates a second variable and assigns to it a calculation involving your first variable (e.g.¬†b = a - 3). You will see again see the result above the cell.\nNow, edit the first cell to change the value assigned to a, and press Shift + Enter. You will see the returned value of a change, and the value of b changes too. This is what it means to be reactive: any change in your notebook propogates through the entire notebook in a logical way. The whole notebook then is like a single program.\n\nPluto notebooks are not dependent on cell order\nTry switching the order of your two cells, by simply hovering your pointer to the left of one of the cells, and then dragging it up or down. Now play around with the code in the cells. You will see that the results do not depend on cell order.\nThis allows you to organize notebooks in whatever way you want. You have the option of having the final result at the top, with supporting code lower down.\n\n\nConsequences of movable cell blocks\nThere are a couple important consequence of the above. One is that we cannot have two statements that assign to the same variable in two different cells. For instance, if you say a = 1 in one cell and a = a + 1. (Try it! Pluto will respond with an error and suggest a solution.) Instead, we can use begin-end blocks to group code in which a single variable is assigned a series of values in succession:\n\nbegin\n    myVar = 1\n    myVar = myVar + 5\nend\n\n6\n\n\nA related principle is that each cell block can only contain a single expression. (However, an expression can be quite big if it contain a begin-end block.) This ensures Julia can figure out which cells depend on which.\n\n\n\nSave your notebook\nLet‚Äôs save our notebook so we can open it later and use it again. At the top of the page, click on ‚ÄúSave notebook‚Äù. You can then choose a folder and enter a file name (e.g.¬†something like ‚ÄúMyFirstPlutoNotebook.jl‚Äù wouldn‚Äôt be a terrible choice). It is good to give your notebook a ‚Äú.jl‚Äù extension, which indicates a file written in Julia.\nIf you now leave your notebook by clicking on the ‚ÄúPluto.jl‚Äù logo in the upper left, you should see that the notebook you just saved is listed under ‚ÄúMy Work‚Äù. Click on that notebook name, and it will open your notebook again.\n\n\nPluto files are valid Julia files\nA nice thing about working in Pluto is that the file that you are saving is 100% runnable as a Julia file (without using Pluto).\n\n\nPluto has no ‚Äúhidden state‚Äù\nA way that Pluto differs from some other notebook environments (e.g.¬†Jupyter) is that the program state is completely described by the code in the notebook. You don‚Äôt have to wonder if each cell has been executed‚Äìthe entire notebook is affected by any change you make (although Julia is clever and for efficiency figures out what cells depend on that change).\n\n\nMake a plot in Pluto\nPluto can show all sorts of output from your code. For instance, try making a plot. We first need to install the Plots package into our Pluto environment:\n\nusing Plots\n\nIf you have not downloaded the Plots package, Pluto will nicely do it for you.\nNow, lets generate some data and graph it:\n\nnumPoints = 10\nxValues = randn(numPoints) # random draw from standard normal distribution\nyValues = xValues .+ 0.5 .* randn(numPoints)\nscatter(xValues, yValues)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou will likely see a scatter plot of 10 data points. The data generation involved random draws from a standard normal distribution, so your graph won‚Äôt look exactly the same as the one shown here.\n\n\n\n\n\n\nAdd a lot more points\n\n\n\nCan you figure out how to modify the above to get 1000 data points? Try it!\n\n\n\n\nAdd text using Markdown\nYou can add headers and comments to your notebook using Markdown, simply by entering md and then double quotes surrounding your text. Create a new cell at the top of your notebook and enter this:\nmd\"# _Welcome to my notebook!_ \n\nThis is a Pluto notebook for programming in the Julia language. Pluto notebooks are **reactive** to changes you make.\n\"\nYou can hide the code producing that text by clicking on the little eye symbol left of the code cell.\nWe can incorporate Julia expressions into our Markdown comments by preceding it with a $ symbol:\nmd\"There are $numPoints data points in the graph\"\nnum = 4; md\"The square of $num is $(num^2) .\"\n[Note that if you want the above Markdown commands to work outside of Pluto, e.g.¬†in a regular Julia REPL, you have to add the Markdown.jl package. Enter package mode with ], then enter add Markdown, then press ‚Äúdelete‚Äù to return to REPL, then enter using Markdown.]\n\n\nNext steps\nNow that we have a good envirnoment set up to write and save more complex programs, we‚Äôll learn about control flow, the way you can design a program to do different sets of code depending on the state of one or more variables."
  },
  {
    "objectID": "MultipleDispatch.html",
    "href": "MultipleDispatch.html",
    "title": "Types and Multiple Dispatch",
    "section": "",
    "text": "If you‚Äôve worked through the material in the previous pages, you now have the tools to write all sorts of reasonably complex programs to do interesting things. You might take a pause here and build up your skills in combining those tools in ways you find interesting. After spending some time doing that, come back to this page and continue below.\nHere, we‚Äôll build up to an understanding of one of the most powerful features of Julia: multiple dispatch. Rather than define that at the start, we‚Äôll build up an understanding. We‚Äôll start with better understanding of type specifications of objects, then learn how to define our own types of data structures, then learn about single dispatch, and finally explore multiple dispatch.\n\nSpecifying types of objects\nSeveral pages back we learned about how Julia has dynamic typing meaning you often don‚Äôt need to think about the types of objects. But as your programming skills increase, it becomes increasingly beneficial to think about types. This facilitates organized code, interpretation of error messages, reading of documentation, and defining and using functions effectively.\nWe can specify the type of an object using the :: operator, which can be thought of as meaning ‚Äúis an instance of‚Äù:\n\nx::Int64 = 6\n\n6\n\n\nThe above declares an object x as being of type Int64, and then assigns the value 6 to it. If you try to assign something like 6.3 to it, you will get an error (try it!). However, Julia tries to be friendly so if you assign something that can be converted to Int64 it works:\n\ny::Int64 = 6.0\ny\n\n6\n\n\n\nprintln(typeof(6.0))\nprintln(typeof(y))\n\nFloat64\nInt64\n\n\nWhy would you want to force a variable to have a type, when Julia can usually type things correctly on the fly? Maybe you want to make sure that the code is working as you want it to, or you want to prevent code designed for one type of data to be accidentally used for another.\n\n\nCreate your own types: struct\nYou can create your own data structures, which have their own types, using the struct keyword. For instance, let‚Äôs say we are working with shapes:\n\nstruct Circle\n    radius\nend\n\nSo now we have defined a new type (Circle) that has one field (radius). We can now create (‚Äúinstantiate‚Äù or ‚Äúconstruct‚Äù) an actual object that is of this type by calling Circle like a function:\n\ncircA = Circle(1)\n\nCircle(1)\n\n\n\ntypeof(circA)\n\nCircle\n\n\nSo now, circA is a specific object in memory of type Circle. To get its radius (its only field), we type the name of the object then a . and then the field name:\n\ncircA.radius\n\n1\n\n\nLet‚Äôs define and instantiate another kind of shape:\n\nstruct Square\n    side\nend\nsq1 = Square(5)\n\nSquare(5)\n\n\n\n\n\n\n\n\nMore shapes!\n\n\n\nCan you define a new Rectangle type? It needs to have two fields: length and width. Then, create a specific rectangle.\n\n\n\n\nDefining functions for specific types\nNow that we have some shape objects, let‚Äôs do something with them. Functions are great at doing things with objects, so let‚Äôs define a function:\n\ngetArea(x::Circle) = œÄ * (x.radius)^2    # write œÄ with: \\pi tab\n\ngetArea (generic function with 1 method)\n\n\nWe have now defined a function that requires a Circle object as input, and returns the area of the circle based on the radius field. We can call it on our actual objects in memory:\n\ngetArea(circA)\n\n3.141592653589793\n\n\nWe also want to get areas of squares. So, we can define a function with the same name but applies only to Squares:\n\ngetArea(x::Square) = x.side^2\n\ngetArea (generic function with 2 methods)\n\n\nNow here is where it gets really neat. Let‚Äôs call the getArea() function on our our actual square object in memory:\n\ngetArea(sq1)\n\n25\n\n\nAnd now let‚Äôs call the same named function on our circle:\n\ngetArea(circA)\n\n3.141592653589793\n\n\nIn each case, Julia applies the correct formula (for a square vs.¬†a circle) because we‚Äôve set up our function to have two actual methods, and it chooses the method to apply based on the type of the argument.\n\n\n\n\n\n\nAdd a method\n\n\n\nCan you define another method for the getArea() function, this time applying to the Rectangle type (which you defined above)? Then call the function using the specific Rectangle you instantiated above.\n\n\n\n\nMultiple Dispatch: When a method depends on multiple arguments to a function\nIn the above example using shapes, we had an example of single dispatch, when the method of a function depends on the type of a single argument. This is common in a variety of computer languages. Julia is unusual in having the concept of multiple dispatch at its core. This is when the method of a function depends on the types of multiple arguments. We‚Äôll develop this idea using an example:\n\nInteracting cats and dogs\n\nstruct Dog\n  name::String\n  age::Int  # Int is an general type for all integer types (e.g. Int64)\n  sound::String \nend\n\nThe above creates a Dog type. Now let‚Äôs make two actual Dogs:\n\nrosie = Dog(\"Rosie\", 3, \"woof\")\nleah = Dog(\"Leah\", 4, \"howl\")\n\nDog(\"Leah\", 4, \"howl\")\n\n\nNow let‚Äôs make a Cat type and two instantiated Cats:\n\nstruct Cat\n  name::String\n  age::Int  # Int is an general type for all integer types (e.g. Int64)\n  sound::String \nend\n\nfluffy = Cat(\"Fluffy\", 6, \"meow\")\nmilo = Cat(\"Milo\", 11, \"rarr\")\n\nCat(\"Milo\", 11, \"rarr\")\n\n\nNow that we‚Äôve made some dogs and cats, let‚Äôs define the rules by which they interact:\n\nfunction interact(x::Dog, y::Dog)\n  println(\"$(x.name) wags tail and makes a $(x.sound) toward $(y.name).\")\nend\n\ninteract (generic function with 1 method)\n\n\n\nfunction interact(x::Dog, y::Cat)\n  println(\"$(x.name) chases $(y.name).\")\nend\n\ninteract (generic function with 2 methods)\n\n\n\nfunction interact(x::Cat, y::Dog)\n  println(\"$(x.name) runs from $(y.name).\")\nend\n\ninteract (generic function with 3 methods)\n\n\n\nfunction interact(x::Cat, y::Cat)\n  println(\"$(x.name) stretches and says $(x.sound).\")\nend\n\ninteract (generic function with 4 methods)\n\n\nNow, let‚Äôs call our function:\n\ninteract(rosie, leah)\ninteract(rosie, fluffy)\ninteract(fluffy, rosie)\ninteract(fluffy, milo)\n\nRosie wags tail and makes a woof toward Leah.\nRosie chases Fluffy.\nFluffy runs from Rosie.\nFluffy stretches and says meow.\n\n\nThe above display that the interact function has four different methods depending on the types of the two input arguments. This is multiple dispatch.\n[This is all I‚Äôve prepared so far. More coming . . .]\nNamed functions can have many different methods, depending on the types of the argument."
  }
]