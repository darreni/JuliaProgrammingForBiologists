[
  {
    "objectID": "IntroToJulia.html",
    "href": "IntroToJulia.html",
    "title": "Introductory Tour of Julia",
    "section": "",
    "text": "On this page we‚Äôll take an introductory tour of Julia. This will touch on a variety of topics, providing just enough detail to get you going. (We‚Äôll go more in-depth on various topics later. You can also learn more from the Julia Manual.)\n\nExpressions\nNow that we have Julia running (on the last page), we can learn how to enter expressions that Julia will evaluate.\nThe simplest expressions are just a single number or string of text, e.g.¬†try entering something like:\n\n5\n\n5\n\n\nAfter you type 5 at the julia&gt; prompt and press enter, Julia responds with 5, the returned value of your expression.\nYou try a more complex expression:\n\n7 * (6 - 1)\n\n35\n\n\n\n\n\n\n\n\nNoteValid vs.¬†invalid expressions\n\n\n\nIf you enter something that is not interpretable by Julia, the REPL will respond indicating an error. But don‚Äôt worry! This is how we learn, and the REPL is still usable. You can just try again by modifying your expression using your growing knowledge of Julia syntax.\n\n\n\n\nArithmetic operators\nPlay around with other simple mathematical expressions. These are some of the main arithmetic operators, which you are likely familiar with: + , -, *, /, ^. Try using parentheses to control the order of operations (for example: compare the returned values of 3 + 5 / 2^3 versus (3 + 5) / 2^3).\nOne that operator that you might be less familiar with is the remainder operator % which gives the remainder of a division. Try it out:\n\n14 % 5\n\n4\n\n\nAnother is the √∑ operator, which produces just the integer part of a division (without the decimal part). You aren‚Äôt likely to use √∑ very often, but I include it here as an example of Julia‚Äôs use of unicode characters (more on this below). To type that character at the Julia prompt, enter \\div followed by the tab key.\n\n14 √∑ 5\n\n2\n\n\n\n\nFunctions\nWe can also use some functions in our expressions. A function is something that does a specific thing defined by code already loaded into memory. You can recognize a function in Julia by the fact that it will be a string of text followed immediately by parentheses, perhaps with inputs to the function inside the parentheses. Here we use the sqrt() function, which produces a square root of the number in the parentheses.\n\nsqrt(16)\n\n4.0\n\n\n\n\nGetting help\nTo look up information about a command in Julia, you can enter the help mode by typing ? at the Julia prompt. The prompt then changes to help?&gt;, and you can type the name of a function or operator and then enter. Julia will then tell you some helpful info. Try this for the + operator, for instance.\n\n\nNaming and assigning values to objects\nEach of the above expressions returns a value that we can give a name and store in memory, using the equal sign =, the assignment operator. For example:\n\nx = 2sqrt(9)\n\n6.0\n\n\nThe above command does several interesting things:\n\nIt evaluates the expression on the right side of the equal sign.\nIt checks whether there is already an object in memory with the name given on the left side of the equal sign (in this case, x). If not, it creates that object.\nIt assigns the value produced by the right side to the object named by the left side.\n\nWe can then use that named object‚Äôs value in subsequent expressions:\n\n4x\n\n24.0\n\n\nAssigning values to named objects allows us to save values in memory and then combine them in our calcuations:\n\npop1 = 50; pop2 = 200; totalPop = pop1 + pop2\n\n250\n\n\nThe semicolons above are used to separate distinct expressions that Julia should evaluate before continuing to the next. This is called a compound expresssion and allows you to enter several commands into the REPL at one time. Another way to enter a compound expression is with a begin-end block:\n\nbegin\n  x = 17\n  y = x^2\nend\n\n289\n\n\n\n\n\n\n\n\nTipCalculate the area of a circular forest patch\n\n\n\nPick a number for the radius (in km) of a circle, and assign that to an object name and store that in Julia‚Äôs memory. Then in a separate command, use that stored object to calculate the area of the circle (the standard formula for this is œÄ\\(r^{2}\\); to write the exponent of ‚Äò2‚Äô though, you‚Äôll need to use ‚Äò^2‚Äô). A neat thing is that Julia already knows the value of œÄ; to get it, just type pi or alternatively \\pi then tab.\n\n\n\n\nDifferent Types of numbers\nWhen computers store numbers, they can do it in different ways, each with their advantages and disadvantages. Two main ways that Julia can store numbers are as integers or as floating-point numbers. Integers are exact but are limited in the values they can take, whereas floating-point numbers can represent more values but are not exact.\nWe can learn about the type that Julia uses to store values by using the typeof() function:\n\ntypeof(3)\n\nInt64\n\n\nJulia responds by saying that the value 3 is of the Int64 type. This means that it is an integer stored in memory using 64 bits. (No worries if you don‚Äôt know what this means.) Now compare to this:\n\ntypeof(3.0)\n\nFloat64\n\n\nJulia responds by sayng 3.0 is of the Float64 type. This means a 64-bit floating-point number. By writing the .0 after the 3 we have told Julia we want this number treated as a floating-point number.\nMuch of the time, we don‚Äôt need to think about object types, because Julia is smart and handles types through something called dynamic typing. Here‚Äôs an example:\n\na = 2\nb = 3.0\nc = a + b\ntypeof(c)\n\nFloat64\n\n\nAbove, Julia figures that by entering b = 3.0 you are indicating that you want b treated as a floating-point number, so when it adds the integer 2 to this, it returns a floating-point number.\nJulia has all sort of other useful Types of numbers. One that I will point out here is the Rational number type, which you can construct with the // operator and do exact calculations using ratios:\n\nratio1 = 1//3\nratio2 = 5//7\nproduct = ratio1 * ratio2\n\n5//21\n\n\nAs your Julia skills increase, there are large benefits to being somewhat aware of types; this can help you write efficient programs and help with debugging your code. You can even define your own object types.\n\n\nRanges\nJulia has a neat data structure (i.e.¬†a type) to store arithmetic series of numbers:\n\nrangeOfNums = 1:100\nprintln(rangeOfNums)\ntypeof(rangeOfNums)\n\n1:100\n\n\nUnitRange{Int64}\n\n\nThe notation 1:100 means all the integers between 1 and 100. Julia stores this range efficiently, until the actual numbers are needed. If we want to actually convert it to the numbers themselves, we could enter something like collect(rangeOfNums)\nIf we want only the even numbers, we enter something like this:\n\ncollect(0:2:10)   # the '2' is the increment between successive values\n\n6-element Vector{Int64}:\n  0\n  2\n  4\n  6\n  8\n 10\n\n\nNote the use of the # symbol above to make comments to the right of code.\n\n\n\n\n\n\nTipCreate a descending vector\n\n\n\nYou have a population of 30 individuals that is decreasing by 3 individuals in each time step. Use the collect() function to create a list of numbers (a.k.a. a vector) representing the population sizes at each time step (until the population goes extinct).\n\n\n\n\nCharacters and Strings\nProgramming in biology often involves manipulating text such as ‚ÄúACGT‚Äù. For this, we can use two other data types in Julia: characters (officially Char) and strings (officially String), which are usually made up of a series of characters (imagine beads of letters on a string, ha ha‚Äîthis might be especially understood by Taylor Swift fans).\nWe enter characters with single quotes, and can combine them to make strings:\n\nnucleotide1 = 'T'\nnucleotide2 = 'C'\ndinucleotide = nucleotide1 * nucleotide2\n\n\"TC\"\n\n\nAbove, we created two objects of type Char and combined them (yes, Julia views combining characters or strings as a form of multiplication, ha ha) to produce a String.\n\n\n\n\n\n\nTipExponents on Strings\n\n\n\nGiven that Julia uses the * symbol (i.e., multiplication) for combining two characters or strings into a longer string, what do you think it might use the ^ symbol for, when applied to a character or string? Make a guess, and then play around and find out. (If you are stuck, try entering 'T'^2 and think about what the REPL returns)\n\n\nWhen you enter a String into Julia, you need to use double quotes (unlike a Char with single quotes).\n\noligo1 = \"ACGCAT\"\noligo2 = \"CCCTG\"\nligation = string(oligo1, oligo2)\n\n\"ACGCATCCCTG\"\n\n\nThe function string above concatenates different strings together.\n\n\n\n\n\n\nTipYour favourite species\n\n\n\nAssign a few of your favorite species to different object names, and then combine them into a single string, with commas separating their names.\n\n\n\n\nUnicode characters\nOne fun thing about Julia is that you can use Unicode characters in object names, strings, function names, and some operators. The motivator for this is to make code read more like humans tend to write mathematics. For example:\n\nœá¬≤ = 30.4\nŒ≤ = 2œá¬≤\n\n60.8\n\n\nTo make the Unicode symbols above, you would type \\chi tab \\^2 tab, and on the next line \\beta tab. Notice also that the expression 2œá¬≤ is evaluated the same as 2*œá¬≤ or 2 * œá¬≤.\nUnicode also allows some fun:\n\n\n\n\n\n\nTipPlant biology using Unicode\n\n\n\nAssign a variable a the value of a Char given by typing \\:seedling: tab. (Remember to use single quotes around the seedling symbol.) Assign a variable b the value of a Char given by typing \\:deciduous_tree: tab. Then execute this line:\nprintln(a, \" grows into \", b)\n\n\nWe can also use Unicode symbols in variable names:\n\nüê¨ = 47    # write with: \\:dolphin: tab\nüê≥ = 5     # write with: \\:whale: tab\ntotalMarineMammals = üê¨ + üê≥\n\n52\n\n\nYou can find how to write a whole bunch of Unicode symbols by clicking here\n\n\nComparisons and Booleans\nIn programming it is often important to check if certain conditions are true or false. These values are called Booleans (of type Bool in Julia).\nThese comparison operators are used to compare two values (place to left and right of the operator), resulting in true or false:\n== : equal? (notice the two equal symbols)\n!= : not equal? (or try a uncode symbol by typing \\neq then tab: ‚â†)\n&lt; : less than?\n&lt;= : less than or equal?\n&gt; : greater than?\n&gt;= : greater than or equal?\n\nTry a bunch of comparisons of values using the above. These are called Boolean expressions. For example:\n\nsqrt(9) == 3\n\ntrue\n\n\n\nx = 8; sqrt(x) &gt;= 3\n\nfalse\n\n\nWe can use Boolean operators to combine multiple comparisons. These are used as follows, where x and y are Boolean expressions:\n!x : not x\nx && y : x and y\nx || y : x or y\n\nFor example:\n\n5 &lt;= 3 && 7 == 14/2\n\nfalse\n\n\n\n5 &lt;= 3 || 7 == 14/2\n\ntrue\n\n\n\n!(5 &lt;= 3 || 7 == 14/2)\n\nfalse\n\n\n\n\n\n\n\n\nTipSelect the extremes\n\n\n\nThe expression rand() gets a random number between 0 and 1. Write a series of commands that picks such a random number, and then returns true if that number is either above 0.75 or below 0.25, and false otherwise.\n(If you solve the above and have time, can you figure out a way to chain your Boolean expressions into a form similar to value1 &lt; x &lt; value2 ?)\n\n\n\n\nCollections, e.g.¬†Arrays\nObjects can contain more than a single item in them. A general term for such a data structure is a collection. An array is a common type of collection used in Julia: It can be thought of as an n-dimensional lattice of boxes, where you can store something in each box. Below we create some kinds of arrays:\n\narrayA = [7.3, 3, 11.2, -5, 3.2]\n\n5-element Vector{Float64}:\n  7.3\n  3.0\n 11.2\n -5.0\n  3.2\n\n\n\narrayB = [6 5 4; 3 2 1]\n\n2√ó3 Matrix{Int64}:\n 6  5  4\n 3  2  1\n\n\nBecause these data structures are more complex than the simple ones we‚Äôve looked at so far, Julia tells you the type of the returned value, before showing you the actual values.\nNote that a Vector is another name (an alias) for a 1-dimensional array, and a Matrix is another name for a 2-dimensional array. Inside the curly brackets, Julia indicates the type that each element of the array belongs to (this is Float64 in the first case, and Int64 in the second).\nWe can ask Julia to return the values in parts of an array by indexing into the array. For example:\n\narrayA[3]\n\n11.2\n\n\n\narrayA[end]\n\n3.2\n\n\nWhat do you think using begin as an index would do? Try it!\n\narrayB[2, 2:3]\n\n2-element Vector{Int64}:\n 2\n 1\n\n\nAbove, we took a slice of arrayB, consisting of row 2 and columns 2-3.\nWe can even use such indexing to change the value stored one of the ‚Äúboxes‚Äù in an array:\n\narrayB[2, 2] = -129\narrayB\n\n2√ó3 Matrix{Int64}:\n 6     5  4\n 3  -129  1\n\n\nWe‚Äôre going to eventually learn a lot more about arrays, as they are super useful in data science, bioinformatics, and simulations. There are many Julia functions than manipulate arrays. Here we‚Äôll mention two of them that are useful for working with vectors (1-dimensional arrays) when you are starting out:\n\npush!() and pop!()\nThese two functions are used to add (push) an element to the end of a vector, or remove (pop) the last element from a vector:\n\nvecA = [\"one\", \"two\", \"three\"]\npush!(vecA, \"four\")\n\n4-element Vector{String}:\n \"one\"\n \"two\"\n \"three\"\n \"four\"\n\n\nWe added an element to the end. Now we can remove it:\n\npop!(vecA)\n\n\"four\"\n\n\nThat last one returns the last element of vecA, and removes it from vecA‚Äîwe can verify this by asking the REPL to show what is in vecA:\n\nvecA\n\n3-element Vector{String}:\n \"one\"\n \"two\"\n \"three\"\n\n\nThe ! in these function names conveys that these functions change an object that is being passed to the function (in this case, vecA). Other useful and well-named functions that change vectors include insert!(), delete!(), append!(), empty!(), and many others.\n\n\n\nTuples\nAnother kind of collection is called a tuple. It is a lot like a vector (a 1-dimensional array) but is immutable. This means that once defined, you cannot change specific values stored in a particular tuple. We create them using parentheses and commas:\n\nmyTuple = (1.3, \"RNA\", -12, '4')\ntypeof(myTuple)\n\nTuple{Float64, String, Int64, Char}\n\n\nThe response tells us that the object we created is of Tuple type, and it tells us the types of each element in the tuple.\nWe can also create named tuples in which we give names to the values:\n\nnt = (base = 'C', position = 35, chrom = \"Z\")\n\n(base = 'C', position = 35, chrom = \"Z\")\n\n\nWe can get the value of a certain element by using that name, like this:\n\nnt.chrom\n\n\"Z\"\n\n\nThe above is one of the uses of the ‚Äú.‚Äù symbol, to access a named element within a tuple. (Another use, quite different, is described after the next heading below).\nTuples are useful for storing and calling connected pieces of info. Because they are not mutable, Julia can store and use them in a more efficient way than arrays. They can also be used to feed data into functions (we‚Äôll explore this later).\n\n\nDictionaries\nYet another useful kind of collection is a dictionary, which in Julia is of type Dict. These can be thought of as lookup tables, which match up keys and values into key-value pairs. For example, let‚Äôs say you wanted to setup a way for a single letter to represent a species name:\n\nlookup = Dict('h'=&gt;\"human\", 'f'=&gt;\"fruit fly\", 's'=&gt;\"sunflower\")\n\nDict{Char, String} with 3 entries:\n  'f' =&gt; \"fruit fly\"\n  'h' =&gt; \"human\"\n  's' =&gt; \"sunflower\"\n\n\nNow, we can get a specific values using a specific key, almost in the same way you would use indexing to access one element in an array:\n\nlookup['s']\n\n\"sunflower\"\n\n\nThere are many ways to modify and work with dictionaries. For now, we‚Äôll move on to other topics in this introductory tour.\n\n\nBroadcasting\nWe often want to apply an operation or function to each element of an array. In Julia this is called ‚Äúbroadcasting‚Äù and is accomplished by the humble ‚Äúdot‚Äù operator: .\nWe can put this dot in front of any arithmetic operator to make the operator apply to each element of a collection:\n\narrayB.^2   # square each element of arrayB\n\n2√ó3 Matrix{Int64}:\n 36     25  16\n  9  16641   1\n\n\n\n3 .* [5, -1, 3]\n\n3-element Vector{Int64}:\n 15\n -3\n  9\n\n\nWe can also put this dot right after a function to have the function apply to each element in a collection:\n\nsqrt.([64 25 36])\n\n1√ó3 Matrix{Float64}:\n 8.0  5.0  6.0\n\n\n\n\nMacros\nMacros are a kind of function that takes text as input and converts it to code that is then evaluated. They are a somewhat advanced topic in terms of developing a full undertanding. For now, I just want to mention them because some are hugely useful even when starting out. As an example, if you are doing a lot of ‚Äúdot‚Äù operations, you can use the @. macro to convert all the operators in a line to dot operators:\n\nbegin\n  data = [3 7 -4 9]\n  results = @. 2data + data^2\nend\n\n1√ó4 Matrix{Int64}:\n 15  63  8  99\n\n\nThe line above with the @. macro produces the same output as:\n\nresults = 2 .* data .+ data.^2\n\n1√ó4 Matrix{Int64}:\n 15  63  8  99\n\n\nAnother useful macro is @time :\n\n@time sum(rand(1000))\n\n  0.000008 seconds (3 allocations: 8.062 KiB)\n\n\n481.5878495084305\n\n\nThe rand(x) function produces x random numbers between 0 and 1. The above returns the sum of 1000 such numbers. Julia tells you the time it took, followed by the sum.\nAn aside: If you are curious about how long the same thing takes in R, you can run this code in R:\nstartTime &lt;- Sys.time()\nsum(runif(1000))\nendTime &lt;- Sys.time()\nprint(endTime - startTime)\n\n\n\n\n\n\nTipEven more numbers!\n\n\n\nModify the last Julia expression above so that it takes the square of each of one million random numbers between 0 and 1, and then adds them up.\n(Hint: pay attention to the section on Broadcasting above, especially about the dot operator.)\n\n\n\n\nDefining your own functions\nJulia facilitates the writing of your own functions. This can have huge benefits in terms of organizing your programs and making them efficient. Here‚Äôs an example:\n\nsumSqrtRands(n) = sum(sqrt.(rand(n)))\n\nsumSqrtRands (generic function with 1 method)\n\n\nWe‚Äôve now defined a function that generates n random numbers, takes the square root of each, and then adds those up. Now we can use it for the sum of one million such numbers (in Julia we can write big numbers with underscores separating integers, making them easier to read):\n\n@time sumSqrtRands(1_000_000)\n\n  0.009607 seconds (6 allocations: 15.313 MiB)\n\n\n666907.5022649702\n\n\nBelow demonstrates another way to write functions, in this case with two arguments (things you pass into the function, called parameters inside the function):\n\nfunction xSquaredPlusY(x, y)\n  x^2 + y\nend\n\nxSquaredPlusY (generic function with 1 method)\n\n\nTry calling that function a few times, with different values of x and y, e.g.:\n\nxSquaredPlusY(3, -2)\n\n7\n\n\n\n\n\n\n\n\nTipApply your function to many elements at once\n\n\n\nCan you figure out how to call the above function in a way where you can input a series of numbers as the first argument (for example, x = [1, 3, 7]), and -2 as the second argument? (Hint: if you get an error, reviewing the Broadcasting section above might help)\n\n\n\n\nPackages\nThousands of people around the world have contributed over 10,000 packages that extend functionality of Julia. Installing these packages is easy.\nFirst, at the julia&gt; prompt in the REPL, typing the right square bracket symbol ] to activate the package mode. You will then see the julia&gt; prompt change into a prompt that looks something like (@v1.12) pkg&gt; . Then, type a command to add a package, e.g.:\nadd Plots\nThis tells Julia to download and install the officially registered package with that name. The Plots package is a big one, so this can take some time.\nTo get out of package mode, press the ‚Äúdelete‚Äù key and this will return you to the normal Julia REPL mode.\nTo actually use the Plots package, we need to load it into the memory for this Julia session. To do that, simply write:\n\nusing Plots\n\nNow, let‚Äôs use a function called plot() that is included in this Plots package. Try:\n\nx = -5:5\ny = x .^ 2\nplot(x, y)\n\n\n\n\nThis will likely open another window on your computer, and show a plot. (If not, don‚Äôt worry; we‚Äôre going to set up another good way to plot in the next page.)\nIf the above worked, you can see another way to run the plot() function here:\n\nf(x) = x^2\nplot(f)\n\n\n\n\nIn our first use of the plot() function above, we passed in two argument, both vectors of numbers. In the second, we passed in just a mathematical function, and plot() figured out a good way to show us the mathematical relationship represented by that function.\nThis flexibility in function calls is an example of multiple dispatch, a key feature of Julia. We‚Äôll come back to this topic in the future.\n\n\nNext steps\nWe‚Äôve now learned a lot of basic concepts related to Julia programming, and it is now time to put them together in more complex ways. For that, we‚Äôll learn how to use Pluto notebooks on the next page. This will enable us to write longer programs and organize and save them.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Introductory Tour of Julia"
    ]
  },
  {
    "objectID": "MultipleDispatch.html",
    "href": "MultipleDispatch.html",
    "title": "Types and Multiple Dispatch",
    "section": "",
    "text": "If you‚Äôve worked through the material in the previous pages, you now have the tools to write all sorts of reasonably complex programs to do interesting things. You might take a pause here and build up your skills in combining those tools in ways you find interesting. After spending some time doing that, come back to this page and continue below.\nHere, we‚Äôll build up to an understanding of one of the most powerful features of Julia: multiple dispatch. Rather than define that at the start, we‚Äôll build up an understanding. We‚Äôll start with better understanding of type specifications of objects, then learn how to define our own types of data structures, then learn about single dispatch, and finally explore multiple dispatch.\n\nSpecifying types of objects\nSeveral pages back we learned about how Julia has dynamic typing meaning you often don‚Äôt need to think about the types of objects. But as your programming skills increase, it becomes increasingly beneficial to think about types. This facilitates organized code, interpretation of error messages, reading of documentation, and defining and using functions effectively.\nWe can specify the type of an object using the :: operator, which can be thought of as meaning ‚Äúis an instance of‚Äù:\n\nx::Int64 = 6\n\n6\n\n\nThe above declares an object x as being of type Int64, and then assigns the value 6 to it. If you try to assign something like 6.3 to it, you will get an error (try it!). However, Julia tries to be friendly so if you assign something that can be converted to Int64, it works:\n\ny::Int64 = 6.0\ny\n\n6\n\n\n\nprintln(typeof(6.0))\nprintln(typeof(y))\n\nFloat64\nInt64\n\n\nWhy would you want to force a variable to have a type, when Julia can usually type things correctly on the fly? Maybe you want to make sure that the code is working as you want it to, or you want to prevent code designed for one type of data to be accidentally used for another.\n\n\nCreate your own types: struct\nYou can create your own data structures, which have their own types, using the struct keyword. For instance, let‚Äôs say we are working with shapes:\n\nstruct Circle\n    radius\nend\n\nSo now we have defined a new type (Circle) that has one field (radius). We can now create (‚Äúinstantiate‚Äù or ‚Äúconstruct‚Äù) an actual object that is of this type by calling Circle like a function:\n\ncircA = Circle(1)\n\nCircle(1)\n\n\n\ntypeof(circA)\n\nCircle\n\n\nSo now, circA is a specific object in memory of type Circle. To get its radius (its only field), we type the name of the object then a . and then the field name:\n\ncircA.radius\n\n1\n\n\nLet‚Äôs define and instantiate another kind of shape:\n\nstruct Square\n    side\nend\nsq1 = Square(5)\n\nSquare(5)\n\n\n\n\n\n\n\n\nTipMore shapes!\n\n\n\nCan you define a new Rectangle type? It needs to have two fields: length and width. Then, create a specific rectangle.\n\n\n\nMutable vs.¬†immutable types\nThe types defined above by the struct keyword are used to instatiate immutable objects. This means we get an error if we try to alter a field within an object:\nsq1.side = 7\nThe REPL responds with an error saying ‚Äúimmutable struct of type Square cannot be changed‚Äù. To set up the ability to change our objects after they are created, we need to use the mutable struct phrase to define the type:\n\nmutable struct SquareMutable\n  side\nend\n\n\nsqA = SquareMutable(3.5)\n\nSquareMutable(3.5)\n\n\n\nsqA.side = 9.7\n\n9.7\n\n\n\n\n\nDefining functions for specific types\nNow that we have some shape objects, let‚Äôs do something with them. Functions are great at doing things with objects, so let‚Äôs define a function:\n\ngetArea(x::Circle) = œÄ * (x.radius)^2    # write œÄ with: \\pi tab\n\ngetArea (generic function with 1 method)\n\n\nWe have now defined a function that requires a Circle object as input, and returns the area of the circle based on the radius field. We can call it on our actual objects in memory:\n\ngetArea(circA)\n\n3.141592653589793\n\n\nWe also want to get areas of squares. So, we can define a function with the same name but applies only to Squares:\n\ngetArea(x::Square) = x.side^2\n\ngetArea (generic function with 2 methods)\n\n\nNow here is where it gets really neat. Let‚Äôs call the getArea() function on our our actual square object in memory:\n\ngetArea(sq1)\n\n25\n\n\nAnd now let‚Äôs call the same named function on our circle:\n\ngetArea(circA)\n\n3.141592653589793\n\n\nIn each case, Julia applies the correct formula (for a square vs.¬†a circle) because we‚Äôve set up our function to have two actual methods, and it chooses the method to apply based on the type of the argument.\n\n\n\n\n\n\nTipAdd a method\n\n\n\nCan you define another method for the getArea() function, this time applying to the Rectangle type (which you defined above)? Then call the function using the specific Rectangle you instantiated above.\n\n\n\n\nMultiple Dispatch: When a method depends on multiple arguments to a function\nIn the above example using shapes, we had an example of single dispatch, when the method of a function depends on the type of a single argument. This is common in a variety of computer languages. Julia is unusual in having the concept of multiple dispatch at its core. This is when the method of a function depends on the types of multiple arguments. We‚Äôll develop this idea using an example:\n\nInteracting cats and dogs\n\nstruct Dog\n  name::String\n  age::Int  # Int is a general type for all integer types (e.g. Int64)\n  sound::String \nend\n\nThe above creates a Dog type. Now let‚Äôs make two actual Dogs:\n\nrosie = Dog(\"Rosie\", 3, \"woof\")\nleah = Dog(\"Leah\", 4, \"howl\")\n\nDog(\"Leah\", 4, \"howl\")\n\n\nWe can learn about what is within a certain object in memory by using the ‚Äòdump()‚Äô function (which can be thought of as ‚Äúdumping‚Äù or showing everything in the object):\n\ndump(rosie)\n\nDog\n  name: String \"Rosie\"\n  age: Int64 3\n  sound: String \"woof\"\n\n\nNow let‚Äôs make a Cat type and two instantiated Cats:\n\nstruct Cat\n  name::String\n  age::Int  # Int is an general type for all integer types (e.g. Int64)\n  sound::String \nend\n\nfluffy = Cat(\"Fluffy\", 6, \"meow\")\nmilo = Cat(\"Milo\", 11, \"rarr\")\n\nCat(\"Milo\", 11, \"rarr\")\n\n\nNow that we‚Äôve made some dogs and cats, let‚Äôs define the rules by which they interact:\n\nfunction interact(x::Dog, y::Dog)\n  println(\"$(x.name) wags tail and makes a $(x.sound) toward $(y.name).\")\nend\n\ninteract (generic function with 1 method)\n\n\n\nfunction interact(x::Dog, y::Cat)\n  println(\"$(x.name) chases $(y.name).\")\nend\n\ninteract (generic function with 2 methods)\n\n\n\nfunction interact(x::Cat, y::Dog)\n  println(\"$(x.name) runs from $(y.name).\")\nend\n\ninteract (generic function with 3 methods)\n\n\n\nfunction interact(x::Cat, y::Cat)\n  println(\"$(x.name) stretches and says $(x.sound).\")\nend\n\ninteract (generic function with 4 methods)\n\n\nNow, let‚Äôs call our function:\n\ninteract(rosie, leah)\ninteract(rosie, fluffy)\ninteract(fluffy, rosie)\ninteract(fluffy, milo)\n\nRosie wags tail and makes a woof toward Leah.\nRosie chases Fluffy.\nFluffy runs from Rosie.\nFluffy stretches and says meow.\n\n\nThe above display that the interact() function has four different methods depending on the types of the two input arguments. This is multiple dispatch.\n\n\nImportance of multiple dispatch\nThe examples above are just an initial look at the power of multiple dispatch. If Julia did not have multiple dispatch, then the method of the function call would depend only the first argument (i.e., single dispatch). You could still write a general interact() function code that checks whether the second argument is a Cat, a Dog, etc., and have if statements to govern what to do in the different cases. But multiple dispatch provides an efficient, concise way to ensure just the appropriate code is evaluated, without explicit if statements.\nOne reason it is important to understand multiple dispatch is that it helps you understand how to use built-in Julia functions, and helps you understand errors when you get them. For example, enter this incorrect expression:\nsqrt([9, 4])\nThe REPL responds by saying: ERROR: MethodError: no method matching sqrt(::Vector{Int64})\nIt is telling you that there is no method for the ‚Äòsqrt‚Äô function that uses an input an object of type Vector{Int64} (meaning a vector of integers). If we can understand this message, we might then realize that we have to either enter a single number as input (sqrt(9)) or broadcast over all elements of the vector using the dot operator (sqrt.([9, 4])).\nIf we want to see what methods a function can use, we can use the methods() function. For example, let‚Äôs do this for animal interaction function that we defined above:\n\nmethods(interact)\n\n# 4 methods for generic function interact from \u001b[35mMain.Notebook\u001b[39m: interact(x::Main.Notebook.Cat, y::Main.Notebook.Cat) in Main.Notebook at /Users/darrenirwin/Documents/Github_repos_MacBookPro/JuliaProgrammingForBiologists/MultipleDispatch.qmd:204  interact(x::Main.Notebook.Cat, y::Main.Notebook.Dog) in Main.Notebook at /Users/darrenirwin/Documents/Github_repos_MacBookPro/JuliaProgrammingForBiologists/MultipleDispatch.qmd:198  interact(x::Main.Notebook.Dog, y::Main.Notebook.Cat) in Main.Notebook at /Users/darrenirwin/Documents/Github_repos_MacBookPro/JuliaProgrammingForBiologists/MultipleDispatch.qmd:192  interact(x::Main.Notebook.Dog, y::Main.Notebook.Dog) in Main.Notebook at /Users/darrenirwin/Documents/Github_repos_MacBookPro/JuliaProgrammingForBiologists/MultipleDispatch.qmd:186 \n\n\nThe REPL then tells us that there are four methods and summarizes what types go into them.\nIf curious, you can try this on any function‚Äìfor instance, try methods(+) to see that there are at least 192 methods for the +() function depending on the arguments passed into it.\n\n\n\nNext steps\nThis and the previous pages have brought you through what I consider to be an introductory tour of the central concepts needed for programming well in Julia. You can use these building blocks to compose programs that do all sorts of complex things‚Äìvirtually anything you can imagine, as long as you can think through the logic of what you want your program to do.\nTo increase your ability to write programs that are memory-efficient and fast, let‚Äôs learn some more details about how numbers are stored in a computer, and how large amounts of data can be stored efficiently in arrays and data frames.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Types and Multiple Dispatch"
    ]
  },
  {
    "objectID": "InstallJulia.html",
    "href": "InstallJulia.html",
    "title": "Download and Install Julia",
    "section": "",
    "text": "To download and install Julia, go to this URL and follow instructions: https://julialang.org/install/\nThat website will likely detect your operating system and suggest the right approach.\nIf you have a Mac: The above will direct you to simply open a Terminal window (look for the Terminal application in your Applications/Utilities directory) and type the command below at the Terminal prompt:\ncurl -fsSL https://install.julialang.org | sh\nIf you have a PC: The above Julia install website will give you two approaches to installing Julia using downloadable installers. For the second of these, there is a way to do this using a command-line interface window (using e.g., Windows Powershell or Windows Terminal), by typing the command below at the prompt:\nwinget install --name Julia --id 9NJNWW8PVKMN -e -s msstore\nThe above commands (whether Mac or PC) install the Juliaup installation manager, which is a wonderful tool to help update Julia and keep different versions (if you wish) available on your computer.\n\n\n\n\n\n\nNoteIf desired: update Julia\n\n\n\nIf you already have Julia and Juliaup installed, and you want to update Julia to the latest available stable version, enter the command juliaup update into your Terminal or other command-line interface. (You can see other useful Juliaup commands here)\n\n\n\nNow, run Julia!\nIn the Terminal window, type julia at the prompt. After some time (only the first time you do this), you should see a julia logo and a prompt saying julia&gt; . This means Julia is installed and running.\nTry typing a simple calculation, e.g.¬†1 + 3 then Enter or Return, and see what happens.\nNow try entering \"Hello World\" (make sure you put the quotes).\nNew try entering print(\"Hello World\") (make sure you put the parentheses and quotes).\nNotice the subtle difference in how Julia evaluates those expressions?\nWith the above, you are using the REPL, the Read-Evaluate-Print-Loop. This is a common way of running Julia. (Another way is to save scripts and execute them, but that is usually for more advanced use.)\nNow, go to the next page to learn (using arrow at lower right of this page) more about interacting with Julia.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Download and Install Julia"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I am a Professor of Zoology at the University of British Columbia, where I have the great fortune to work with a wonderful group of students. To learn more about our research, go to: https://www.zoology.ubc.ca/~irwin/irwinlab/\nDisclaimer: I am mostly self-taught in the area of computer science and programming, so you will likely find better sources to learn about those topics. My goal here is to help other biologists learn to start programming. I have chosen the Julia language because of its easy entry, its speed and memory efficiency, and because it has been hugely useful in my own research.\nThanks: I have benefitted greatly from many excellent courses available from organizations such as Compute Canada, the Digital Alliance of Canada, and UBC Advanced Research Computing. I also thank the many YouTubers, bloggers, and book authors who provide excellent information about Julia and other languages. And of course I thank the inventors of Julia (you can learn more at https://en.wikipedia.org/wiki/Julia_(programming_language)).\nThis whole website was generated using Quarto, which allows embedding of runnable Julia code.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.",
    "crumbs": [
      "Home",
      "Basics",
      "About"
    ]
  },
  {
    "objectID": "Plots.html",
    "href": "Plots.html",
    "title": "Plots",
    "section": "",
    "text": "Plotting is a huge topic. Here I‚Äôll do my best to give you an efficient introduction to key concepts and commands, equipping you with the tools to build plots of arbitrary complexity. My emphasis here is on ‚Äòlow-level‚Äô commands (e.g.¬†draw a point, draw a line), rather than ‚Äòhigh-level‚Äô commands (e.g.¬†make a polished fancy plot in a single command). I emphasize the former because it will give you the confidence and power to develop plots to do whatever you want, and it is easy to learn the high-level commands later.\nThere are a number of different plotting packages in Julia, many of them excellent in different ways. Here we will use the ‚ÄòPlots‚Äô package because it is perhaps simplest to work with and is most integrated (or composable) with other packages in the Julia ecosystem. (After some experience with this package, a lot of your knowledge will be transferable to other packages.)\n\nAdd the Plots package\nIf you haven‚Äôt already done so (perhaps you did this several pages prior), install the Plots package as follows:\nIf using the REPL, type ] to activate the Package mode, then enter add Plots . Then press the delete key to return to the main REPL, and enter using Plots.\nIf using Pluto, simply type add Plots in a code cell and then shift-enter to execute the cell.\nThese steps might take quite a bit of time because the package and its dependencies are big.\n\n\nMake a simple plot\nWe‚Äôll make a simple plot and learn some of the functions involved.\n\nDraw some lines\nLet‚Äôs define some x values and y values of points, and then plot them by connecting those points with lines:\n\nusing Plots\nxValues = [1.5, 1.8, 2.3, 2.7, 3.2, 3.5]\nyValues = [2.8, 2.5, 2.3, 2.3, 2.5, 2.8]\nplot(xValues, yValues, linewidth=3)\n\n\n\n\nSo we drew some lines between the points defined those coordinates.\n\n\nDraw some points\nNow, let‚Äôs say we want to add some points to the same plot. We can use scatter!() :\n\nscatter!([2.1, 2.9], [3.5, 3.5])\n\n\n\n\nThe ! in the scatter!() function is used to indicate that this function will change the existing plot (rather than make a new plot).\n\n\nDraw a shape\nNow, let‚Äôs add a filled shape to the same plot:\n\nplot!(Shape([2.4, 2.5, 2.6], [2.9, 3.1, 2.9]))\n\n\n\n\nHere, we created a Shape object and fed that as an argument to the plot!() function.\nAs the plot was updated, you can see that the Plots package adjusted the limits of the x and y axes to fit the plotted points. We can control that ourselves:\n\nplot!(xlim = [1, 4], ylim = [2, 4])\n\n\n\n\n\n\nYou can change just about anything in the plot\nWe can adjust all sorts of other things about the plot. For instance, add axis labels and a title, and remove the legend:\n\np1 = plot!(title = \"A happy plot\",\n    xlabel = \"My x axis\",\n    ylabel = \"My y axis\",\n    legend = false)\n\n\n\n\nTo find out more about attributes of plots and how to change them, type ??plot in the Julia REPL (the first ? will activate the help mode, and then enter ?plot).\nIn the last code block above, we both generate a plot and assign it to the name p1, which gives us a way to invoke it later (you‚Äôll see why further below).\n\n\n\nShow mathematical functions\nAbove, we fed the plot function a set of x and y values. We can also feed it a function, and it will do its best to provide a reasonable plot of the function:\n\nplot(sin)\n\n\n\n\nWe can add some more functions to the plot:\n\nplot!(x -&gt; 3cos(x))\np2 = plot!(x -&gt; (x^2 - 5))\n\n\n\n\nIn the above, the arguments given to plot!() are anonymous functions. This means they are not given names and are not stored in memory. Rather, the syntax x -&gt; f(x) simply provides a mapping of x onto y values, and the plot!() function interprets that and shows us a part of the relationship.\n\nAdd text to the plot\nWe can use the annotate!() function to add text to our plot, at the desired coordinates:\n\nannotate!(-3, 10, \"Here's some text\", :left)\n\n\n\n\nThis adds text at location -3, 10 and the :left indicates that it should be left-aligned to that location.\n\n\nParametric plots\nAnother way we can invoke a plot is to provide it two functions, both of which depend on a variable that ranges from a minimum value to a maximum value. We call the function in this format: plot(x_function, y_function, minimum, maximum) :\n\nplot(sin, cos, 0, 2pi)\nplot!(aspect_ratio = :equal)\n\n\n\n\n\nplot(x -&gt; x*sin(x), x -&gt; x*cos(x), 0, 2pi)\np3 = plot!(aspect_ratio = :equal, legend=false)\n\n\n\n\n\n\n\n3D plots\nWe can expand from the above to 3 dimensions:\n\ntime = 0:0.1:20\nxvals = sin.(time)\nyvals = cos.(time) \nzvals = time\np4 = plot(xvals, yvals, zvals)\n\n\n\n\n\nSurface plots\nThis is one kind of 3D plot, where we have a value for z at every value of x and y:\n\nxes = -1:0.01:1\np5 = surface(xes, xes, (x, y) -&gt; x^2 + y^2, legend=false)\n\n\n\n\nHere, the first argument is the x values, the second is the y values, and the third is the z values, which in this case we provided as an anonymous function relating x and y to z.\n\n\nHeatmaps\nWe can show the above as a heatmap:\n\np6 = heatmap(xes, xes, (x, y) -&gt; x^2 + y^2)\n\n\n\n\nThere are many other kinds of plotting commands. Keep in mind though that if it is difficult to find a high-level command to do exactly what you want, the low-level commands for plotting points, lines, and shapes along with some good logical thinking will result in anything you can imagine!\n\n\n\nLayouts\nWe can combine separate plots into one figure quite simply. We first define each plot and assign it a name, resulting in it being stored as an object in memory. Then, we assemble these into a figure.\nAbove, we defined a series of plots and gave them the names p1 through p5. We‚Äôll now call the `plot() function in a way that causes some of these to be plotted as panels in one graphing window:\n\nplot(p1, p2, p4, p5)\n\n\n\n\nBecause we have provided four plots to be shown, the default assumption is that we want a 2x2 grid. We can alter this by using the layout keyword and grid() functions:\n\nplot(p1, p3, p6, layout = (1, 3))\n\n\n\n\nTry switching the 3 and 1 to see what you get.\n\nplot(p3, p4, p6, p5, layout = grid(2, 2, heights=[0.4, 0.6], widths=[0.3, 0.7]))\n\n\n\n\n\nThe @layout macro\nEarlier, we learned about how the @ symbol is used to indicate a macro, something that is a tool to write non-standard code that is then re-written by the macro into actual Julia code. You can think of it as a convenient shortcut. The @layout macro is a wonderful example:\n\nplot(p1, p2, p3, p4, p5, p6, \n    layout = @layout [ s s s\n                        s s\n                         s])\n\n\n\n\nAfter the @layout, we simply write brackets within which is a visual representation of the layout of the plot. The s symbol here is arbitrary‚Äîyou can use whichever letter you want‚Äîthe key thing is that the pattern of white space and line breaks between the symbols conveys to the macro what the layout arrangement should be.\nIf we want our sub-plots to take up differing amounts of space, we can add that in this way:\n\nbigPlot = plot(p4, p5, p1, p2, p3, p6, \n                layout = @layout [ s s s\n                                s{0.8w} s\n                                s{0.2h}])\n\n\n\n\nThe {0.8w} and {0.2h} mean that that subplot should take up 0.8 proportion of the width or 0.2 proportion of the height.\n\n\n\nSave your plot\nWe can now save the plot, and give a path/filename that ends by designating the format (e.g.¬†pdf, png, jpg):\nsavefig(bigPlot, \"myplot.pdf\")\n\n\nNext steps\nThis has been a quick intro to plotting, but I hope it gives a good idea of the rich capability of the Plots package and how to get started producing your own plots in Julia.\nNow that we have a good understanding of the key elements of programming and have some plotting tools, let‚Äôs build an actual simulation!",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Plots"
    ]
  },
  {
    "objectID": "MoreFunThings.html",
    "href": "MoreFunThings.html",
    "title": "More Fun Things",
    "section": "",
    "text": "This series of tutorials have brought us through the essentials of how to write programs in Julia, and how to set up Pluto notebooks or VS Code programming environments. The material was designed to be about the most that could be covered in a 1-credit grad-level university course for students without any programming experience at the start. At the end of such a course, some students might be wanting some pointers to learn more. So here goes:",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "More Fun Things"
    ]
  },
  {
    "objectID": "MoreFunThings.html#some-other-really-neat-julia-packages",
    "href": "MoreFunThings.html#some-other-really-neat-julia-packages",
    "title": "More Fun Things",
    "section": "Some other really neat Julia packages",
    "text": "Some other really neat Julia packages\nIn these tutorials we‚Äôve used a number of packages: Plots, Pluto, Markdown (automatically within Pluto), GenomicDiversity, Downloads, CSV, DelimitedFiles, DataFrames, Impute, About, Random, Pkg.\nBut there are over 10,000 more out there! Here are some neat ones that you might like to try at some point:\nLuxor: for amazing graphics\nFlux: machine learning\nPyCall: call Python from Julia.\nRCall: call R from Julia.\nUnicodePlots: plot in the Terminal.\nMakie: an alternate plotting package, good for interactive visualizations.\nStatsKit: a meta-package containing many statistics-related packages.\nJavis: animations and visualizations.\nUnitful: do math while including the physical units.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "More Fun Things"
    ]
  },
  {
    "objectID": "MoreFunThings.html#call-r-and-python-from-within-julia",
    "href": "MoreFunThings.html#call-r-and-python-from-within-julia",
    "title": "More Fun Things",
    "section": "Call R and Python from within Julia",
    "text": "Call R and Python from within Julia\nThe RCall and PyCall packages allow you to call R and Python from within Julia. Note that you need to have these installed on your computer for this to work‚Äîif you do, then try this in a series of Pluto cells:\n\nusing RCall\n\n\nbegin\n    R\"x &lt;- c(2, 3, 7)\"\n    R\"y &lt;- x^2\"\nend\n\nRObject{RealSxp}\n[1]  4  9 49\n\n\nWe just ran some calculations in R! We can even pass objects back and forth between Julia and R:\n\nbegin\n    myJuliaObject = [4, 3, 2, 1]\n    R\"myRObject &lt;- $myJuliaObject\"  # string interpolation to pass Julia object to R\nend\n\nRObject{IntSxp}\n[1] 4 3 2 1\n\n\nThe above returns an object that is of type RObject in Julia. It is essentially a pointer in Julia to an object in the R environment. To actually use it in Julia, we would need to convert to a proper Julia object. In this next code block, we‚Äôll use R to cube each number and then we‚Äôll return the vector to Julia:\n\nbegin\n    R\"newRObject &lt;- myRObject^3\"\n    newJuliaObject = @rget newRObject  # macro that converts R object to Julia object \nend\n\n4-element Vector{Float64}:\n 64.0\n 27.0\n  8.0\n  1.0\n\n\nIf you want a real surprise, type $ at the Julia prompt in the REPL, after you have loaded the RCall package (import Pkg; Pkg.add(\"RCall\"); using RCall). Hint: Try typing some R code!\nSimilar interaction can be done with Python, using the PyCall package.\nSo, you don‚Äôt have to choose a single programming language. You can pass data back and forth, and use the best data analysis packages for your purposes.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "More Fun Things"
    ]
  },
  {
    "objectID": "MoreFunThings.html#include-physical-units-in-your-calculations",
    "href": "MoreFunThings.html#include-physical-units-in-your-calculations",
    "title": "More Fun Things",
    "section": "Include physical units in your calculations",
    "text": "Include physical units in your calculations\nOften when working on a calculator or computer, we separate numbers from their physical units (e.g., meters, seconds), do the calculation on the numbers, and then write the answer next to some unit designation that we work out separately. This can lead to errors‚Äìfor example a spacecraft crashed into Mars because two teams of engineers were using different units in their calculations.\nSo, wouldn‚Äôt it be great if there were a way for the units to stay with the numbers? The Unitful package provides a way! In Pluto, enter this series of cells:\n\nusing Unitful\n\n\ntimespan = 1u\"minute\" + 3u\"s\"\n\n63 s\n\n\nJulia now understands that 1 minute plus 3 seconds is 63 seconds. Note the syntax: the u means unit, and we follow that with double quotes and a string with the unit name (there are a whole bunch of standard units included in the package).\nLet‚Äôs say we are studying a walking animal, and it goes 100 meters in the timespan calculated above. Let‚Äôs calculate its speed:\n\nspeed = 100u\"m\" / timespan\n\n1.5873015873015872 m s‚Åª¬π\n\n\nThe answer is expressed in units of m s‚Åª¬π. Perfect!\nWe are just touching the surface of what can be done with the Unitful package. One neat thing is conversions, using uconvert():\n\nuconvert(u\"kg\", 100u\"g\")\n\n1//10 kg\n\n\nThis tells us the 100 grams (the second argument) is the same as 1/10 kg (in the units of the first argument). Notice that the answer is actually given as 1//10 (with two forward slashes), indicating it is a Rational{Int} type so that subsequent calculations are precise.\nWe can learn about unusual units this way:\n\nuconvert(u\"kg\", 1u\"slug\")\n\n14.593902937206364 kg\n\n\nDid you know that 1 slug (a unit of mass, used in the olden days) is that many kilograms?",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "More Fun Things"
    ]
  },
  {
    "objectID": "MoreFunThings.html#add-more-interactivity-to-your-pluto-notebooks",
    "href": "MoreFunThings.html#add-more-interactivity-to-your-pluto-notebooks",
    "title": "More Fun Things",
    "section": "Add more interactivity to your Pluto notebooks",
    "text": "Add more interactivity to your Pluto notebooks\nAnother amazing package is PlutoUI. You can use this to add sliders, checkboxes, buttons, and menus to your Pluto notebooks, enhancing a user‚Äôs ability to interact with your notebooks. Try adding this series of code cells to a Pluto notebook:\nusing PlutoUI\n@bind yIntercept Slider(-10.0:0.1:10.0)\n@bind slope Slider(-1.0:0.1:1.0)\nbegin\n    f(x) = slope * x + yIntercept\n    plot(f; ylims = [-10.0, 10.0])\nend\nPlay around with the above by moving the sliders, and look what happens to the line on the plot.\nLet‚Äôs make a bunch of points that are roughly along that lie, but with some randomness. We‚Äôll choose the number of points with an interactive element called a Scrubbable:\nmd\"##### Let's graph $(@bind numPoints Scrubbable(100)) points\"\nIf you put your cursor on the number and drag right or left, the number changes. Now let‚Äôs write some code that depends on the variable that is represented by that number (numPoints):\nxValues = 10 .* rand(numPoints) .- 5\nbegin\n    xValues = 10 .* rand(numPoints) .- 5\n    # apply our f(x) function to each xValue and add some randomness:\n    fofX = f.(xValues) + randn(numPoints)\n    scatter(xValues, fofX; ylims = [-10.0, 10.0])\nend\nNow we have three ways to change the graph. Play around by moving the sliders and the scrubbable number of points.\nWe are just scratching the surface of how the PlutoUI package can be used.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "More Fun Things"
    ]
  },
  {
    "objectID": "MoreFunThings.html#multithreading",
    "href": "MoreFunThings.html#multithreading",
    "title": "More Fun Things",
    "section": "Multithreading",
    "text": "Multithreading\nMost of our computers now have multiple CPUs, so if we divide our computation into multiple threads we can often accelerate things. Julia has a super simple way of setting this up. If you start Julia in the terminal with julia -t 4 then Julia opens in a way where you can use up to four threads. You can confirm this by entering Threads.nthreads(), to which it should respond 4.\nThen, you can divide tasks among your four threads, using a simple @threads macro. It has this general structure:\nusing Base.Threads\n@threads for i in 1:10\n    # add some lines here that do some neat stuff \n    println(\"Loop $i was sent to thread $(threadid())\")\nend\nThis approach has the potential to speed up a complex calculation by almost a factor of 4 (in the case of four threads, more if on a machine with more CPUs).\nIf you plan to use multithreading, it is good to understand the concept of data-races and make sure each one of your iterations does not depend on output from another. Each should be its own self-contained task. Read more here.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "More Fun Things"
    ]
  },
  {
    "objectID": "MoreFunThings.html#quarto",
    "href": "MoreFunThings.html#quarto",
    "title": "More Fun Things",
    "section": "Quarto",
    "text": "Quarto\nAfter you have gained experience as a Julia programmer, you may want to record notes for yourself and others in a way where you can easily write text and run blocks of code. We have seen that Pluto notebooks are great for this. Another way is to use Quarto, which is a dynamic open-source publishing system.\nIn fact, this whole JuliaProgrammingForBiologists website was written using Quarto. I chose it because I could easily write this text while including live code blocks that actually run. I am now writing this as a .qmd file (abbreviated from Quarto MarkDown), and when I tell Quarto to render the file it then converts it to HTML, running the code blocks as it goes. We can use Quarto to publish web pages, whole web sites such as this one, PDF documents, Word documents, etc. You can include pages with Julia, Python, and R.\nTo learn more about how to get set up with Quarto, see my own tutorial on that topic or the Quarto homepage.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "More Fun Things"
    ]
  },
  {
    "objectID": "Randomization.html",
    "href": "Randomization.html",
    "title": "Randomization in Simulation and Statistics",
    "section": "",
    "text": "The concept of random events is central to our understanding of many biological processes (e.g.¬†mutation, genetic drift) and to hypothesis testing using data from a sample. Hence, we biologists often need to use random numbers in our computer programming. Random numbers enable us to model probabilistic processes, where different outcomes occur some pre-defined proportion of the time, if we were to do the process a very large number of times.\nAn interesting fact though is that computers cannot truly pick totally random numbers. Rather, there are deterministic algorithms that do a great job of producing series of numbers that have little apparent relationship with each other, and that appear to occur with equal probability over some range of values. These are often called ‚Äòpseudorandom numbers‚Äô.\nThese algorithms start with a random number seed, and if you give a certain algorithm the same seed and run it twice, it will produce the same series of ‚Äòrandom‚Äô numbers. This can be useful if for instance you are testing a simulation and you want to ensure it produces the same output after you‚Äôve made some small change to the code. Other times though, you want your random numbers to be as unpredictable as possible. For this we can use an arbitrary seed that we have never tried before; different seeds will produce totally different random sequences. A neat trick is to look up the time on the computer‚Äôs clock and use digits representing the number of milliseconds (after the last whole second) as the random number seed; this way the programmer cannot even predict the seed before running the code.\nMost of the time though, we don‚Äôt need to think at all about the way Julia is generating random numbers, as it uses an excellent algorithm and uses an arbitrary seed based on difficult-to-predict aspects of the computer‚Äôs state. So generating random numbers in Julia is easy!\n\nThe rand() function\nTo get a random number between 0 and 1, we simply write the rand() function with no arguments:\n\nrand()\n\n0.9513278298855148\n\n\nThe output of this default use of the funtion is a floating-point number (that is, it is of type Float64).\nTry running that a few times to see that the output is indeed random.\nBetter yet, let‚Äôs run it 10 times in one command:\n\nrand(10)\n\n10-element Vector{Float64}:\n 0.6275710337698648\n 0.04413533319420171\n 0.579586008929356\n 0.5909601399754812\n 0.8835522543885165\n 0.19306858302836616\n 0.689967165029623\n 0.3719583928828004\n 0.03777268058435035\n 0.27471557212528785\n\n\nThis shows that including an integer as the one argument tells Julia to generate that many random numbers (each a Float64 between 0 and 1).\nBut the rand() function makes great use of multiple dispatch. If we include a type as the one argument, it gives us a random value for that type:\n\nrand(Int8)\n\n-34\n\n\nThe returned value here is a random integer within the range of possible Int8 values.\nTo randomly produce true or false:\n\nrand(Bool)\n\nfalse\n\n\nIf we instead put a range as the one argument, Julia returns a number in that range:\n\nrand(1:6)\n\n4\n\n\nThe above simulates the role of a 6-sided die. Try it a few times.\nOr we can give a vector or tuple containing a set of values to choose from:\n\nrand([0, pi, 2pi])  # the brackets indicate a vector (i.e., an array)\n\n0.0\n\n\n\nrand(('A', 'C', 'G', 'T'))  # the parentheses indicate a tuple\n\n'C': ASCII/Unicode U+0043 (category Lu: Letter, uppercase)\n\n\nWe can even write the above example more concisely, by providing all the Chars together as a String:\n\nrand(\"ACGT\")\n\n'G': ASCII/Unicode U+0047 (category Lu: Letter, uppercase)\n\n\nThere is great flexibility in how we can use the rand() function:\n\nrand([1, \"DNA\", false], (2,5))\n\n2√ó5 Matrix{Any}:\n 1       1       false  \"DNA\"  1\n  \"DNA\"   \"DNA\"  false  \"DNA\"   \"DNA\"\n\n\nAbove, we provided as arguments both the set of possible outcomes and a tuple indicating the dimensions and size of the matrix to produce.\n\n\nSetting up to get random numbers that are reproducible (!?!)\nIf we want our code to produce and use the same sequence of ‚Äòrandom‚Äô numbers, we need to load the Random package:\n\nusing Random\n\nThe rand() function can accept an optional first argument that specifies the random number generator. Here, we will use the Xoshiro algorithm (now the default in Julia) and give it an arbitrary seed of 321:\n\nrand(Xoshiro(321), 5)\n\n5-element Vector{Float64}:\n 0.6893036297831823\n 0.22036324422357434\n 0.7799494887616285\n 0.2330428384897486\n 0.8716295743088799\n\n\nLet‚Äôs see if we run that again:\n\nrand(Xoshiro(321), 5)\n\n5-element Vector{Float64}:\n 0.6893036297831823\n 0.22036324422357434\n 0.7799494887616285\n 0.2330428384897486\n 0.8716295743088799\n\n\nWe get the same sequence of numbers. The numbers are ‚Äòrandom‚Äô in some sense, but repeatable. Try changing the value of the seed, and see what happens.\nInstead of setting up a random number generator each time we call the rand() function, we might want to set up a random number generator and then use that throughout our program. That way, the set of numbers in our program is never repeated within our program, but the whole program will run the same each time. For this, we set up a random number generator (‚Äòrng‚Äô) and use that each time:\n\nrng = Xoshiro(321)\nrand(rng, 5)\n\n5-element Vector{Float64}:\n 0.6893036297831823\n 0.22036324422357434\n 0.7799494887616285\n 0.2330428384897486\n 0.8716295743088799\n\n\n\nrand(rng, 5)\n\n5-element Vector{Float64}:\n 0.02894933089311269\n 0.07474632097497813\n 0.38509511194135615\n 0.6081412740086088\n 0.17766823446325286\n\n\nNow our two sets of numbers above are different (so ‚Äòrandom‚Äô with respect to each other), but reproducible on a larger level. (You can test this by rerunning the three lines of code above.)\nWe can use our generator to choose among specified options using a construction like this:\n\nrand(rng, [\"yes\",\"no\",\"maybe\"], 5)\n\n5-element Vector{String}:\n \"maybe\"\n \"maybe\"\n \"no\"\n \"yes\"\n \"maybe\"\n\n\n\n\n\n\n\n\nTipMake some DNA\n\n\n\nWrite a function that produces a pseudo-random DNA sequence (using the letters A, C, G, T), of a length provided to the function. Ensure that your function always provides the same sequence, such that the only thing that differs between function calls is the length of the sequence. (You might find this useful: the function join() useful, as it assembles a string out of elements in a vector, e.g.¬†join([2,\"A\"]) returns \"2A\".)\n\n\n\n\nNormally-distributed random numbers\nOften in the context of biology, we want normally-disributed random numbers. To draw from a normal distribution with mean 0 and standard deviation 1, use this function:\n\nrandn()\n\n1.1994907782475621\n\n\n\n\n\n\n\n\nTipMake a cell move\n\n\n\nMake a graph showing the path of a cell that has moved randomly in 2-dimensional space. (Hint: Start the cell at a certain location give by an x and y value, and then alter the x and y values by adding independent random values)\n\n\n\n\nMake a null distribution\nNow that we know how to randomly sample from a set of outcomes, we can generate our own null distributions and use them in statistical tests of our data. Here is a simple example, borrowed from the UBC BIOL 300 teaching material (thanks to Mike Whitlock) and based on the data in this paper:\nHill, RA, and RA Burton 2005. Red enhances human performance in contests. Nature 435:293\nIn the 2004 olympics, athletes in four combat sports (boxing, taekwondo, Greco-Roman wrestling, and freestyle wrestling) were randomly assigned red or blue clothing. Given the random assignment, if color has no effect on the probability of winnning, then we expect about half of matches to be won by each color. In actuality, there were more red than blue winners in 16 rounds of competition, and more blue than red winners in only 4 rounds. Is this convincing enough evidence that color had a psychological effect on the athletes, or is it plausible that this outcome was just by chance?\nWell, let‚Äôs generate a null distribution for the number of rounds won by red (out of 20 rounds), assuming color had no actual effect. To do this we can simulate red randomly winning or losing, do that 20 times, and record the number of red wins as one possible result when color has no effect. We can then do that whole process a large number of times and observe the proportion of times that we get a result of 16 red wins or something equally or more extreme. (This is an estimate of the P-value.)\n\nfunction getSimulatedRedWins()\n    redWins = 0  # initialize the counter at zero\n    for i in 1:20  # loop through 20 rounds\n        winner = rand([\"red\",\"blue\"])  # pick a random winner for one round\n        if winner == \"red\"  # if red winner, add one to the count of red wins\n            redWins = redWins + 1 \n        end\n    end\n    return redWins\nend\n\ngetSimulatedRedWins()\n\n9\n\n\n\n\n\n\n\n\nTipTry another way of writing the above function\n\n\n\nA fun thing about programming is there are many ways to solve a problem. Try different approaches for writing the function above. Can you figure out a way that doesn‚Äôt use a for loop?\nAlso, can you make the above function more general in some way? For instance, can you make it such that the number of rounds (20) is not fixed but can entered as an argument to the function?\n\n\nWe now have a function to get one simulated value for the number of red wins under the null hypothesis of no advantage for red. Lets run this many many times and generate a null distribution:\n\nfunction getManySimResults(numSims)\n    simRedWins = fill(-9, numSims) # make vector for data, with obviously wrong value\n    for i in 1:numSims  # loop through simulations\n        simRedWins[i] = getSimulatedRedWins()\n    end\n    return simRedWins\nend\n\nnullValues = getManySimResults(1_000_000)\n\nusing Plots\n\nhistogram(nullValues, bins = (0:21) .- 0.5, legend=false, xlabel = \"Number of red wins\",\n    ylabel = \"Number of simulations\",)\n\n\n\n\nThe graph shows the distribution of the number of red wins out of 20 trials, under the null hypothesis that the probabilities of red vs.¬†blue winning are both 50%.\n\n\nEstimate a P-value\nWe can now compare our real data (16/20 wins were for red) and ask how much of our null distribution is that extreme or even more extreme. Hence we‚Äôll add up the proportion of simulations with 16 or more red wins. Then, we‚Äôll multiply by 2 to include the other extremes on the blue-winning side (making this a two-tailed test):\n\nnumExtremeSims = 2sum(nullValues .&gt;= 16)\n\n12042\n\n\nOur estimated P-value will be that number divided by the number of simulations:\n\npValue = numExtremeSims / length(nullValues)\n\n0.012042\n\n\nIf you have a statistics background, you might have noticed the above situation is perfectly suited for a binomial test. In fact, the distribution that we simulated is extremely close to a binomial distribution. The only reason it differs is because our number of simulated outcomes is finite‚Äìmeaning there are chance differences between or simulated distribution and the theoretical distribution, which is given by the binomial theorem.\nWe can compare our estimated P-value above with the P-value produce by a binomial test. For this, we‚Äôll add a package to our Julia environment and then use it:\nusing Pkg  # this loads the Pkg package\nPkg.add(\"HypothesisTests\")  # this downloads and installs the HypothesisTests package \n\nusing HypothesisTests\nBinomialTest(16, 20, 0.5)\n\nBinomial test\n-------------\nPopulation details:\n    parameter of interest:   Probability of success\n    value under h_0:         0.5\n    point estimate:          0.8\n    95% confidence interval: (0.5634, 0.9427)\n\nTest summary:\n    outcome with 95% confidence: reject h_0\n    two-sided p-value:           0.0118\n\nDetails:\n    number of observations: 20\n    number of successes:    16\n\n\nThis command shows that the p-value of a precise binomial test (0.0118) is extremely close to our estimate based on a large number of simulations. (Doing an even larger number of simulations will tend to make the estimate even closer to the precise value from the binomial test.)\nThe P-value is below the usual significance threshold of 0.05, so the authors rejected the null of no effect of colour on winning, and concluded there is an advantage provided by wearing red rather than blue.\n\n\nPermutation (or Randomization) test\nAbove, we used simulated data sets to generate a null distribution for a single variable (number of red wins out of 20 trials). We can use a related approach when interested in the association of two variables. We do this by assuming the null hypothesis of no association is true, and then repeatedly and randomly shuffle the values in the dataset to make a bunch of new datasets. We calculate a summary statistic from each shuffled dataset, and the distribution of those summary statistics is our null distribution for that statistic. If the statistic from our real data is in the extreme tails of that distribution, we can then reject the null and conclude that there is in fact an association between the variables. This procedure is called a permutation test or randomization test.\nLet‚Äôs do a permutation test on data from this publication:\nJohnson et al. (1999) Female remating propensity contingent on sexual cannibalism in sagebrush crickets,¬†Cyphoderris strepitans: a mechanism of cryptic female choice. Behavioral Ecology 10: 227-233.\nWhen these crickets mate, the male offers his hindwings for the female to eat. The question was: Why would they do such a thing?!? One idea: if the females get some nutrients from the wings, maybe they wait longer to remate (with another male), the implication being that males who feed females their wings might father more offspring.\nLet‚Äôs load a dataset containing times to remating for two experimental groups of females: those mated initially with a winged male (and who mostly ate his wings) and those mated initially with a wingless male (where wings had been surgically removed).\n\nusing CSV, DataFrames, Downloads\ncricket_file_URL = \"https://github.com/darreni/JuliaProgrammingForBiologists/raw/refs/heads/main/example_data/cricketData.csv\"\ncricketData = DataFrame(CSV.File(Downloads.download(cricket_file_URL)))\n\n25√ó2 DataFrame\n\n\n\nRow\nMale_state\nLog_remating_time\n\n\n\nString15\nFloat64\n\n\n\n\n1\nMale_wingless\n0.0\n\n\n2\nMale_wingless\n0.7\n\n\n3\nMale_wingless\n0.7\n\n\n4\nMale_wingless\n1.4\n\n\n5\nMale_wingless\n1.6\n\n\n6\nMale_wingless\n1.8\n\n\n7\nMale_wingless\n1.9\n\n\n8\nMale_wingless\n1.9\n\n\n9\nMale_wingless\n1.9\n\n\n10\nMale_wingless\n2.2\n\n\n11\nMale_wingless\n2.1\n\n\n12\nMale_wingless\n2.1\n\n\n13\nMale_winged\n1.4\n\n\n14\nMale_winged\n1.6\n\n\n15\nMale_winged\n1.9\n\n\n16\nMale_winged\n2.3\n\n\n17\nMale_winged\n2.6\n\n\n18\nMale_winged\n2.8\n\n\n19\nMale_winged\n2.8\n\n\n20\nMale_winged\n2.8\n\n\n21\nMale_winged\n3.1\n\n\n22\nMale_winged\n3.8\n\n\n23\nMale_winged\n3.9\n\n\n24\nMale_winged\n4.5\n\n\n25\nMale_winged\n4.7\n\n\n\n\n\n\nLet‚Äôs make some quick histograms showing the distribution of remating time for each group:\n\nusing Plots\np1 = histogram(cricketData.Log_remating_time[cricketData.Male_state .== \"Male_wingless\"], bins=0:0.5:5, xlims=[0,5], title=\"females mated to wingless males\", ylabel=\"frequency\")\n\np2 = histogram(cricketData.Log_remating_time[cricketData.Male_state .== \"Male_winged\"], bins=0:0.5:5, xlims=[0,5], title=\"females mated to winged males\", xlabel=\"Remating time\", ylabel=\"frequency\")\n\nplot(p1, p2,\n    layout = @layout [p\n                      p])\n\n\n\n\nIf we want to test whether the two groups differ (beyond chance differences due to sampling error), we might be uncomfortable with a 2-sample t-test because that would require assumptions of normality and equal variance. Instead, we can do a permutation test.\nThe permutation test assumes nothing about the underlying distributions, simply holding up the null hypothesis of no difference in distributions between the two categories. We‚Äôll test this by generating a null distribution for the difference in mean remating time between the two categories, and then compare our real difference to that null distribution.\nLet‚Äôs make a function to calculate the difference in means:\n\nfunction calculateCricketMeanDiffs(data::DataFrame)\n    winged = data.Log_remating_time[data.Male_state .== \"Male_winged\"]\n    wingless = data.Log_remating_time[data.Male_state .== \"Male_wingless\"]\n    sum(winged)/length(winged) - sum(wingless)/length(wingless)\nend\n\ncalculateCricketMeanDiffs (generic function with 1 method)\n\n\nNow use that to calculate the difference in real group means:\n\nrealDiff = calculateCricketMeanDiffs(cricketData)\n\n1.4134615384615383\n\n\nSo we have our real difference. Let‚Äôs compare that to possible differences we get if there is no real association between male state and remating time. We‚Äôll shuffle the values of one variable (using the well-named shuffle() function) and construct a null distribution of mean differences:\n\nusing Random  # needed for the shuffle() function\nfunction permuteOnce(data::DataFrame)\n    permutedData = copy(data)  # this makes a copy of the dataframe, so original not altered\n    shuffle!(permutedData.Log_remating_time)  # can specify a random number generator as a first argument, if desired\n    return permutedData\nend\n\n# Test the function above:\npermuteOnce(cricketData)\n\n25√ó2 DataFrame\n\n\n\nRow\nMale_state\nLog_remating_time\n\n\n\nString15\nFloat64\n\n\n\n\n1\nMale_wingless\n2.2\n\n\n2\nMale_wingless\n1.9\n\n\n3\nMale_wingless\n4.5\n\n\n4\nMale_wingless\n3.8\n\n\n5\nMale_wingless\n0.0\n\n\n6\nMale_wingless\n1.9\n\n\n7\nMale_wingless\n1.4\n\n\n8\nMale_wingless\n2.3\n\n\n9\nMale_wingless\n1.9\n\n\n10\nMale_wingless\n2.8\n\n\n11\nMale_wingless\n1.8\n\n\n12\nMale_wingless\n1.9\n\n\n13\nMale_winged\n0.7\n\n\n14\nMale_winged\n1.4\n\n\n15\nMale_winged\n2.1\n\n\n16\nMale_winged\n1.6\n\n\n17\nMale_winged\n1.6\n\n\n18\nMale_winged\n2.1\n\n\n19\nMale_winged\n2.8\n\n\n20\nMale_winged\n3.1\n\n\n21\nMale_winged\n2.8\n\n\n22\nMale_winged\n4.7\n\n\n23\nMale_winged\n2.6\n\n\n24\nMale_winged\n3.9\n\n\n25\nMale_winged\n0.7\n\n\n\n\n\n\n\nfunction permuteMany(data::DataFrame, reps::Int)\n    nullDiffs = Vector{Float64}(undef, reps) \n    for i in 1:reps\n        permutedData = permuteOnce(data)\n        nullDiffs[i] = calculateCricketMeanDiffs(permutedData)\n    end\n    return nullDiffs\nend\n\npermutedDiffs = permuteMany(cricketData, 10_000)\n\n10000-element Vector{Float64}:\n  0.259615384615385\n -0.75\n -0.41346153846153877\n  0.5801282051282051\n -0.2852564102564106\n  0.4198717948717956\n  0.7884615384615385\n -0.04487179487179471\n -0.6698717948717943\n -0.34935897435897445\n  ‚ãÆ\n -0.25320512820512864\n -0.0288461538461533\n -0.5096153846153846\n -0.2692307692307687\n -0.621794871794872\n  0.21153846153846168\n  0.3717948717948718\n -0.5576923076923077\n -0.044871794871795156\n\n\nNow let‚Äôs plot our null distribution and our real value:\n\nhistogram(permutedDiffs)\nplot!([realDiff, realDiff], [0, 200], color=\"red\", width=5)\n\n\n\n\nSo our real value (shown in red) is quite extreme compared to the null distribution of our test statistic, given the null hypothesis of no association between the experimental group and the response variable. This causes us to doubt the null. We can estimate the p-value by determining how many simulated values were beyond our actual value (times 2 to make it a 2-tailed test):\n\npValue = 2sum(permutedDiffs .&gt;= realDiff) / length(permutedDiffs)\n\n0.0008\n\n\nOur estimate of the p-value tends to become more precise if we increase the number of permutations (see several cells up, where we called the permuteMany() function).\nThe p-value is far below the usual standard alpha of 0.05, so we are comfortable in rejecting the null and concluding that experimental removal of male hindwings does appear to shorten the remating time of females mated to that male (at least in this species of cricket).\n\n\nHave fun with randomness!\nI find experimenting with randomness can be one of the most enjoyable aspects of writing computer simulations. I think this is one reason humans enjoy games of chance‚Äìthere is a surprising aspect to randomness, but also a strange sense of order can go along with it. Using functions like rand(), randn(), and shuffle(), I encourage you to have fun incorporating randomness into your programming.\n\n\nNext steps\nWe now have all the essential tools for writing programs to do all sorts of neat things. One thing we haven‚Äôt explored much yet is how to important a really big dataset into Julia and then do some neat analyses on it. We‚Äôll look at an example of this on the next page.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Randomization in Simulation and Statistics"
    ]
  },
  {
    "objectID": "UseVSCode.html",
    "href": "UseVSCode.html",
    "title": "Use an Integrated Development Environment (IDE)",
    "section": "",
    "text": "We have now learned two interfaces for coding in Julia: 1) using the REPL; 2) using Pluto. The REPL is good for interactive use, using single commands or short scripts. Pluto is excellent for developing somewhat longer scripts in a stepwise manner, but still not great for really long and comnplex programs. For developing large programming projects, we often will want to use a highly capable text editor (e.g.¬†Emacs, Vim) or an Integrated Development Environment (IDE). (If you‚Äôve used RStudio, then you‚Äôve already used an IDE‚Äìbut it only works with R and Python.)\nVisual Studio Code (or VS Code for short) has become the widely recommended IDE for Julia. VS Code can be used to program in just about any language (e.g.¬†R, Python, C, HTML), so investment of time in learning it can be rewarding whatever languages you may use in the future. VS Code is highly customizable through the loading of extensions, and there are excellent and easily loaded extensions that facilitate programming in Julia using VS Code.\nOne hesitation I have in introducing VS Code is that because it is a highly capable and customizable IDE, it looks visually complex and can have a somewhat steep learning curve. For this reason, if you are enjoying the simplicity of using Julia just via the REPL and/or Pluto, then it might be wise to stick to those until you build up more experience, and then try VS Code.\n\nInstall VS Code with the Julia extension\nTo install VS Code, follow the instructions under the ‚ÄúGetting Started‚Äù heading on this web page: https://code.visualstudio.com/docs/languages/julia (Note that you already have Julia installed, so you can skip that step.) I will repeat the key steps here too:\n\nInstall VS Code for your computer here: https://code.visualstudio.com/download.\nStart VS Code, and in the top menu bar choose View-&gt;Extensions, then type in Julia in the ‚ÄúSearch Extensions‚Äù box, then select the Julia extension and click its install button.\n\n\n\nStart a Julia script file\nTo stay organized, first choose File-&gt;Open Folder, and click the New Folder button at the lower left, and name a new folder something creative like ‚ÄúMyFirstJuliaVSCodeFolder‚Äù.\nThen open a new file in the folder‚Äìthere are many ways to do this‚Äìone of these is to click on the Explorer symbol (looks like some pages of paper) at upper left, then to the right of your folder name, click on the symbol that looks like a page with a plus sign. This is the New File command. A blank space for a file name will appear, and then choose a name ending in .jl. For example, myFirstJuliaFile.jl. The last .jl part is crucial, as it tells VS Code that this file is in the Julia language.\nAfter you press return, a window to the right opens with the name of your file at the top. This window is a text editor showing the contents of your file. It is empty at the start, so put something in there! For example, this is what I typed there:\n# This is a Julia file created in VS Code\n# by Darren Irwin\n# 6 October 2024\n\nmyText = \"I can count to \"\n\nrepeats = 3\n\nfor i in 1:repeats\nprintln(myText * string(i))\nend\n\n\nRun your script\nOnce you are happy with what is there, you save (File-&gt;Save) and then run the file by clicking the right-pointing triangle at upper right of the text window. This will open a REPL window (probably at bottom of your screen), run the code in the REPL, and output the results there.\n\n\nInteract with the REPL\nAnother way to interact with the REPL is to cut-and-paste code from your script into the REPL, running individual commands as you go. In this way, you can test out commands in the REPL, and when you know they work as intended you can include them in your growing script.\n\n\nInclude a plot\nLet‚Äôs see how VS Code displays plots. Add this to your Julia file (the one you made above) and then run the file again:\nusing Plots\nf(x) = x^2 - 3\nplot(f)\nIf your computer works like mine, you see a panel to the right that shows the plot. (The plot shows an upward-opening parabola.)\n\n\nExplore VS Code\nVS Code has far more features and complexities than I can summarize here. One key to using it is to learn just enough to do what you need to do, and don‚Äôt worry about the rest. Here are a couple helpful things to note at this point:\n\nAfter you run some Julia code and have a REPL open, you should see three little circles somewhere on the left side of the screen. This is a Julia symbol. If you click on this, you will see a list of the objects in Julia‚Äôs active memory‚Äìwhich can be very useful for seeing what your code has produced. (If you‚Äôve run the above code first, you will see objects such as myText and repeats and their values.)\nAn important tool in VS Code is the Command Palette. You can find this by clicking on the symbol that looks like a gear, in the lower left of the VS Code window, and choosing Command Palette in the popup window. Then a search bar opens at the top of the page, and you can type text related to the command you are looking for‚Äìfor example, try save and then choose File: Save to save the current file you are working on.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Use an Integrated Development Environment (IDE)"
    ]
  },
  {
    "objectID": "ResourcesForFurtherLearning.html",
    "href": "ResourcesForFurtherLearning.html",
    "title": "Further Learning",
    "section": "",
    "text": "If you would like to learn more about programming and data analysis using Julia, some of the resources I have used are listed below:\n\nBooks\nThere are a lot of these, and growing. Some I‚Äôve used and found very helpful:\nJulia for Data Science, by Bogumi≈Ç Kami≈Ñski\nPractical Julia: A Hands-On Introduction for Scientific Minds, by Lee Phillips\nJulia Data Science, by Jose Storopoli, Rik Huijzer, and Lazaro Alonso *Free!!\nStatistics with Julia, by Yoni Nazarathy and Hayden Klok *Free PDF download for UBC students through the UBC library. :)\n\n\nYoutube videos\nDoggo.jl, a series of great tutorials, though a bit odd in style\nIntro to Computational Thinking Course at MIT\nJulia language Youtube Channel\nA talk about Pluto.jl, by its main developer Fons van der Plas\n\n\nOnline courses\nThere are a growing number of these. One I‚Äôve done and recommend:\nProgramming with Julia, by ƒ∞lker Arslan\n\n\nOther websites\nJulia language website‚Äôs list of Julia tutorials\nJulia language documentation\nThe Julia manual\nThe Julia Forem\nThe Julia Discourse",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Further Learning"
    ]
  },
  {
    "objectID": "LoadDataAnalyzeGraph.html",
    "href": "LoadDataAnalyzeGraph.html",
    "title": "Load & Graph Data",
    "section": "",
    "text": "Here we‚Äôll bring together much of our Julia knowledge to actually analyze a large dataset.\nThe example here will be based on a dataset from this paper:\nMcCallum, Q., K. Askelson, F.F. Fogarty, L. Natola, E. Nikelski, A. Huang, and D. Irwin. 2024. Pronounced differentiation on the Z chromosome and parts of the autosomes in crowned sparrows contrasts with mitochondrial paraphyly: implications for speciation. Journal of Evolutionary Biology, voae004, https://doi.org/10.1093/jeb/voae004\nWe will load in a large dataset of genotypes throughout the genomes of Golden-crowned Sparrows and two forms of White-crowned Sparrows: pugetensis and gambelii. We will then use my own original Julia package called GenomicDiversity.jl to analyze and graph aspects of this dataset. (On 18 November 2024 this package became listed on the General Registry, meaning that you can install it simply by entering the package mode‚Äîby typing ]‚Äî and then entering add GenomicDiversity and then using GenomicDiversity to actually use it.)\nTo work through this example, start with a new Pluto notebook. Give it a name and save it, so your work will be continuously saved. You will use a set of data files that is included with the GenomicDiversity package. These are within a folder called Sparrow_data_McCallumetal2024 within the GenomicDiversity folder on your computer, but these can sometimes be a little difficult to find if you don‚Äôt know where to look. So below we will use commands that load these data files into Julia by grabbing them directly from my GitHub repository.\n\nLoad the GenomicDiversity package\nI wrote this set of functions to facilitate the analysis of and graphing of genomic data. To load download it and make it active in your Pluto notebook, write the following in a Pluto code cell and then run the cell:\nusing GenomicDiversity\nIt might take a couple minutes to download and install. After it completes, try this in another code cell:\ngreet_GenomicDiversity()\nIf you get a nice introduction, then the GenomicDiversity package has installed properly. üòÑ\n\n\nLoad other packages\nWe will need a few other packages for downloading the data files, reading data files, and storing data as data frames:\nusing Downloads, CSV, DelimitedFiles, DataFrames\n\n\nSet up the paths and names for the data files stored on GitHub\nbegin\n    demo_gitHub_folder = \"https://raw.githubusercontent.com/darreni/GenomicDiversity.jl/refs/heads/main/demoData/SparrowDemo_data_McCallumetal2024/\"\n    genotype_file = demo_gitHub_folder * \"SparrowDemo_genotypes.012\"\n    individuals_file = demo_gitHub_folder * \"SparrowDemo_genotypes.012.indv\"\n    position_file = demo_gitHub_folder * \"SparrowDemo_genotypes.012.pos\"\n    metadata_file = demo_gitHub_folder * \"SparrowDemo.Fst_groups.txt\"\nend\nThese input files were produced by an analysis pipeline that took genotyping-by-sequencing (GBS) reads, mapped them to a reference genome, identified single nucleotide polymorphisms (SNPs), called genotypes of individuals, and outputted the information in three files: * a genotype file containing a matrix of genotypes (rows representing individuals and columns representing loci), where 0 represents homozygous reference, 1 represents heterozygous, 2 represents homozygous alternate, and -1 represents missing data * a .indv file containing individual identifiers (corresponding to rows of the genotype matrix) * a .pos file providing the locations of loci in the genome (with rows representing loci, column 1 indicating the scaffold, and column 2 indicating the position along that scaffold)\n\n\nEnough setup, let‚Äôs load data!\nFirst import metadata about the samples:\nmetadata = DataFrame(CSV.File(Downloads.download(metadata_file)))\nAbove, the CSV.file() function interprets the correct delimitation format of the data file, and the DataFrame() function creates a DataFrame object (a wonderful way to store data where columns are variables and rows are individuals).\nNow, import the list of individuals (row names) of the genotype matrix:\nind = DataFrame(CSV.File(Downloads.download(individuals_file); header=[\"ind\"], types=[String]))\nGet the number of individuals:\nindNum = size(ind, 1)\nCheck that the metadata file and .indv file have same number of individuals:\nif nrow(metadata) != indNum\n    println(\"WARNING: number of rows in metadata file different than number of individuals in .indv file\")\nelse println(\"Good news: number of rows in metadata file matches the number of individuals in .indv file\")\nend\nCombine individual names and metadata into one data structure (enabling confirmation that names match and are in correct order):\nind_with_metadata = hcat(ind, metadata)\nLoad SNP positions:\npos_whole_genome = DataFrame(CSV.File(Downloads.download(position_file); header=[\"chrom\", \"position\"], types=[String, Int]))\nLoad the genotype matrix:\nbegin # read in genotype data \n    @time geno = readdlm(Downloads.download(genotype_file), '\\t', Int16, '\\n')\n    loci_count = size(geno, 2) - 1   # because the first column is not a SNP (just a count from zero)\n    print(string(\"Read in genotypic data at \", loci_count,\" loci for \", indNum, \" individuals. \\n\"))\n    genosOnly = geno[:, Not(1)] #remove first column, which was just a row index\nend\nIn the data matrix, rows represent individuals and columns represent SNPs, and genotypes are as follows:\n0: homozygous reference; 1: heterozygous; 2: homozygous alternate; -1: missing genotype\n\n[If you want to filter individuals or SNPs with too much missing data, I have scripts that can be added here]\n\n\nChoose our groups to plot, and their colours\ngroups_to_plot = [\"GCSP\",\"PSWS\",\"GWCS\"]\ngroup_colors = [\"gold\",\"red\",\"blue\"]\n\n\nTo do a PCA, we first need to impute missing genotypes\nPrepare data matrix to be ready for imputation, by replacing -1 with missing data type:\nbegin\n    genosOnly_with_missing = Matrix{Union{Missing, Int16}}(genosOnly)\n    genosOnly_with_missing[genosOnly_with_missing .== -1] .= missing;\n    genosOnly_with_missing = Matrix{Union{Missing, Float32}}(genosOnly_with_missing) \nend\nLoad Impute package:\nusing Impute\nNow actually impute the missing genotype values:\n@time imputed_genos = Impute.svd(genosOnly_with_missing)\n\n\n\nLet‚Äôs make the PCA plot!\nbegin\n    PCAmodel = GenomicDiversity.plotPCA(imputed_genos, ind_with_metadata,\n            groups_to_plot, group_colors;\n            sampleSet=\"Zonotrichia sparrows\", regionText=\"whole_genome\",\n            flip1=false, flip2=false, showPlot=true)\n    PCAmodel.PCAfig  # shows the figure\nend\n\n\n\n\n\nGold symbols represent Golden-crowned Sparrows. Blue represent the gambelii form of White-crowned Sparrows. Red represent that the pugetensis form of White-crowned Sparrows.\n\n\nNow let‚Äôs produce a genotype-by-individual plot\nOur overall dataset has close to 46,000 SNPs, far too many to visualize meaningfully in a single plot. We can come up with a meaningful subset by examining variation on a single scaffold (i.e., chromosome in this case) and only showing the SNPs that strongly differ in allele frequency between chosen groups.\nWe‚Äôll calculate allele frequencies and sample sizes for each group, and then genetic differentiation (known as FST) between the groups:\nfreqs, sampleSizes = GenomicDiversity.getFreqsAndSampleSizes(genosOnly_with_missing,\n                            ind_with_metadata.Fst_group, groups_to_plot)\nFst, FstNumerator, FstDenominator, pairwiseNamesFst = GenomicDiversity.getFst(freqs,\n                                            sampleSizes, groups_to_plot)\nNow we will choose a scaffold and specify some other parameters for the plotting algorithm:\nbegin\n    chr = \"CM018231.2\" # the name of a scaffold in the reference genome\n    regionInfo = GenomicDiversity.chooseChrRegion(pos_whole_genome, chr) # this gets the maximum position for the chromosome\n    group1 = \"GCSP\"   # the alleles most common in this  group will be assigned the same color in the graph\n    groupsToCompare = \"GCSP_PSWS\" # The groups to compare for the Fst filter below\n    Fst_cutoff =  0.8\n    missingFractionAllowed = 0.2\nend\nFinally, we can actually make the plot:\nplotInfo = GenomicDiversity.plotGenotypeByIndividualWithFst(groupsToCompare, \n    Fst_cutoff, missingFractionAllowed, regionInfo, \n    pos_whole_genome, Fst, pairwiseNamesFst, \n    genosOnly_with_missing, ind_with_metadata, freqs, \n    groups_to_plot, group_colors)\nplotInfo[1] # this outputs the plot\n\n\n\n\n\nThe figure shows the genotypes of individuals at SNPs that have Fst higher than Fst_cutoff in the groups being compared (given by groupsToCompare). The two alleles have different shades of purple, with triangles indicating heterozygotes. The bottom of the plot indicates the location of SNPs on the chromosome, and the blue shading indicates SNP density across the chromosome.\nIf the function works on your computer like it does on mine, it will create a separate plot window and show the figure both there and in your Pluto notebook.\n\n\n\n\n\n\nTipProduce such plots for a series of chromosomes\n\n\n\nCan you write a loop to cycle through a number of different chromosomes and make a plot for each? You would use a lot of the code in the previous two cells above. You could do this for these scaffolds, expressed here a a vector of strings: [\"CM018230.2\", \"CM018231.2\", \"CM018232.2\", \"CM018233.2\", \"CM018234.2\"]\n\n\n\n\nA take-home message:\nThe GenomicDiversity.plotGenotypeByIndividual() function produces this complex plot from the repeated use of low-level plotting functions to simply draw lines, filled shapes, and text in the plotting window. If you learn the commands to draw such simple elements and the logic by which to determine where to draw them, you can design your own functions to make all sorts of complex figures.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Load & Graph Data"
    ]
  },
  {
    "objectID": "Numbers.html",
    "href": "Numbers.html",
    "title": "A Bit about Numbers",
    "section": "",
    "text": "On previous pages we have learned some about how Julia remembers numbers as belonging to different types. Why is this? Isn‚Äôt a number just a number? Well, when it comes to storing them in computer, the answer is no. To understand why, let‚Äôs learn a little about how computers store information.\n\nBinary memory\nThe great majority of computers today (and certainly your own personal computer) store information as a series of 1s and 0s. (You can equally well think of these as on/off or true/false.) A single 1/0 switch is called bit‚Äîthe smallest unit of information that a computer can store.\nA set of 8 bits is called a byte. The memory on a computer consists of gigantic grids of such bytes. When we talk about memory sizes of computers, we use terms like kilobytes (KB; 1,000 bytes, or 8,000 bits) or megabytes (MB; 1,000,000 bytes), and so forth.\n\n\nBinary counting\nSo how can numbers other than 0 and 1 be stored? As a series of 0s and 1s, which are interpreted as a group according to some rule. For example, we can simply count in binary to convert our decimal (base-10) numbers to the way computers often store integers:\nDecimal 0 can be stored as binary 0.\nDecimal 1 can be stored as binary 1.\nDecimal 2 can be stored as binary 10.\nDecimal 3 can be stored as binary 11.\nDecimal 4 can be stored as binary 100.\nDecimal 5 can be stored as binary 101.\n\nAnd so forth. You can see that storing larger integers requires more bits.\nThe take-home message here: For integers, there is a tradeoff between memory size and the range of integers that can be stored.\n\n\nWhat about non-integers?\nThe above works fine for integers, but we often want to store numbers like 7.1 or 0.005 or sqrt(2). For this, people have come up with a clever way of encoding numbers called floating-point numbers, because you can think of it as storing numbers as an integer multiplied by a number that represents the magnitude (which adjusts where the decimal point goes).\nThis floating-point number system works great, but there is a limitation: In a fixed set of bits, there is a limit to the precision of such numbers. In other words, there are only certain values such numbers can take, with gaps between them. The more bits we dedicate to storing such numbers, the smaller these gaps are.\nThe take-home message here: For floating-point numbers, there is a tradeoff between memory size and precision of the numbers stored.\n\n\nNumbers in Julia\nTo learn a bit about how numbers are represented by different Julia types, we can use the bitstring() function:\n\nbitstring(1)\n\n\"0000000000000000000000000000000000000000000000000000000000000001\"\n\n\nThis shows us that the number 1 is stored as 63 0s and then a 1. This is Julia‚Äôs default way of storing integers, as type Int64 (a 64-bit integer).\n\n\n\n\n\n\nTipWrite out bit representations for a series of integers\n\n\n\nCan you write a simple for loop to write out the bit representations of a series of integers, for example 0 through 10? (Reminder: the println function will print out some text)\n\n\nLet‚Äôs try the same but use 1.0 instead:\n\nbitstring(1.0)\n\n\"0011111111110000000000000000000000000000000000000000000000000000\"\n\n\nHere we have quite a different representation. This is because the number is now stored as type Float64 (a 64-bit floating-point number).\n\nThe about() function\nWe can learn more about how numbers are encoded by adding a nice little package called About:\nusing Pkg; Pkg.add(\"About\")\nThis package has one function, wisely named about() as it tells us about objects (note though that it can only tell you about relatively simple objects).\n\nusing About\nabout(1)\n\n\nInt64 (&lt;: Signed &lt;: Integer &lt;: Real &lt;: Number &lt;: Any), occupies 8B.\n\n 0000000000000000000000000000000000000000000000000000000000000001\n = +1\n\n\n\n\nThe highlighting tells you how the number is encoded (one bit for the positive sign, the rest for the integer)\n\nabout(1.0)\n\n\nFloat64 (&lt;: AbstractFloat &lt;: Real &lt;: Number &lt;: Any), occupies 8B.\n\n 0011111111110000000000000000000000000000000000000000000000000000 \n ‚ï®‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n +    2^0   √ó                1.000000000000000000                \n = 1.0000000000000000\n\n\n\n\nThe result shows you which bits are for which components of the floating-point number.\n\n\n\n\n\n\nTipTry about() on other objects\n\n\n\nPlay around with this function to learn about how other types of things are stored. (For example, about('x'), about(\"ACGT\"), about(3//7), about(sqrt(2)), about(pi).)\n\n\n\n\n\nChoosing types wisely\nWhy does all this matter? Well, if you don‚Äôt actually need 64 bits for your numbers, then you can tell Julia to store them in fewer bits, and this can increase efficiency (i.e., reduce memory and increase speed).\nFor example, if you know that a variable will only need to store integers ranging between -128 and 127, then you can specify that variable as an 8-bit integer:\n\nx8 = Int8(39)\n\n39\n\n\n\ntypeof(x8)\n\nInt8\n\n\n\nbitstring(x8)\n\n\"00100111\"\n\n\n\nabout(x8)\n\n\nInt8 (&lt;: Signed &lt;: Integer &lt;: Real &lt;: Number &lt;: Any), occupies 1B.\n\n 00100111 = +39\n\n\n\n\nWe have succeeded in storing the number 39 in only 8 bits rather than 64.\nAs another example, let‚Äôs say we need to store a floating-point number but we don‚Äôt need a lot of precision. Let‚Äôs store it as a 16-bit floating-point number:\n\npi16 = Float16(3.14159)\n\nFloat16(3.14)\n\n\nJulia‚Äôs response indicates the rough level of precision that the number has been stored in (only 3.14). That may not be a wise choice for that one number, but imagine if you had millions of numbers stored in memory‚Äîperhaps that precision is good enough for what you are using them for, and cuts the memory by 75% (compared to Float64).\n\nCheck the capacity of types for your numbers\nIf you are working with integers, you can find the minimum storable integer for a type like this:\n\ntypemin(Int16)\n\n-32768\n\n\nAnd the maximum like this:\n\ntypemax(Int16)\n\n32767\n\n\nHence we know that type Int16 can store integers from -32768 to 32767.\n\n\n\n\n\n\nTipWeird math\n\n\n\nWhat happens if you take encode the number 32767 encoded as an Int16 and add 10 to it? Try out by entering Int16(32767) + Int16(10). Can you figure out what happened? (Hint: this is called ‚Äúoverflow‚Äù.)\n\n\n\n\n\nBeware of other weird math\nIn addition to overflow (with integers), we want to be aware of the consequences of floating-point imprecision. An example:\n\n0.1 + 0.2 == 0.3   # note the \"==\" makes this a Boolean statement, asking whether this equation is true\n\nfalse\n\n\nThe REPL returns false. What?!?\nThis is a result of the imprecision of floating-point numbers. Let‚Äôs ask what the left side of the equation is evaluated as:\n\n0.1 + 0.2\n\n0.30000000000000004\n\n\nWe see it is slightly different from 0.3. This is because both 0.1 and 0.2 are stored with a bit of imprecision, and their total is actually a smidgin bigger than 0.3.\nWe are now at risk of a deep dive into computer science, but I will pull us back from the brink. The makers of Julia have provided us biologists a solution to the above. Just use the ‚Äúapproximately equal‚Äù symbol: ‚âà (to get this, type \\approx then press the ‚Äútab‚Äù key.)\n\n0.1 + 0.2 ‚âà 0.3   # note the \"‚âà\" is the Boolean operator for approximately equal\n\ntrue\n\n\nThe REPL now says it is a true statement, within the (im)precision of the data type being used.\n(The ‚âà symbol is a short way of calling the isapprox() function‚Äîthose interested can look that up for the gory details.)\nJulia provides another solution to this situation: We can use the Rational type to encode rational numbers precisely, as ratios of integers:\n\n1//10\n\n1//10\n\n\nWe can see that Julia is treating this expression in a different way than 0.1 or 1/10 (which Julia would convert to 0.1). With 1//10, Julia is remembering both the numerator and denominator, storing this as a ratio of integers. We can check the type:\n\ntypeof(1//10)\n\nRational{Int64}\n\n\nNow that the ratios are now stored precisely, let‚Äôs check our Boolean statement:\n\n1//10 + 2//10 == 3//10\n\ntrue\n\n\nPrecise math now works! However, there is a limitation to use of the Rational type: it cannot store irrational numbers like sqrt(3) or œÄ.\n\n\nMachine epsilon\nAbove we touched on how the Float64 type (or any way of storing numbers in a finite number of bits) must have gaps between the numbers that can be represented precisely. The size of the gap between two representable floating-point numbers is known as ‚Äúmachine epsilon‚Äù. We can use the eps() function to return the distance between 1.0 and the next larger representable floating-point value:\n\neps(Float32) # \"Float32\" is the type that we feed into the function\n\n1.1920929f-7\n\n\nThat is for 32-bit floating point numbers. The epsilon for a 64-bit floating-point number is a lot smaller:\n\neps(Float64)\n\n2.220446049250313e-16\n\n\n\n\n\n\n\n\nNoteRecognize that number?\n\n\n\nThose of you who have used R or have read much of the scientific literature might notice the above value, often shown as 2.2 √ó 10-16. For complex reasons, this machine epsilon value was chosen as the minimum reported P-value for many statisical software packages, including R.\n\n\n\n\nBigInt and BigFloat\nFor most uses, Int64 and Float64 provide excellent flexibility with numbers. In those rare cases where you need even bigger integers or even more precision on your floats, Julia provides BigInt and BigFloat types. These use as many bits as you need to provide the number of numbers that you want.\nFor example, let‚Äôs start with the largest integer that can be stored as an Int16:\n\nmyLargeNum1 = typemax(Int64)\n\n9223372036854775807\n\n\nIf we add 1 to that, we would have an overflow problem. Instead, let‚Äôs make it a BigInt and add 1:\n\nmyLargeNum2 = BigInt(myLargeNum1) + 1\n\n9223372036854775808\n\n\n\nabout(myLargeNum2)\n\n\nBigInt (mutable) (&lt;: Signed &lt;: Integer &lt;: Real &lt;: Number &lt;: Any)\n Memory footprint: 16B directly (referencing 32B in total)\n\n\n\n\nThis uses 16 bytes (128 bits), twice as much as our starting number. Its memory footprint can grow even bigger if we need it to.\nThe BigInt type can be useful for storing precise values of things like factorials:\n\nfactorial(BigInt(50))\n\n30414093201713378043612608166064768844377641568960512000000000000\n\n\n\n\nNext steps\nThinking about efficiency of number types will be particularly important when storing large numbers of numbers in Arrays or DataFrames, which we will explore on the next page.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "A Bit about Numbers"
    ]
  },
  {
    "objectID": "ControlFlow.html",
    "href": "ControlFlow.html",
    "title": "Control Flow: Loops and Ifs",
    "section": "",
    "text": "So far, what we have learned might be called coding, the way your write commands that do a fixed set of instructions. To do true programming we need to know how to write scripts in which the exact sequence of commands is determined dynamically. This is called control flow.\n\nLoops: for and while\nLoops are very useful in programming, because we often want to do a set of commands multiple times. For example:\n\nfor ice in 1:10\n  iceCubed = ice^3\n  println(\"The cube of \", ice, \" is \", iceCubed)\nend\n\nThe cube of 1 is 1\nThe cube of 2 is 8\nThe cube of 3 is 27\nThe cube of 4 is 64\nThe cube of 5 is 125\nThe cube of 6 is 216\nThe cube of 7 is 343\nThe cube of 8 is 512\nThe cube of 9 is 729\nThe cube of 10 is 1000\n\n\nAbove, the for ice in 1:10 line means to assign the value 1 to an object called ice and then execute the expressions below that line and above the end, and then assign the value 2 to ice and do the expressions again, then do the same with 3 etc., all the way to 10.\nHere we‚Äôll use a random integer to determine how many times to do a loop:\n\nbegin\n  rand_times = rand(1:10)  # This returns a random integer in the range 1 to 10\n  for i in 1:rand_times\n    println(i)\n  end\n  println(\"I counted to $rand_times\")\nend\n\n1\n2\nI counted to 2\n\n\nTry executing the above several times, so you can see how it chooses a random number to count to.\nNote that the $ in the println line above causes string interpolation of the expression to the right of it.\nI show the code block above as being within a begin - end block, which is how you would want to enter it in a single cell in Pluto. Below, I will not always show the begin and end.\n\n\n\n\n\n\nTipTeach Julia to Sing\n\n\n\nWrite a script that produces the song ‚Äú99 bottles of beer on the wall.‚Äù This song goes like ‚Äú99 bottles of beer on the wall, 99 bottle of beer, you take one down and pass it around, 98 bottles of beer on the wall; 98 bottles of beer on the wall, 98 bottles of ‚Ä¶‚Äù and so forth all the way down until there is no more beer. (I don‚Äôt think anyone has ever completed the song . . . Can your program succeed in doing so?)\n\n\nAn interesting thing about for loops is that the iterator variable is internal to the loop (not ‚Äúknown‚Äù outside of the loop):\n\ni = 27\nprintln(\"Before the loop, i = $i\")\nfor i in 1:3\n  println(\"Inside the loop, i = $i\")\nend\nprintln(\"After the loop, i = $i\")\n\nBefore the loop, i = 27\nInside the loop, i = 1\nInside the loop, i = 2\nInside the loop, i = 3\nAfter the loop, i = 27\n\n\n\nfor loops can iterate across many kinds of collections\nYou can iterate across all sorts of things, for example a matrix of strings:\n\nspeciesGrid = [\"warblers\" \"flamebacks\" \"sticklebacks\"; \n              \"sparrows\"  \"guppies\" \"digital organisms\"] \nfor i in speciesGrid\n  println(\"We study $i.\")\nend\n\nWe study warblers.\nWe study sparrows.\nWe study flamebacks.\nWe study guppies.\nWe study sticklebacks.\nWe study digital organisms.\n\n\nInstead of the in in the for line, you can use the unicode character ‚àà (produced by typing \\in tab), which is a mathematical symbol meaning ‚Äúis an element of‚Äù. :\n\nmySet = [\"banana\", 5.3, 'üê¨']  # for the dolphin:  \\:dolphin: tab\nfor thing ‚àà mySet\n  println(\"My thing is $thing\")\nend\n\nMy thing is banana\nMy thing is 5.3\nMy thing is üê¨\n\n\n\n\nNested loops\nOften it is useful to have nested loops. For instance, to produce all dinucleotide combinations:\n\nbases = ['A', 'C', 'G', 'T']\nfor i in bases\n  for j in bases\n    print(i, j, \", \")\n  end\nend\n\nAA, AC, AG, AT, CA, CC, CG, CT, GA, GC, GG, GT, TA, TC, TG, TT, \n\n\nYou can produce the above more concisely by putting both iterator statements on the same line:\n\nbases = ['A', 'C', 'G', 'T']\nfor i in bases, j in bases\n  print(i, j, \", \")\nend\n\nAA, AC, AG, AT, CA, CC, CG, CT, GA, GC, GG, GT, TA, TC, TG, TT, \n\n\n\n\n\n\n\n\nTipProduce all trinucleotides\n\n\n\nCan you modify the above to produce all possible trinucleotides (i.e., 3-base nucleotides)?\n\n\n\n\nwhile loops\nLet‚Äôs say you don‚Äôt know in advance how many times you want to go through a loop. Rather, you want to stop the loop when some condition is met. The while loop is perfect for that:\n\nmySum = 0\nwhile mySum &lt;= 21  # inspired by a card game\n  myRand = rand(1:10)  # this variable internal to the loop, not known outside\n  mySum = mySum + myRand\n  println(mySum)\nend\n\n1\n2\n8\n14\n18\n20\n28\n\n\n\n\n\n\n\n\nTipSimulate dispersal of an organism\n\n\n\nYou are writing a simulation in which individuals move from their birth site to their breeding site, along a continuous range of length 1. The dispersal distance is drawn from a standard normal distribution, given by randn(), with the constraint that they are not allowed to move outside of the range. If an individual is born at location 0.7, write a script that determines its breeding location within the range (lowest possible value = 0; highest possible value = 1).\n\n\n\n\n\nCompound expressions\nA compound expression is a single large expression that is made up of multiple sub-expressions that are evaluated in order. When the compoud expression is evaluated, only the value generated by the last sub-expression is returned. There are basically two ways to generate compound expressions:\n\nUse a semicolon (;) chain\n\nx = 4; y = 3; x + y\n\n7\n\n\nThe above returns the value of the last subexpression, and it does remember values assigned in the earlier subexpressions. (To prove this to yourself, enter x to see its value.)\nYou can use compound expressions as part of even larger expressions, e.g.:\n\nmyVar = (x = 4; y = 3; x + y)\n\n7\n\n\nThere, the compound expression in parentheses is evaluated and the resulting value is assigned to myVar.\n\n\nUse a begin block\nThe above compound expression is equivalent to the one below:\n\nmyVar2 = begin x = 4; y = 3; x + y end\n\n7\n\n\nThe use of begin blocks is particularly useful when dividing expressions between multiple lines:\n\nbegin\n  string1 = \"Phylloscopus\"\n  string2 = \"trochiloides\"\n  string1 * \" \" * string2\nend\n\n\"Phylloscopus trochiloides\"\n\n\n\n\n\nConditional evaluation: if and ? :\nOften in our programs we want to execute some commands only if a condition is met. For this, we can use an if - elseif - else block:\n\ncoinflip = rand([\"heads\", \"tails\"])\nif coinflip == \"heads\"\n  println(\"Heads--You win!\")\nelseif coinflip == \"tails\"\n  println(\"Tails--You lose :(\")\nelse \n  println(\"The coin has a strange value\")\nend\n\nTails--You lose :(\n\n\nIn an if block, the elseif and else parts are optional, but the end is essential. The indentation is customary and makes the code easier to read, but is not required. The value of the conditional expressions (e.g., just to the right of if) must be of type Bool, meaning either true or false.\n\n\n\n\n\n\nTipDetermine homozygote or heterozygote\n\n\n\nWrite a script in which you assign a diploid genotype to an object, with the genotype encoded as a 2-element vector containing strings (e.g., [\"A\", \"C\"] or [\"A\", \"A\"]), and then the script tells you whether the genotype is homozygous (the two elements are the same) or heterozygous (the two elements are different). (Hint: Remember how to access one element of a vector, e.g.¬†x[1] gives just the first element of x; Remember how to ask if two things are equal: ==)\n\n\nIn Julia, if blocks return a value. You can make use if that to do something like this:\n\nhomozygote = true\ngenotype = if homozygote\n             \"TT\"\n           else\n             \"TG\"\n           end\n\n\"TT\"\n\n\n\nTernary operators\nThe ternary operator, consisting of a ? and : separating three expressions (hence ‚Äúternary‚Äù), can be thought of as a consise form of an if - else block. For instance, this is equivalent to the above:\n\nhomozygote ? \"TT\" : \"TG\"\n\n\"TT\"\n\n\nThis can be thought of as ‚ÄúTrue or false‚Äù ? ‚ÄúDo this if true‚Äù : ‚ÄúDo this if false‚Äù\n\n\n\n\n\n\nTipDetermine whether a number is positive or negative\n\n\n\nAssign a non-zero number to an object, and then use a ternary operater to report whether the number is positive or negative.\n\n\n\n\n\nShort-circuit evaluation\nAnother way of constructing conditional evaluations is to use the && and || operators (which mean logical ‚Äúand‚Äù and logical ‚Äúor‚Äù). These operators come between two sub-expressions which are evaluated in order from left to right. Julia is efficient and only evaluates the rightmost sub-expression if it needs to (this is why it is called short-circuit evaluation: the evaluation doesn‚Äôt always extend to the right sub-expression). Hence:\n\nIn a && b, b is evaluated only if a is true (because otherwise the whole statement is definitely false)\nIn a || b, b is evaluated only if a is false (because otherwise the whole statement is definitely true)\n\nThe interesting thing is that the b subexpression does not have to produce true or false. Rather, it can do anything you want, and is only executed depending on whether a is true. For example:\n\nx = 5\nx &gt; 0 && println(\"x is positive\")\n\nx is positive\n\n\nTry changing x above to a negative value and run the above again.\nI think of the above construction as ‚ÄúCheck if true AND (only if true) do this thing.‚Äù\n\ny = 3.2\ny &lt;= 0 || println(\"x is positive\")\n\nx is positive\n\n\nAgain, try changing the value of y to a negative value and run again.\nI think of the above as ‚ÄúCheck if true OR (only if not true) do this thing.‚Äù\nThe above expressions may take a while to get used to. You don‚Äôt have to use them, as you might find the if block a lot more intuitive. But you may see these expressions in code that others have written, so it is good to understand them.\n\n\nArray comprehensions\nThis is a concept that involves understanding of arrays, for loops, and (in some cases) if statements. Let‚Äôs say we want to generate a vector containing all the cubes of the integers from 1 to 5. From what we‚Äôve learned above, we can write a for loop to do that:\n\ncubes = [] # initializes an empty vector\nfor i in 1:5\n  push!(cubes, i^3)\nend\ncubes\n\n5-element Vector{Any}:\n   1\n   8\n  27\n  64\n 125\n\n\nThat works fine. A more concise way to do this using an array comprehension:\n\ncubes2 = [x^3 for x in 1:5]\n\n5-element Vector{Int64}:\n   1\n   8\n  27\n  64\n 125\n\n\nThe code in the brackets can be thought of as a loop in which a variable (x) takes on the values from 1 through 5, each time calculating x^3 and storing that as a value in the vector. We can even add an if statement to filter the resulting values in the vector:\n\ncubes3 = [x^3 for x in 1:10 if x^3 % 3 == 0]\n\n3-element Vector{Int64}:\n  27\n 216\n 729\n\n\nThis produces only the cubes that are divisible by 3.\n\nMulti-dimensional array comprehension\nWe can use comprehensions to generate arrays of any dimension. For example:\n\nmultiplicationTable = [x*y for x in 1:6, y in 1:6]\n\n6√ó6 Matrix{Int64}:\n 1   2   3   4   5   6\n 2   4   6   8  10  12\n 3   6   9  12  15  18\n 4   8  12  16  20  24\n 5  10  15  20  25  30\n 6  12  18  24  30  36\n\n\nThe above had two implied loops (one for x and one for y) and the comma between them indicates they represent two dimensions.\n\n\n\n\n\n\nTipMake a 4√ó4 array containing all possible dinucleotides\n\n\n\nUsing array comprehension, write code that will generate Matrix containing all 16 possible 2-letter combinations of A, C, G, and T.\nIf you succeed: Can you now generate a 4√ó4√ó4 Array that contains all possible trinucleotides?\n\n\nArray comprehensions might take a while to get used to, as they contain a lot of logic in concise code. I mention them here because you may see them in Julia programs written by others. When you are starting out though, the logic may be easier to perceive if you write out your array-filling loops as full for blocks containing a series of expressions and an end keyword.\n\n\n\nNext steps\nNow that we have have developed an understand of the key elements of programming, in the next pages let‚Äôs learn some more about visualizing data and then build a fun simulation.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Control Flow: Loops and Ifs"
    ]
  },
  {
    "objectID": "ArraysAndDataFrames.html",
    "href": "ArraysAndDataFrames.html",
    "title": "Arrays & DataFrames",
    "section": "",
    "text": "Two Julia object types are especially useful for storing and manipulating datasets are Arrays (which we learned some about in the quick introduction) and DataFrames. On this page we‚Äôll build understanding about each of these.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Arrays & DataFrames"
    ]
  },
  {
    "objectID": "ArraysAndDataFrames.html#arrays",
    "href": "ArraysAndDataFrames.html#arrays",
    "title": "Arrays & DataFrames",
    "section": "Arrays",
    "text": "Arrays\nYou can think of an Array as a big box that contains one or more small boxes in a grid arrangement. They can have zero dimensions (i.e., one small box), one dimension (i.e., a stack of small boxes; also called a Vector), two dimensions (i.e., a grid of small boxes; also called a Matrix), or even more dimensions. We can store things in each small box, and refer to what is in that box by its indices (the box number along each dimension).\nFor example, here we create a 2-dimensional array of 3 by 4 dimensions:\n\nA = [11 21 31 41\n     0 0 0 0\n     99 88 77 66]\n\n3√ó4 Matrix{Int64}:\n 11  21  31  41\n  0   0   0   0\n 99  88  77  66\n\n\nJulia shows us the type of this object as being Matrix{Int64} meaning that it is a Matrix (a 2-dimensional Array) with elements of type Int64.\nLet‚Äôs look in just one box using indexing:\n\nA[3,2]\n\n88\n\n\nThat gives us the value in row 3 and column 2.\nOr we can take a slice of the array:\n\nA[1:3,2:3]\n\n3√ó2 Matrix{Int64}:\n 21  31\n  0   0\n 88  77\n\n\n\nCreating arrays\nOften in programming, it is good practice to set up an array and then later fill it with meaningful values. This promotes efficiency (minimizing memory use and maximizing speed) compared to building an array by small pieces at a time.\nWe can initialize arrays in a number of ways. Here are a few of the possibilities:\n\nB = ones(3, 7)\n\n3√ó7 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0\n\n\n\nC = zeros(1,5)\n\n1√ó5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n\n\n\nD = fill(3.7, 3, 5, 2)\n\n3√ó5√ó2 Array{Float64, 3}:\n[:, :, 1] =\n 3.7  3.7  3.7  3.7  3.7\n 3.7  3.7  3.7  3.7  3.7\n 3.7  3.7  3.7  3.7  3.7\n\n[:, :, 2] =\n 3.7  3.7  3.7  3.7  3.7\n 3.7  3.7  3.7  3.7  3.7\n 3.7  3.7  3.7  3.7  3.7\n\n\nThis last one is a 3-dimensional array. You can think of the dimensions as rows, columns, and pages or layers.\nThere are many times when we don‚Äôt care what the initial values in our array are. A time-saving method is to declare an array with an arbitrary value determined by the bit values already in the memory being accessed:\n\n@time E = Array{Float64}(undef, 1000, 1000)\n\n  0.008141 seconds (1.43 k allocations: 7.720 MiB, 98.99% compilation time)\n\n\n1000√ó1000 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  ‚Ä¶  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  ‚Ä¶  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n ‚ãÆ                        ‚ãÆ              ‚ã±            ‚ãÆ                   \n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  ‚Ä¶  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\n\n\n@time F = ones(1000,1000)\n\n  0.003197 seconds (15 allocations: 7.657 MiB)\n\n\n1000√ó1000 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  ‚Ä¶  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  ‚Ä¶  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n ‚ãÆ                        ‚ãÆ              ‚ã±            ‚ãÆ                   \n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  ‚Ä¶  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n\n\nThose two commands both create the same sized objects of type Matrix{Float64}, but the second takes longer to run because it has to change all the values to 1.0.\n\n\nArrays can store just about anything!\n\nG = [1 1.0 \"one\"\n     1//1 '1' BigInt(1)]\n\n2√ó3 Matrix{Any}:\n  1    1.0    \"one\"\n 1//1   '1'  1\n\n\nIn fact, you can even put an array inside an array:\n\nG[1,1] = [1 0\n          0 1]\nG\n\n2√ó3 Matrix{Any}:\n   [1 0; 0 1]  1.0    \"one\"\n 1//1           '1'  1\n\n\nThe object G is of type Matrix{Any} which means that it is a matrix that can store anything in its small boxes. In contrast, the object A (which we created far above) is of type Matrix{Int64} which means that it can only store integers. If we try to put something else in its boxes, we get an error:\nA[2,3] = \"A string, not an integer\"\nJulia responds: MethodError: Cannot `convert` an object of type String to an object of type Int64\nThe error arises because A is set up as a matrix of integers, and we cannot put a string into it. We can fix this though be changing the type of the array:\n\nA = convert(Matrix{Any}, A)  # converts A to type Matrix{Any}\nA[2,3] = \"A string, not an integer\"\nA\n\n3√ó4 Matrix{Any}:\n 11  21  31                            41\n  0   0    \"A string, not an integer\"   0\n 99  88  77                            66\n\n\n\n\nMemory and speed efficiency of arrays\nWhen we created the arrays A and G, Julia made a best guess as to what types it should allow in the boxes. In the case of A, when we first created it we put in only integers, so Julia made the assumption that we would always want only integers in it. Why would it make that limitation? Well, there are huge benefits in terms of the way the array is stored in memory. If only integers will be stored, then Julia knows how much memory to allocate. If anything could be stored in an array, then it has to set it up in memory in a more flexible way that is not as efficient.\nJulia gives us the option of thinking a lot about efficiency in our coding, but it is also quite fast even when you don‚Äôt write efficient code, by making its best guess about how to store data. As you become a better programmer and work with larger datasets, it will become more useful to think about storing data efficiently.\nAs one example, let‚Äôs say we need to store a big matrix of random values, lets say 10,000 rows by 10,000 columns, so 100 million values. We could just venture forth with a simple command, like this:\n\nbigMatrix = fill(1, 10_000, 10_000)\n\n10000√ó10000 Matrix{Int64}:\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n ‚ãÆ              ‚ãÆ              ‚ãÆ        ‚ã±        ‚ãÆ              ‚ãÆ           \n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n\n\nThis creates a 10,000 by 10,000 array and fills it with the 1s. We can check the memory size of this array like this:\n\nsizeof(bigMatrix)\n\n800000000\n\n\nThis tells us that bigMatrix uses 800 million bytes of memory. This makes sense, because it is of type Matrix{Int64} meaning that each element is stored as a 64-bit integer, meaning it uses 8 bytes (there are 8 bits in a byte).\nIf we think about our needs though, we might realize we will not need to store any big or small integers in this matrix. If our matrix will only be used to store integers ranging from -128 and 127, then those integers can all be stored in only 8 bits (1 byte). So let‚Äôs tell Julia that we want our Matrix set up like that:\n\nbigMatrix2 = fill(Int8(1), 10_000, 10_000)\n\n10000√ó10000 Matrix{Int8}:\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n ‚ãÆ              ‚ãÆ              ‚ãÆ        ‚ã±        ‚ãÆ              ‚ãÆ           \n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n\n\nNow, we have filled our new matrix with Int8(1) which is the value 1 encoded as type Int8, meaning it takes up 8 bits, or 1 byte:\n\nsizeof(bigMatrix2)\n\n100000000\n\n\nThis matrix takes 1/8 the memory of the first, but encodes exactly the same information. (But we have more limitation on what numbers it can store.)\nUsually, information stored with lower memory footprint will also be quicker to access, meaning your programs will be faster.\n\nBitArrays\nA super efficient way to store a set of binary values (e.g.¬†true/false, 1/0, on/off) is as a BitArray, wherein each element is stored as a single bit (the smallest memory unit in a computer). This means we can store 64 values in the same memory space as a default integer stored as Int64 would take:\n\nmyBitArray = trues(10_000, 10_000)  # trues() sets up a BitArray with all values set to 1\n\n10000√ó10000 BitMatrix:\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n ‚ãÆ              ‚ãÆ              ‚ãÆ        ‚ã±        ‚ãÆ              ‚ãÆ           \n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n\n\n\nsizeof(myBitArray)\n\n12500000\n\n\nNow our array of 1s takes only 12.5 million bytes, which is 1/64 the memory size of our bigMatrix of 1s above.\n\n\n\nLogical indexing\nOne way to choose specific elements from arrays is using logical indexing, in which a series of true/false values (or as 1/0 values in a BitArray) are used to indicate the elements to choose. To show this, let‚Äôs start with a simple matrix:\n\nm1 = reshape(1:16, 4, 4)  # reshape() turns a Vector into a Matrix\n\n4√ó4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\n\nNow we can use a vector of Boolean values to choose rows:\n\nm1[[true, false, true, false], :]\n\n2√ó4 Matrix{Int64}:\n 1  5   9  13\n 3  7  11  15\n\n\nOr choose rows and columns like this:\n\nm1[[true, false, true, false], [false, true, true, false]]\n\n2√ó2 Matrix{Int64}:\n 5   9\n 7  11\n\n\nAn equivalent expression using BitVectors is:\n\nm1[BitVector([1, 0, 1, 0]), BitVector([0, 1, 1, 0])]\n\n2√ó2 Matrix{Int64}:\n 5   9\n 7  11\n\n\nThis lets us do things like choose the even rows and odd columns:\n\nm1[iseven.(1:4), isodd.(1:4)]\n\n2√ó2 Matrix{Int64}:\n 2  10\n 4  12\n\n\nIn the above expression, iseven.(1:4) produces a BitVector that indicates whether each integer from 1 to 4 is even. See that here:\n\niseven.(1:4)\n\n4-element BitVector:\n 0\n 1\n 0\n 1\n\n\nAbove we used logical indexing to determine the rows and columns to include. We can also use it to pick elements more directly:\n\nselectionMask = (m1 .% 3 .== 0)  # Chooses values divisible by 3\n\n4√ó4 BitMatrix:\n 0  0  1  0\n 0  1  0  0\n 1  0  0  1\n 0  0  1  0\n\n\nThe above made a BitMatrix indicating which elements satisfied the condition. Now let‚Äôs use that to choose those elements:\n\nm1[selectionMask]\n\n5-element Vector{Int64}:\n  3\n  6\n  9\n 12\n 15\n\n\nThis method‚Äîof specifying a condition for elements to satisfy, constructing a BitMatrix, and using that BitMatrix to index the array‚Äîis used often in data analysis.\n\n\n\n\n\n\nTipBuild a structure for storing genotypes\n\n\n\nYour research involves genotypic data, and you want to efficiently keep track of both real and simulated diploid genotypes for multiple individuals and loci (i.e., genes). You can assume that there are only two alleles at each locus. Can you come up with a data object to store your data, and then store some example data in your object? (Hint: you have 3 dimensions of data: individuals, loci, and the two alleles at each locus.)\nIf that goes well, then write code that will choose only the heterozygous individuals at a given locus.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Arrays & DataFrames"
    ]
  },
  {
    "objectID": "ArraysAndDataFrames.html#dataframes",
    "href": "ArraysAndDataFrames.html#dataframes",
    "title": "Arrays & DataFrames",
    "section": "DataFrames",
    "text": "DataFrames\nThese are also hugely useful in biological data analysis. A DataFrame can be thought of as a series of same-length Vectors arranged as columns into a single table of data. Usually, each row represents an individual, whereas each column represents a distinct variable. Importantly, the different columns can have different types of elements (for example, one column might have Strings, one might have Ints, another might have Float64s, etc.). DataFrames store these different types of vectors efficiently. Furthermore, we can designate names for each column and refer to them by those names.\nTo use DataFrames, we must download and install a package. Type ] to enter the package mode, then enter this:\nadd DataFrames\nNow press delete or backspace to enter the normal REPL mode, and enter this:\n\nusing DataFrames\n\nLet‚Äôs enter some example data:\n\ndata = DataFrame(species = [\"warbler\", \"wren\", \"sparrow\", \"flameback\"],\n          mass_g = [11, 9, 28, 300],\n          random_num = rand(4))\n\n4√ó3 DataFrame\n\n\n\nRow\nspecies\nmass_g\nrandom_num\n\n\n\nString\nInt64\nFloat64\n\n\n\n\n1\nwarbler\n11\n0.786336\n\n\n2\nwren\n9\n0.743958\n\n\n3\nsparrow\n28\n0.593225\n\n\n4\nflameback\n300\n0.0635008\n\n\n\n\n\n\nThe REPL now shows us our dataframe in a nice table format. We see it has interpreted our input data as we would like, with the three columns containing elements of type String, Int64, and Float64.\nWe can now refer to columns in a convenient way:\n\ndata.species\n\n4-element Vector{String}:\n \"warbler\"\n \"wren\"\n \"sparrow\"\n \"flameback\"\n\n\n\ndata.mass_g\n\n4-element Vector{Int64}:\n  11\n   9\n  28\n 300\n\n\nThis convenient reference allows us to choose subsets of the data, borrowing our knowledge from the Logical Indexing section above:\n\ndata.species[data.mass_g .&gt; 20]\n\n2-element Vector{String}:\n \"sparrow\"\n \"flameback\"\n\n\nWe can add a new column quite easily:\n\ndata.size_category = fill(\"undetermined\", size(data, 1))  # the size(data,1) function gets the number of rows.\ndata\n\n4√ó4 DataFrame\n\n\n\nRow\nspecies\nmass_g\nrandom_num\nsize_category\n\n\n\nString\nInt64\nFloat64\nString\n\n\n\n\n1\nwarbler\n11\n0.786336\nundetermined\n\n\n2\nwren\n9\n0.743958\nundetermined\n\n\n3\nsparrow\n28\n0.593225\nundetermined\n\n\n4\nflameback\n300\n0.0635008\nundetermined\n\n\n\n\n\n\nNow let‚Äôs fill in our new column with meaningful values:\n\ndata.size_category[data.mass_g .&gt; 100] .= \"BIG\"\ndata.size_category[100 .&gt; data.mass_g .&gt; 15] .= \"medium\"\ndata.size_category[15 .&gt; data.mass_g] .= \"small\"\ndata\n\n4√ó4 DataFrame\n\n\n\nRow\nspecies\nmass_g\nrandom_num\nsize_category\n\n\n\nString\nInt64\nFloat64\nString\n\n\n\n\n1\nwarbler\n11\n0.786336\nsmall\n\n\n2\nwren\n9\n0.743958\nsmall\n\n\n3\nsparrow\n28\n0.593225\nmedium\n\n\n4\nflameback\n300\n0.0635008\nBIG\n\n\n\n\n\n\n\nLoading your own data into a DataFrame\nIf you want to load your own data file as a DataFrame, you can do it with the following command. You will first need to add the CSV package (used for loading in files in Comma Separated Values format, or similar but with another separator such as tab). Add this package by pressing ] to activate the package mode, then enter add CSV and then you can import data as follows:\nusing CSV\nmyData = DataFrame(CSV.File(\"pathToMyFile/myFileName.csv\"))\n\n\nLearning more about DataFrames\nThe DataFrames.jl package is extremely capable, and we are just touching the surface here of what it can do. A good source to learn more is: https://dataframes.juliadata.org/stable/man/basics/#First-Steps-with-DataFrames.jl\n\n\nNext steps\nOne thing we might want to fill arrays with are random numbers‚Äìthis can be useful in doing simulations and in statistical analysis. We‚Äôve used the rand() function some on previous pages. On the next, we‚Äôll learn more about randomization and its uses.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Arrays & DataFrames"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Julia Programming For Biologists",
    "section": "",
    "text": "Welcome! I developed this website for the purpose of teaching tutorials about the Julia programming language, in the context of biology.\nJulia is a relatively new programming language (started around 2012; first official release in 2018) that is both highly readable (by humans) and fast. This is intended to solve the ‚Äú2-language‚Äù problem, a common workflow in which development of a new program is done first in a highly readable language (e.g., R or Python) and then converted by an expert programmer into a fast but less readable language (e.g., C), resulting in code than can be difficult to interpret by non-experts. Hence Julia provides easy entry for new programmers while also having the power and efficiency to appeal to experts. It is used by NASA, Moderna, Pfizer, and many other organizations, and is used widely by scientists doing climate modelling of Earth and imaging black holes in distant galaxies.\nIf you are in doubt that you need a faster or more readable language than the one you are using, ask yourself this: Have you ever heard other scientists mention how long their bioinformatic processing or evolutionary simulations can take? It is often on the scale of days, weeks, months. What if that were instead minutes, hours, days? How might that accelerate your research, and allow you to expand the scope of your science? Have you ever heard someone say ‚ÄúI can‚Äôt program‚Äù? Did they decide that because they are fundamentally unable to learn the logic of programming, or because many the languages used in programming can be difficult to learn?\nI have used Julia in my own work for about four years now, after having much experience with Matlab and then R, and dabbling a bit in Python, C, C++, and Java. The developers of Julia have praise for aspects of all of these languages, and their goal was to combine all the good aspects into one efficient and readable language. I think they have succeeded marvelously. (I am not the only one‚Äîsee this paper in Nature Methods for a discussion of the merits of using Julia in biology.)\nMy intended audience with these tutorials is biologists with no or little previous programming experience, who are interested in building their data science, bioinformatic, and statistics skills, or who even want to design their own mathematical models and simulations. In particular, I used these to teach a new graduate-level course ‚ÄúComputer Programming for Biologists‚Äù at UBC in November of 2024, which after enthusiastic feedback is being taught again in November of 2025. My goal is to get students programming quickly, giving just enough underlying explanation of computer science principles to enable fast progress.\nThese tutorials are a work in progress, and there will be additions and revisions from time to time . . .\n\n\n\n\n\nFor more details on the features of Julia, see here.\nTo advance through pages of the tutorial, click on the right arrow below.",
    "crumbs": [
      "Home",
      "Basics",
      "Home"
    ]
  },
  {
    "objectID": "PlutoNotebooks.html",
    "href": "PlutoNotebooks.html",
    "title": "Pluto Notebooks",
    "section": "",
    "text": "Now that we‚Äôve learned some about the Julia REPL and are building our understanding of programming, we likely want an environment in which we can compose programs and save them for use later. Pluto notebooks provides a reactive notebook environment for doing this.\n\nInstall Pluto\nPluto is a package that we install into Julia in the same way as we did with the Plots package (on the last page):\nType ] to enter the package mode, then input this:\nadd Pluto\nThis downloads and installs everything needed for Pluto to run (which is quite a bit, so may take some time).\nWhen done, press ‚Äúdelete‚Äù to return from package mode to the REPL. Then type these two commands:\nimport Pluto\nPluto.run()\nEventually (and if your computer works the same as mine), a browser window will open that says ‚Äúwelcome to Pluto.jl‚Äù at the top.\n\n\nCreate your first notebook\nClick on ‚ÄúCreate a new notebook‚Äù (under the heading ‚ÄúMy Work‚Äù).\nYou will then see a mostly blank page that says ‚ÄúPluto.jl‚Äù in the upper left. Below that there is a line with faint text that says ‚ÄúEnter cell code‚Äù. Try entering a simple Julia expression there to assign a value to a variable (e.g.¬†something like a = 5^2) and then press Shift + Enter to tell Pluto to evaluate the cell.\nPluto then returns the result of your expression above the cell.\nLet‚Äôs add another cell by clicking the little ‚Äú+‚Äù sign below the first cell. In this new cell, enter an expression that creates a second variable and assigns to it a calculation involving your first variable (e.g.¬†b = a - 6). You will see again see the result above the cell.\nNow, edit the first cell to change the value assigned to a, and press Shift + Enter. You will see the returned value of a change, and the value of b changes too. This is what it means to be reactive: any change in your notebook propogates through the entire notebook in a logical way. The whole notebook then is like a single program.\n\nPluto notebooks are not dependent on cell order\nTry switching the order of your two cells, by simply hovering your pointer to the left of one of the cells, and then dragging it up or down. Now play around with the code in the cells. You will see that the results do not depend on cell order.\nThis allows you to organize notebooks in whatever way you want. You have the option of having the final result at the top, with supporting code lower down.\n\n\nConsequences of movable cell blocks\nThere are a couple important consequence of the above. One is that we cannot have two statements that assign to the same variable in two different cells. For instance, if you say a = 1 in one cell and a = a + 1. (Try it! Pluto will respond with an error and suggest a solution.) Instead, we can use begin-end blocks to group code in which a single variable is assigned a series of values in succession:\n\nbegin\n    myVar = 1\n    myVar = myVar + 5\nend\n\n6\n\n\nA related principle is that each cell block can only contain a single expression. (However, an expression can be quite big if it contain a begin-end block.) This ensures Julia can figure out which cells depend on which.\n\n\n\nSave your notebook\nLet‚Äôs save our notebook so we can open it later and use it again. At the top of the page, click on ‚ÄúSave notebook‚Äù. You can then choose a folder and enter a file name (e.g.¬†something like ‚ÄúMyFirstPlutoNotebook.jl‚Äù wouldn‚Äôt be a terrible choice). It is good to give your notebook a ‚Äú.jl‚Äù extension, which indicates a file written in Julia.\nIf you now leave your notebook by clicking on the ‚ÄúPluto.jl‚Äù logo in the upper left, you should see that the notebook you just saved is listed under ‚ÄúMy Work‚Äù. Click on that notebook name, and it will open your notebook again.\n\n\nPluto files are valid Julia files\nA nice thing about working in Pluto is that the file that you are saving is 100% runnable as a Julia file (without using Pluto).\n\n\nPluto has no ‚Äúhidden state‚Äù\nA way that Pluto differs from some other notebook environments (e.g.¬†Jupyter) is that the program state is completely described by the code in the notebook. You don‚Äôt have to wonder if each cell has been executed‚Äìthe entire notebook is affected by any change you make (although Julia is clever and for efficiency figures out what cells depend on that change).\n\n\nMake a plot in Pluto\nPluto can show all sorts of output from your code. For instance, try making a plot. We first need to install the Plots package into our Pluto environment:\n\nusing Plots\n\nIf you have not downloaded the Plots package, Pluto will nicely do it for you.\nNow, lets generate some data and graph it:\n\nbegin\n  numPoints = 10\n  xValues = randn(numPoints) # random draw from standard normal distribution\n  yValues = xValues .+ 0.5 .* randn(numPoints)\n  scatter(xValues, yValues)\nend\n\n\n\n\nYou will likely see a scatter plot of 10 data points. The data generation involves random draws from a standard normal distribution, so your graph won‚Äôt look exactly the same as the one shown here.\n\n\n\n\n\n\nTipAdd a lot more points\n\n\n\nCan you figure out how to modify the above to get 1000 data points? Try it!\nIf wanting a bigger challenge: Can you figure out how to make the cloud of points more like a round cloud, where the xValues and yValues are not so strongly associated?\n\n\n\n\nAdd text using Markdown\nMarkdown is a system for converting strings to formatted text in a document. You can use Markdown to add headers and comments to your notebook, simply by entering md and then double quotes surrounding your text. Create a new cell at the top of your notebook and enter this:\nmd\"# _Welcome to my notebook!_ \n\nThis is a Pluto notebook for programming in the Julia language. Pluto notebooks are **reactive** to changes you make.\n\"\nYou can hide the code producing that text by clicking on the little eye symbol left of the code cell.\nWe can incorporate Julia expressions into our Markdown comments by preceding it with a $ symbol:\nmd\"There are $numPoints data points in the graph\"\nnum = 4; md\"The square of $num is $(num^2) .\"\nThe fancy name for the above is string interpolation. The expressions following the $ are evaluated as Julia expressions, and the returned values are integrated into the string (indicated by double quotes) and then formatted as Markdown text (indicated by the md preceding the quotes).\n[Note that if you want the above Markdown commands to work outside of Pluto, e.g.¬†in a regular Julia REPL, you have to add the Markdown.jl package. Enter package mode with ], then enter add Markdown, then press ‚Äúdelete‚Äù to return to REPL, then enter using Markdown.]\n\n\nNext steps\nNow that we have a good environment set up to write and save more complex programs, we‚Äôll learn about control flow, the way you can design a program to do different sets of code depending on the state of one or more variables.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Pluto Notebooks"
    ]
  },
  {
    "objectID": "BuildSimulation.html",
    "href": "BuildSimulation.html",
    "title": "Build a Simulation",
    "section": "",
    "text": "Now that we‚Äôve learned a lot of programming methods, let‚Äôs build a more complex simulation. We could choose all sorts of things to simulate. Here I have chosen a somewhat whimsical example of a hypothetical biological process that has some resemblance to known examples (e.g.¬†male lizards that have three mating strategies, each of which is better than one of the others). We‚Äôll use this to explore the steps involved in building a simulation.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Build a Simulation"
    ]
  },
  {
    "objectID": "BuildSimulation.html#rockpaperscissors-on-a-landscape",
    "href": "BuildSimulation.html#rockpaperscissors-on-a-landscape",
    "title": "Build a Simulation",
    "section": "Rock‚Äîpaper‚Äîscissors on a landscape",
    "text": "Rock‚Äîpaper‚Äîscissors on a landscape\nOur task: Imagine a population of individuals spread out on a landscape. Individuals come in three possible behavioural morphs, with each having one strategy. We‚Äôll call these rock, paper, and scissors, via analogy to the popular game. Individuals move randomly on the landscape. When they encounter each other, they compete in such a way where:\n\npaper defeats rock\nscissors defeats paper\nrock defeats scissors\n\nThe losing individual disappears, and the winning individual reproduces, causing one more individual to appear of the same winning type.\nOur goal is to write a program that will carry out the simulation and allow us to see the dynamics that these simple rules produce on the landscape.\n\nFirst step: consider data structures and the high-level logic of our program\nThere are many ways to solve any particular programming problem. Our goal is to come up with something that is reasonably efficient and easily understood by others reading our code (and ourselves in the future ;). Let‚Äôs first think of how to convert the language given by our task above into more precise concepts that we can specify in code.\n‚Äúlandscape‚Äù: We could conceptualize this as a square of space (bounded by 0 and 1), with locations given by an x value and a y value (both floating-point numbers).\n‚Äúpopulation of individuals‚Äù: We could view this as a list or vector, with the first element representing the first individual, the second representing the second, and so forth. Different vectors could represent different aspects of these individuals (one vector for the x values, one for the y values, etc.).\n‚Äústrategies‚Äù: We can encode these as single letters (i.e.¬†Chars), with the strategies for the whole population being a vector of these.\n‚Äúmove randomly on the landscape‚Äù: We can move individuals by adding a random number drawn from a normal distribution (with the standard deviation specified in a way that keeps movements small).\n‚Äúencounter each other‚Äù: This is vague as stated, and there are many ways we could make this more concrete. One way is to pick a random individual that will interact, and then determine the closest individual to that first one. These two then compete.\n‚Äúcompete‚Äù: The strategies of the two individuals will be compared, and the winner determined by the rules above. Then, we need to replace the losing individual with a new individual with the strategy of the winner. (We realize though that in terms of the coding, this is the same as just changing the strategy of the losing individual. We will make use of this as it means we don‚Äôt have to eliminate cells from our data structure, only change them.)\n‚Äúsee the dynamics‚Äù: This implies we want to watch the simulation play out over a long period of time. So we need to use a loop to run the steps for many many iterations. We also need to show the results visually. We could either watch the simulation in real time or produce a movie by saving frames and then assembling them (fortunately, this is easy as we‚Äôll see below).\n\n\nNow, build the program in steps, using functions for organization\nAfter we‚Äôve spent some time (see above) thinking about how we will conceptualize our simulation in terms of data structures and tasks, we are ready to start writing code.\nWhen I started programming, I tended to write long complex programs as a single long script that does everything. I‚Äôve gradually learned that organizing programs into functions, each of which does one clear task, leads to many benefits (e.g., good logic, undertandability of code, and efficiency). In Julia, this is especially true.\nSo, let‚Äôs start writing!\n\nSet up a landscape with randomly-placed individuals, each playing one of the three strategies.\n\nN = 5000  # the number of individuals in the simulation\nx_locations = rand(N)\ny_locations = rand(N)\nstrategies = rand(['R', 'S', 'P'], N)\n\n5000-element Vector{Char}:\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n 'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n ‚ãÆ\n 'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n 'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n 'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n 'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n\n\nThe above created 3 vectors, each of length N. These three store the three pieces of info for the individuals in our simulation (x location, y location, and strategy).\n\n\nSet up a visualization of the population\nWe envision a 2-dimensional plot representing the geographic range, with dots representing individuals at their locations. We can use 3 colors to represent the three strategies. Let‚Äôs define the color key using a dictionary:\n\nplot_colors = Dict('R'=&gt;\"red\", 'P'=&gt;\"green2\", 'S'=&gt;\"blue\")\n\nDict{Char, String} with 3 entries:\n  'P' =&gt; \"green2\"\n  'R' =&gt; \"red\"\n  'S' =&gt; \"blue\"\n\n\nNow let‚Äôs write a function that uses the above data structures to plot the population:\n\nusing Plots\nfunction show_sim(x_locations, y_locations, strategies, plot_colors)\n    sim_plot = scatter([], [])  # starts an empty plot\n    for i in unique(strategies)\n        selection = (strategies.==i)\n        scatter!(x_locations[selection], y_locations[selection]; markercolor=plot_colors[i], markersize=2, markerstrokewidth = 0, markerstrokealpha = 0, markershape = :circle, legend=false)\n    end\n    sim_plot  # shows the plot\nend\n\nshow_sim (generic function with 1 method)\n\n\nThe above simply defined our plot-showing function. Now let‚Äôs call it to show the initial state of our simulated population:\n\nplot1 = show_sim(x_locations, y_locations, strategies, plot_colors)\n\n\n\n\nWe can see that we have succeeded in setting up a population of individuals with random locations and strategies. Hooray!\nWe now have to write some code to make individuals interact:\n\n\nWrite a function competing pairs of individuals, and determining the winner\n\n\n\n\n\n\nTipWrite a ‚Äúroshambo‚Äù function to determines the winner of two strategies\n\n\n\nYour function should take two input arguments (named s1 and s2), with each being a strategy (either 'R', 'P', or 'S'), and then output 0 if there is no winner, 1 if s1 is the winner, or 2 if s2 is the winner.\n\n\nTest the function above:\n\nroshambo('S', 'R')\n\n2\n\n\n\nroshambo('P', 'R')\n\n1\n\n\n\nroshambo('S', 'S')\n\n0\n\n\nWe now have a short expression that tells us which individual wins. This is an example of abstraction (a key concept in computer science), because we don‚Äôt have to think about the detailed code in the function‚Äîwe know it just works.\nNow let‚Äôs build code that chooses a random individual and the individual closest to it (so that we can then compete them).\n\n\nWrite function to get the closest individual to a given individual\n\nfunction find_closest(x_locations, y_locations, ind)\n    x_focal = x_locations[ind] \n    y_focal = y_locations[ind]\n    dists = sqrt.((x_locations .- x_focal).^2 .+ (y_locations .- y_focal).^2)\n    dists[ind] = 1000  # set this individual's distance to itself very high,\n                       # so it is not chosen in the next line as closest\n    findmin(dists)[2]  # gets index for the minimum value \nend\n\nfind_closest (generic function with 1 method)\n\n\nAbove, we have developed functions for choosing the closest individual (to a given individual) and for determining the winner when those two individuals interact. We also need to build a way to move individuals on the landscape:\n\n\nWrite function to disperse an individual:\n\nsigma_disp = 0.005\nfunction disperse_ind!(x_locations, y_locations, ind, sigma_disp)\n    new_x = -9.9 # initialize with arbitrary wrong value\n    new_y = -9.9 \n    # try new locations, until in range (then break out of loop)\n    while !(0 &lt; new_x &lt; 1) || !(0 &lt; new_y &lt; 1)  \n        new_x = x_locations[ind] + (sigma_disp * randn())\n        new_y = y_locations[ind] + (sigma_disp * randn())\n    end\n    # assign new location to individual in population\n    x_locations[ind] = new_x  \n    y_locations[ind] = new_y\nend\n\ndisperse_ind! (generic function with 1 method)\n\n\nWe include the ! symbol as part of the name of the disperse_ind!() function, to convey that the function modifies some of the input objects.\n\n\nPut the parts together, into one function that runs the whole simulation\n\nfunction run_sim!(iterations)\n    for i in 1:iterations\n        rand_ind = rand(1:length(x_locations))  #choose the index of a random individual\n        closest_ind = find_closest(x_locations, y_locations, rand_ind)\n        winner = roshambo(strategies[rand_ind], strategies[closest_ind])\n        # replace loser with winning strategy\n        if winner == 1 \n            strategies[closest_ind] = strategies[rand_ind]\n        elseif winner == 2\n            strategies[rand_ind] = strategies[closest_ind]  \n        end\n        # move these individuals a bit, but with boundary of 0 and 1\n        disperse_ind!(x_locations, y_locations, rand_ind, sigma_disp)\n        disperse_ind!(x_locations, y_locations, closest_ind, sigma_disp)\n    end\n    show_sim(x_locations, y_locations, strategies, plot_colors)\nend\n\nrun_sim! (generic function with 1 method)\n\n\nThe above function runs the simulation for a given number of iterations, modifying the population vectors as it goes. At the end it returns a plot of the state of the simulation.\nLet‚Äôs test the function above:\n\nrun_sim!(5000)\n\n\n\n\nThat shows us the result of the simulation after a given number of iterations. But we want to see the dynamics. Let‚Äôs make a movie!\n\n\nMake a movie of the simulation\nThe Plots package, which we have already loaded, has a wonderfully simple way of writing code that generates movies:\n\nWe use the @animate macro to initialize an Animation object and store a series of plots that are frames of the animation.\nWe use the gif() function to convert the object to an animated gif.\n\nLet‚Äôs use this by running our simulation for 100 small chunks of time, showing a frame after each chunk:\n\nanim = @animate for i in 1:100\n    plot_frame = run_sim!(5000) \nend\ngif(anim, fps=4)\n\n\n[ Info: Saved animation to /var/folders/d5/44s1c4v95rjcnh5nsvq4_0040000gn/T/jl_WhYbUnaXSB.gif\n\n\n\n\n\n\n\nWe can now see the dynamics of the simulation much more clearly. We see the rock‚Äîpaper‚Äîscissors game on a landscape with limited dispersal leads to waves of each strategy replacing other strategies over time.\n\n\n\nPlay with the above\nI‚Äôve designed this example to provide a basic structure and logic for this sort of ‚Äúindividuals on a landscape‚Äù sort of simulation. You can play around with any element of the above example. For example, you try the following (starting with simple and scaling up to more challenging):\n\nChange the dispersal distance or number of individuals, and see what happens.\nMake the graph fancier, with axis labels and explanation of colors, or adding the number of iterations as text somewhere.\nAdd a fourth strategy with its own rules, and see what happens.\nStore the three population vectors in a single data structure (by using the mutable struct command to make a new type)\nChange the way the population interacts with the edge of the range‚Äîfor instance, what if individuals who move off the right side were to appear on the left side? This would make the range have no limits, but still finite space (the resulting geometry is called a torus‚Äîlike the surface of a donut in 3D space.)\nShow some different aspect of simulation behaviour‚Äîfor instance, can you save the movements of a single individual over time, and show just that individual‚Äôs path at the end? Or could you show the population size of the three strategies over time?\nAdd something new to the simulation‚Äîfor example, what if individuals were to mate when they meet, with offspring inheriting neutral alleles (meaning no selective effects) from both parents? Could you then use this framework to track allele frequencies on the landscape over time?\n\n\n\nThink about simulating something that interests you\nIn this series of tutorials we‚Äôve learned a lot of the central logic used in programming. Now it is a matter of putting it together in ways that do things that interest you. Think about some biological question that interests you and try to consider how a computer simulation might provide you with some insight regarding that question. Then, think about how to build a simple simulation. Start small and simple. Once you develop a framework, you can add complexity later.\nSome simulation ideas that come to mind, to get the ball rolling:\n\nMigration path of a bird, according to some simple rules of movement (e.g.¬†fly southward, but with variation in exact direction and distance in each time step).\nPath of growth of a cell (e.g.¬†an axon?) according to some simple rules, perhaps in a way that avoids (or is attracted to) other cells.\nPredator - prey dynamics on a landscape.\nChange in allele frequencies over time, with random mating and no selection in a population of constant size (there is a name for this, which rhymes with ‚Äúmagnetic lift‚Äù).\nSimulation of how random mutations in a certain gene sequence might affect the amino acid structor of the encoded protein.\n\n\n\nNext steps\nNow that we have learned enough Julia to build a reasonably simple yet interesting simulation that leads to some complex behaviour, we are ready to learn more about functions, types, and multiple dispatch in Julia. Together, these concepts can be thought of as methods of control flow. They enable powerful and fascinating approaches to programming.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Build a Simulation"
    ]
  },
  {
    "objectID": "SimulationWithNewTypes.html",
    "href": "SimulationWithNewTypes.html",
    "title": "Simulate using your own Types",
    "section": "",
    "text": "Let‚Äôs build a simulation that uses our ability to define new data types (using the struct keyword). This will allow us to build parts of the simulation in an intuitive way, keeping us and our code organized.\n\nMeiotic drive in a population\nThis example is from an analysis I did about meiotic drive, meaning when chromosomes (or parts of them) have a transmission advantage during meiosis. This violates the usual rules of Mendelian inheritance, in which alleles have a 50% probability of getting into offspring. There are many known examples of meiotic drive.\nIn female meiosis (i.e., egg production) in virtually all eukaryotes, the first cell division is asymmetric, with a large part of the cell becoming the egg and a small part becoming the polar body. If a chromosome gets into the egg it has the potential to be passed down into the next generation. If it is in the polar body, it does not get passed down. Spindle fibers leading to the egg differ molecularly than those leading to the polar body. This places selection on chromosomal variants that can somehow interact with the spindle fibers in such a way that they are more likely to get into the egg.\nIf some chromosomes have an advantage getting into eggs, then they will tend to spread through a population. But what if there is a cost to these meiotic drivers? Perhaps they cause some problem in terms of whole-organism fitness. If so, perhaps there are suppression mechanisms that would spread as well.\nThis situation is particularly intriguing in species with Z / W sex chromosomes (e.g., birds, butterflies), meaning females are ZW and males are ZZ. There, a driver on the W or Z can cause the sex ratio of a female‚Äôs offspring to be biased towards females (in the case of a W driver) or males (in the case of a Z driver). The figure below illustrates meiosis and the consequences of a W driver:\n\n\n\nTransmission of the W chromosome via female meiosis, and the potential of a driving W to gain a bias in transmission, resulting in spread of the driving W and associated mitochondrial DNA (mtDNA). This is Figure 1 from Irwin 2025 BioRxiv.\n\n\nThe evolutionary dynamics of such a situation can be difficult to think through intuitively. So let‚Äôs build a simulation!\n\n\nFirst step: consider data structures and the high-level logic of our program\nLet‚Äôs consider how we can organize our simulation. One way is to invent new data types (structs) that store information at different levels, and then build functions that encapsulate the rules by which those data types interact.\nSo we‚Äôll define new types for:\n\nchromosomes (containing the kind of chromosome, its spindle attraction to the egg, its whole-organism fitness, and its ability to suppress drive)\nindividuals (containing 4 chromosomes: a sex chromosome and autosome inherited through the egg, and the same from the sperm)\npopulations (containing a bunch of female [ZW] individuals and a bunch of male [ZZ] individuals)\n\nBy setting up the above framework, we‚Äôll be able to create functions that work with data at various levels, keeping everything well organized. Key functions will govern:\n\nmating of two individuals, determining the chromosomes inherited by their offspring (i.e., new individuals)\nbreeding of one generation of a population, by choosing random parents for each offspring\nsurvival of offspring to adulthood, based on fitness\nrecording frequencies of chromosome types and sexes in each generation\nrunning many generations\ngraphing results\n\n\n\nDefining our new types\n\nChromosomes\nTo store information for each chromosome, we‚Äôll invent a Chrom type. It is convention in Julia for types to start with a capital letter (whereas functions start with lower case letters).\n\nstruct Chrom\n    kind\n    spindleAttraction # this means the strength of attraction to the egg (with 1.0 meaning a normal non-driver)\n    # fitnessLoss (commented out, but we may want to add later)\n    # suppressStrength (commented out, but we may want to add later)\nend\n\nLet‚Äôs now create some sex chromosomes, some with a drive advantage and some without:\n\ndriveStrength = 1.5  # sets this to be the drive strength of each driving chrom type\nboringW = Chrom(\"W\", 1.0) # a simple nothing-special W chromosome\ndrivingW = Chrom(\"W\", driveStrength) # a driving W\nboringZ = Chrom(\"Z\", 1.0) \n# drivingZ = Chrom(\"Z\", driveStrength)\n\nChrom(\"Z\", 1.0)\n\n\nLet‚Äôs add a simple autosome with nothing special:\n\nboringAutosome1 = Chrom(\"1\", 1.0)\n\nChrom(\"1\", 1.0)\n\n\n\n\nIndividuals\nWe‚Äôll define an Indiv type that has four chromosomes, and here we choose to specify that they must be of the Chrom type.\n\nstruct Indiv\n    sexChromFromEgg::Chrom \n    sexChromFromSperm::Chrom\n    autosome1FromEgg::Chrom\n    autosome1FromSperm::Chrom\nend\n\nNow we can create some kinds of individuals, by specifying the four chromosomes according to the order above:\n\nfemaleBoring = Indiv(boringW, boringZ, boringAutosome1, boringAutosome1)\nfemaleDriveW = Indiv(drivingW, boringZ, boringAutosome1, boringAutosome1)\nmaleBoring = Indiv(boringZ, boringZ, boringAutosome1, boringAutosome1)\n\nIndiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0))\n\n\n\n\nPopulations\nNow we can create a data type that stores a whole population of females and males:\n\nmutable struct Population\n    popFemales\n    popMales\nend\n\nWe make this a mutable struct because the population will change over time (whereas each kind of chromosome and individual does not need to change after creation).\nCreate a starting population of 20000 individuals in which 5% of the W are driving:\n\npop1Females = vcat(fill(femaleDriveW, 500), fill(femaleBoring, 9500))\npop1Males = vcat(fill(maleBoring, 10000))\npop1 = Population(pop1Females, pop1Males)\n\nPopulation(Indiv[Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0))  ‚Ä¶  Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0))], Indiv[Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0))  ‚Ä¶  Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0))])\n\n\nWe now have the main data structures needed for our simulations, so let‚Äôs define functions that do things with them.\n\n\n\nWrite a mating function\nOur function will use the function sample() from the StatsBase package to make a random choice of chromosome to inherit, weighted by transmission probability. To download and install that package, if using the REPL, enter the package manager by typing ] and then type add StatsBase. Then, call that package into memory:\n\nusing StatsBase  # needed for \"sample\" function\n\n\n\n\n\n\n\nTipPluto automatically installs packages\n\n\n\nIf using Pluto, you don‚Äôt need to explicitly add a package. Rather, using StatsBase will cause Pluto to download and install on first use. üòÉ\n\n\nGiven one female (ZW) and one male (ZZ) parent, we will write a function to determine the chromosomes passed on to one offspring, incorporating transmission advantage as calculated by the ratio of spindleAttraction of each chromosome compared to total spindleAttraction:\n\nfunction makeOneOffspring(female, male) \n    # determine sex chromosome of egg, weighted by spindleAttraction\n    transProbSexChromFromEgg = female.sexChromFromEgg.spindleAttraction / \n                    (female.sexChromFromEgg.spindleAttraction + female.sexChromFromSperm.spindleAttraction)\n    eggSexChrom = sample([female.sexChromFromEgg, female.sexChromFromSperm], \n        Weights([transProbSexChromFromEgg, 1 - transProbSexChromFromEgg]))\n    # determine sex chromosome of sperm, with no drive (Mendelian)\n    spermSexChrom = sample([male.sexChromFromEgg, male.sexChromFromSperm])\n    # determine autosome1 in egg, weighted by spindleAttraction\n    transProbAutosome1FromEgg = female.autosome1FromEgg.spindleAttraction / \n                    (female.autosome1FromEgg.spindleAttraction +\n                    female.autosome1FromSperm.spindleAttraction)\n    eggAutosome1 = sample([female.autosome1FromEgg, female.autosome1FromSperm], \n                    Weights([transProbAutosome1FromEgg, 1 - transProbAutosome1FromEgg]))\n    # determine autosome1 in sperm, Mendelian\n    spermAutosome1 = sample([male.autosome1FromEgg, male.autosome1FromSperm])\n    \n    return Indiv(eggSexChrom, spermSexChrom, eggAutosome1, spermAutosome1)\nend\n\nmakeOneOffspring (generic function with 1 method)\n\n\nLet‚Äôs check that our function works:\n\nmakeOneOffspring(femaleDriveW, maleBoring)\n\nIndiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0))\n\n\nIt does, but does it produce the transmission bias? Let‚Äôs build a test function to check that:\n\nfunction test_makeOneOffspring(female, male, reps)\n    offspringSex = fill(\"N\", reps)\n    for i in 1:reps\n        kid = makeOneOffspring(female, male)\n        if kid.sexChromFromEgg.kind == \"W\"\n            offspringSex[i] = \"F\"\n        else offspringSex[i] = \"M\"\n        end\n    end\n    proportionFemale = (sum(offspringSex .== \"F\") / reps)\n    println(\"Out of \" * string(reps) * \" offspring, the proportion female is \" * string(proportionFemale))\nend\n\ntest_makeOneOffspring (generic function with 1 method)\n\n\nNow run some tests:\n\ntest_makeOneOffspring(femaleDriveW, maleBoring, 1_000_000)\n\nOut of 1000000 offspring, the proportion female is 0.600461\n\n\nFor a W driver with driveStrength of 1.5, the above should result in about 50% more females than males, so a proportion of 0.6 female (and 0.4 male).\nWhen a female has no driving chromosomes, then the proportion of females should be about 0.5:\n\ntest_makeOneOffspring(femaleBoring, maleBoring, 1_000_000)\n\nOut of 1000000 offspring, the proportion female is 0.499748\n\n\n\n\nWrite a function to breed one generation\nSince we have a function for producing one offspring (see above), we can call that repeatedly to make an entire new generation of offspring, with each offspring having a randomly chosen mother and father. In addition to random mating, here we will assume constant population size and non-overlapping generations.\n\nfunction breedOneGeneration(population::Population; k = length(population.popFemales) + length(population.popMales))\n    # can set the number of offspring (k) in function call, or leave out and it will set k according to the current population size\n    offspringFemales = []\n    offspringMales = []\n    # cycle through offspring, choosing random parents\n    for i in 1:k\n        mother = sample(population.popFemales)\n        father = sample(population.popMales)\n        offspring = makeOneOffspring(mother, father)\n        if offspring.sexChromFromEgg.kind == \"W\" # so offspring is female\n            push!(offspringFemales, offspring)\n        elseif offspring.sexChromFromEgg.kind == \"Z\" # so offspring is male\n            push!(offspringMales, offspring)\n        end\n    end\n    return Population(offspringFemales, offspringMales)\nend\n\nbreedOneGeneration (generic function with 1 method)\n\n\nLet‚Äôs test the above function with one generation of breeding of the pop1 that we created further above:\n\npopNext = breedOneGeneration(pop1)\nprintln(\"The offspring generation has \", string(length(popNext.popFemales)), \" females and \", string(length(popNext.popMales)), \" males.\")\n\nThe offspring generation has 10086 females and 9914 males.\n\n\n\n\nWrite some functions for recording population proportions\n\nfunction getPropDrivingW(population::Population)\n    driving = []\n    for i in population.popFemales # all females have a single W, making next line OK\n        if i.sexChromFromEgg.spindleAttraction &gt; 1.0\n            push!(driving, true)\n        else push!(driving, false)\n        end\n    end\n    return sum(driving) / length(driving)\nend\n\ngetPropDrivingW (generic function with 1 method)\n\n\nTest this function:\n\ngetPropDrivingW(pop1)\n\n0.05\n\n\nLet‚Äôs also record the proportion of females:\n\nfunction getPropFemale(population::Population)\n    length(population.popFemales) / \n            (length(population.popFemales) + length(population.popMales))\nend\n\ngetPropFemale (generic function with 1 method)\n\n\nTry it:\n\ngetPropFemale(pop1)\n\n0.5\n\n\n\n\nPut it all together\nWe now have all the pieces to build a big-picture function that runs the simulation for many generations:\n\nfunction runManyGens(population::Population, gens::Int; k = length(population.popFemales) + length(population.popMales))\n    # The above sets k (the number of offspring in each generation) as the starting population size\n    # Create vectors to store proportions over the generations:\n    propFemale = fill(-0.9999, gens+1)      # Fill with obviously wrong values,\n    propDrivingW = fill(-0.9999, gens+1)    # which will be written over as simulation proceeds.\n    # record proportions in starting population (generation 0; index 1)\n    propFemale[1] = getPropFemale(population)\n    propDrivingW[1] = getPropDrivingW(population)\n    # Loop through generations\n    for i in 1:gens\n        # produce offspring\n        population = breedOneGeneration(population; k)\n        # record proportions in the offspring generation\n        propFemale[i+1] = getPropFemale(population)\n        propDrivingW[i+1] = getPropDrivingW(population)\n    end\n    return (propFemale = propFemale, \n            propDrivingW = propDrivingW, \n            population = population)\nend\n\nrunManyGens (generic function with 1 method)\n\n\nThe above function returns a tuple containing the record of female proportions over time, driving W proportions over time, and the final population.\n\n\nRun the simulation!!\nOK, we‚Äôve done a lot of setup. Now lets run and see what happens. This will rely on the Plots package‚Äîif not installed yet and if you are using the REPL, enter the package manager by typing ] at the REPL prompt, then type add Plots.\n\nusing Plots\nrunLength = 100  # generations\npop1run = runManyGens(pop1, runLength)\npop1plot = plot(0:runLength, pop1run.propFemale, color = :purple, label = \"Females\", xlabel = \"Generations\", ylabel = \"Proportion\", title = \"Driving W, Drive Strength = \" * string(driveStrength))\nxlims!(0, runLength)  # sets x axis limits\nylims!(0, 1.05)  # sets y axis limits\nplot!(0:runLength, pop1run.propDrivingW, color = :red, label = \"Driving W\")\n\n\n\n\nOur graph shows something not too surprising: the driving W (red line) spreads through the population rather quickly, and this causes the sex ratio to change from 50% to about 60% female.\nYou could play with the simulation by changing the value of driveStrength or the starting population size and frequency of the driving W.\nOr, let‚Äôs try asking an interesting question: How fast would a driving Z (rather than W) spread? Would it have the same potential as a W to spread, or would it go faster or slower? If both a driving W and driving Z start at the same low frequency, what happens?\n\n\nAdd a driving Z\nBecause we‚Äôve built our simulation above using data structures (types) and functions that are well-organized and quite general (not specific to the particular scenario in the graph above), it is easy for us to add another kind of chromosome and see what happens:\n\ndrivingZ = Chrom(\"Z\", driveStrength)\n\nChrom(\"Z\", 1.5)\n\n\nThis creates a Driving Z chromosome that has the equivalent drive strength as our Driving W above (a 50% advantage in getting into the egg, compared to a ‚Äúboring‚Äù Z or W).\nWe can now make some new kinds of starting individuals, with respect to the driving Z chromosome:\n\nfemaleDriveZ = Indiv(boringW, drivingZ, boringAutosome1, boringAutosome1)\nfemaleDriveWZ = Indiv(drivingW, drivingZ, boringAutosome1, boringAutosome1)\nmaleFirstDriveZ = Indiv(drivingZ, boringZ, boringAutosome1, boringAutosome1)\nmaleSecondDriveZ = Indiv(boringZ, drivingZ, boringAutosome1, boringAutosome1)\nmaleTwoDriveZ = Indiv(drivingZ, drivingZ, boringAutosome1, boringAutosome1)\n\nIndiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0))\n\n\nNow let‚Äôs make a population that has 5% starting Driving Z. This will be more complex than in the Driving W case, because there are more kinds of starting individuals. The code below set‚Äôs things up initially according to Hardy-Weinberg equilibrium (i.e.¬†according to frequencies that would result from random mating):\n\npop2setPropDrivingZ = 0.05\npop2SizeFemale = 10_000\npop2SizeMale = 10_000\npop2Females = vcat(fill(femaleDriveZ, Int(round(pop2setPropDrivingZ * pop2SizeFemale))), \n                fill(femaleBoring, Int(round((1-pop2setPropDrivingZ) * pop2SizeMale))))\npop2numMaleTwoDriveZ = Int(round(pop2setPropDrivingZ^2 * pop2SizeMale))\npop2numMaleFirstDriveZ = Int(round(pop2setPropDrivingZ * (1-pop2setPropDrivingZ) * pop2SizeMale))\npop2numMaleSecondDriveZ = Int(round((1-pop2setPropDrivingZ) * pop2setPropDrivingZ * pop2SizeMale))\npop2numMaleBoring = Int(round((1-pop2setPropDrivingZ)^2 * pop2SizeMale))\npop2Males = vcat(fill(maleTwoDriveZ, pop2numMaleTwoDriveZ),\n                fill(maleFirstDriveZ, pop2numMaleFirstDriveZ),\n                fill(maleSecondDriveZ, pop2numMaleSecondDriveZ),\n                fill(maleBoring, pop2numMaleBoring))\npop2 = Population(pop2Females, pop2Males)\n\nPopulation(Indiv[Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0))  ‚Ä¶  Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0))], Indiv[Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0))  ‚Ä¶  Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0))])\n\n\nWe need to add a function for calculating the population proportion of the driving Z, so we can track that over the generations:\n\nfunction getPropDrivingZ(population::Population)\n    driving = []\n    # have to cycle through females and males to count up all the driving Z\n    for i in population.popFemales\n        if i.sexChromFromSperm.spindleAttraction &gt; 1.0\n            push!(driving, true)\n        else push!(driving, false)\n        end\n    end\n    for i in population.popMales\n        if i.sexChromFromEgg.spindleAttraction &gt; 1.0\n            push!(driving, true)\n        else push!(driving, false)\n        end\n        if i.sexChromFromSperm.spindleAttraction &gt; 1.0\n            push!(driving, true)\n        else push!(driving, false)\n        end     \n    end\n    return sum(driving) / length(driving)       \nend\n\ngetPropDrivingZ (generic function with 1 method)\n\n\nLet‚Äôs also modify the runManyGens() funciton so that it keeps track of the driving Z frequency:\n\nfunction runManyGens(population::Population, gens::Int; k = length(population.popFemales) + length(population.popMales))\n    # The above sets k (the number of offspring in each generation) as the starting population size\n    # Create vectors to store proportions over the generations:\n    propFemale = fill(-0.9999, gens+1)      # Fill with obviously wrong values,\n    propDrivingW = fill(-0.9999, gens+1)    # which will be written over as simulation proceeds.\n    propDrivingZ = fill(-0.9999, gens+1)\n    # record proportions in starting population (generation 0; index 1)\n    propFemale[1] = getPropFemale(population)\n    propDrivingW[1] = getPropDrivingW(population)\n    propDrivingZ[1] = getPropDrivingZ(population)\n    # Loop through generations\n    for i in 1:gens\n        # produce offspring\n        population = breedOneGeneration(population; k)\n        # record proportions in the offspring generation\n        propFemale[i+1] = getPropFemale(population)\n        propDrivingW[i+1] = getPropDrivingW(population)\n        propDrivingZ[i+1] = getPropDrivingZ(population)\n    end\n    return (propFemale = propFemale, \n            propDrivingW = propDrivingW,\n            propDrivingZ = propDrivingZ, \n            population = population)\nend\n\nrunManyGens (generic function with 1 method)\n\n\nLet‚Äôs now run the simulation with this starting population, and graph the results:\n\npop2run = runManyGens(pop2, runLength)\npop2plot = plot(0:runLength, pop2run.propFemale, color = :purple, label = \"Female\", xlabel = \"Generations\", ylabel = \"Proportion\", title = \"Driving Z, Drive Strength = \" * string(driveStrength))\nxlims!(0,runLength)\nylims!(0, 1.05)\nplot!(0:runLength, pop2run.propDrivingZ, color = :blue, label = \"Driving Z\")\n\n\n\n\nThis shows us something interesting: Equivalent strength W and Z drivers tend to spread through a population at different rates. The W spreads much more quickly. This is something that maybe some people would intuit in advance, and might be a surprise to many. Our simulation shows us this, and we can then ponder ‚ÄúWhy?‚Äù\nAfter some thought, we might realize the answer: All of the W chromosomes are in females, whereas only 1/3 of Z chromosomes are in females (assuming equal sex ratios). Because the meiotic drive advantage only applies in female meiosis (rather than male), the strength of selection for the W driver is much greater than that for the Z driver.\n\nWhat happens when both Z and W drivers are in a population?\nLet‚Äôs now start a population with both Z and W drivers at 5% initially. Might they both cancel out each other‚Äôs effects? (After all, when in the same pre-meiotic cell, neither has an advantage getting into the egg.)\nLet‚Äôs see by running a simulation!\nOur setup of the starting population is even a little more complex, because there are more kinds of starting individuals:\n\npop4setPropDrivingW = 0.05\npop4setPropDrivingZ = 0.05\npop4SizeFemale = 10_000\npop4SizeMale = 10_000\n\npop4numFemaleDriveWZ = Int(round(pop4setPropDrivingW * pop4setPropDrivingZ * pop4SizeFemale))\npop4numFemaleDriveW = Int(round(pop4setPropDrivingW * (1-pop4setPropDrivingZ) * pop4SizeFemale))\npop4numFemaleDriveZ = Int(round((1-pop4setPropDrivingW) * pop4setPropDrivingZ * pop4SizeFemale))\npop4numFemaleBoring = Int(round((1-pop4setPropDrivingW) * (1-pop4setPropDrivingZ) * pop4SizeFemale))\n\npop4Females = vcat(fill(femaleDriveWZ, pop4numFemaleDriveWZ),\n                fill(femaleDriveW, pop4numFemaleDriveW),\n                fill(femaleDriveZ, pop4numFemaleDriveZ),\n                fill(femaleBoring, pop4numFemaleBoring))\n\npop4numMaleTwoDriveZ = Int(round(pop4setPropDrivingZ^2 * pop4SizeMale))\npop4numMaleFirstDriveZ = Int(round(pop4setPropDrivingZ * (1-pop4setPropDrivingZ) * pop4SizeMale))\npop4numMaleSecondDriveZ = Int(round((1-pop4setPropDrivingZ) * pop4setPropDrivingZ * pop4SizeMale))\npop4numMaleBoring = Int(round((1-pop4setPropDrivingZ)^2 * pop4SizeMale))\npop4Males = vcat(fill(maleTwoDriveZ, pop4numMaleTwoDriveZ),\n                fill(maleFirstDriveZ, pop4numMaleFirstDriveZ),\n                fill(maleSecondDriveZ, pop4numMaleSecondDriveZ),\n                fill(maleBoring, pop4numMaleBoring))\npop4 = Population(pop4Females, pop4Males)\n\nPopulation(Indiv[Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0))  ‚Ä¶  Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"W\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0))], Indiv[Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.5), Chrom(\"Z\", 1.5), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0))  ‚Ä¶  Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0)), Indiv(Chrom(\"Z\", 1.0), Chrom(\"Z\", 1.0), Chrom(\"1\", 1.0), Chrom(\"1\", 1.0))])\n\n\nNow, let‚Äôs run it:\n\npop4run = runManyGens(pop4, runLength)\npop4plot = plot(0:runLength, pop4run.propFemale, color = :purple, label = \"Female\", xlabel = \"Generations\", ylabel = \"Proportion\", title = \"Driving W and Z, Drive Strength = \" * string(driveStrength))\nxlims!(0, 100)\nylims!(0, 1.05)\nplot!(0:runLength, pop4run.propDrivingW, color = :red, label = \"Driving W\")\nplot!(0:runLength, pop4run.propDrivingZ, color = :blue, label = \"Driving Z\")\n\n\n\n\nHere, we see that the driving Z has little ability to hinder the spread of the driving W. Rather, the driving W still spreads quickly, going to fixation, and the driving Z spreads more slowly. We see that the sex ratio becomes female-biased as the driving W spreads, but eventually returns to 50:50 when the driving Z goes towards fixation.\nThe net effect is that W drivers have great potential to spread, and these can be followed by Z drivers, returning the sex ratio to an unremarkable level. The insight then from these simulations is that spread of W and Z drivers can occur regularly within species, and we might not notice.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Simulate using your own Types"
    ]
  }
]