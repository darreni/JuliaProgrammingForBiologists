[
  {
    "objectID": "IntroToJulia.html",
    "href": "IntroToJulia.html",
    "title": "Introductory Tour of Julia",
    "section": "",
    "text": "Now that we have Julia running, we can learn how to enter expressions that Julia will evaluate.\nThe simplest expressions are just a single number or string of text, e.g.¬†try entering something like:\n\n5\n\n5\n\n\nAfter you type 5 at the julia&gt; prompt and press enter, Julia responds with 5, the returned value of your expression.\nYou can do a little more complex expression:\n\n7 * (6 - 1)\n\n35\n\n\n\nArithmetic operators\nPlay around with other simple mathematical expressions. These are some of the main arithmetic operators, which you are likely familiar with: + , -, *, /, ^. Try using parentheses to control the order of operations (for example: compare the returned value of 3 + 5 / 2^3 and (3 + 5) / 2^3).\nOne that operator that you might be less familiar with is the remainder operator % which gives the remainder of a division. Try it out:\n\n7 % 2\n\n1\n\n\nAnother is the √∑ operator, which produces just the integer part of a division (without the decimal part). You aren‚Äôt likely to use √∑ very often, but I include it here as an example of Julia‚Äôs use of unicode characters (more on this below). To type that character at the Julia prompt, enter \\div followed by the tab key.\n\n\nFunctions\nWe can also use some functions in our expressions. A function is something that does a specific thing defined by code already loaded into memory. You can recognize a function in Julia by the fact that it will be a string of text followed immediately by parentheses, perhaps with inputs to the function inside the parentheses. Here we use the sqrt() function, which produces a square root of the number in the parentheses.\n\nsqrt(16)\n\n4.0\n\n\n\n\nAssigning values to variable names\nEach of the above expressions returns a value that we can give a name and store in memory, using the equal sign =, the assignment operator. For example:\n\nx = 2sqrt(9)\n\n6.0\n\n\nThe above command does several interesting things:\n\nIt evaluates the expression on the right side of the equal sign.\nIt checks whether there is already an object in memory with the name given on the left side of the equal sign (in this case, x). If not, it creates that object.\nIt assigns the value produced by the right side to the object named by the left side.\n\nWe can then use that named object‚Äôs value in subsequent expressions:\n\n4x\n\n24.0\n\n\nAssigning values to named objects allows us to save values in memory and then combine them in our calcuations:\n\npop1 = 50; pop2 = 200; totalPop = pop1 + pop2\n\n250\n\n\nThe semicolons above are used to separate distinct expressions that Julia should evaluate before continuing to the next. This is called a compound expresssion and is a convenient to enter several commands on the same line. Another way to enter a compound expression is with a begin-end block:\n\nbegin\n  x = 17\n  y = x^2\nend\n\n289\n\n\n\n\n\n\n\n\nCalculate the area of a circular forest patch\n\n\n\nPick a number for the radius (in km) of a circle, and assign that to a variable name and store that in Julia‚Äôs memory. Then in a separate command, use that variable to calculate the area of the circle (the standard formula for this is œÄ\\(r^{2}\\); to write the exponent of ‚Äò2‚Äô though, you‚Äôll need to use ‚Äò^2‚Äô). A neat thing is that Julia already knows the value of œÄ; to get it, just type pi or alternatively \\pi then tab.\n\n\n\n\nDifferent Types of numbers\nWhen computers store numbers, they can do it in different ways, each with their advantages and disadvantages. Two main ways that Julia can store numbers are as integers or as floating-point numbers. Integers have exact values but are quite limited in the values they can take, whereas floating-point numbers can take many more values but have a disadvantage that they are not exact.\nWe can learn about the Type that Julia uses to store values by using the typeof() function:\n\ntypeof(3)\n\nInt64\n\n\nJulia responds by saying that the value 3 is of the Int64 type. This means that it is an integer stored in memory using 64 bits. (No worries if you don‚Äôt know what this means.) Now compare to this:\n\ntypeof(3.0)\n\nFloat64\n\n\nJulia responds by sayng 3.0 is of the Float64 type. This means a 64-bit floating-point number. By writing the .0 after the 3 we have told Julia we want this number treated as a floating-point number.\nMuch of the time, we don‚Äôt need to think about variable types, because Julia is smart and handles types through something called dynamic typing. Here‚Äôs an example:\n\na = 2\nb = 3.0\nc = a + b\ntypeof(c)\n\nFloat64\n\n\nAbove, Julia figures that by entering b = 3.0 you are indicating that you want b treated as a floating-point number, so when it adds the integer 2 to this, it returns a floating-point number.\nJulia has all sort of other useful Types of numbers. One that I will point out here is the Rational number type, which you can construct with the // operator and do exact calculations using ratios:\n\nratio1 = 1//3\nratio2 = 5//7\nproduct = ratio1 * ratio2\n\n5//21\n\n\nAs your Julia skills increase, there are large benefits to being somewhat aware of types; this can help you write efficient programs and help with debugging your code. You can even define your own Types.\n\n\nRanges\nJulia has a neat data structure (i.e.¬†a type) to store arithmetic series of numbers:\n\nrangeOfNums = 1:100\nprintln(rangeOfNums)\ntypeof(rangeOfNums)\n\n1:100\n\n\nUnitRange{Int64}\n\n\nJulia stores this range efficiently, until the actual numbers are needed. If we want to actually convert it to the numbers themselves, we could enter something like collect(rangeOfNums)\nIf we want only the even numbers, we enter something like collect(0:2:30).\n\n\n\n\n\n\nCreate a descending vector\n\n\n\nYou have a population of 30 individuals that is decreasing by 3 individuals in each time step. Use the collect() function to create a list of numbers (a.k.a. a vector) representing the population sizes at each time step (until the population goes extinct).\n\n\n\n\nCharacters and Strings\nProgramming in biology often involves manipulating text such as ‚ÄúACGT‚Äù. For this, we can use two other variable types in Julia: characters (officially Char) and strings (officially String), which are usually made up of a series of characters (imagine beads of letters on a string, ha ha).\nWe enter characters with single quotes, and can combine them to make strings:\n\nnucleotide1 = 'T'\nnucleotide2 = 'C'\ndinucleotide = nucleotide1 * nucleotide2\n\n\"TC\"\n\n\nAbove, we create two variables of type Char and combined them (yes, Julia views combining characters or strings as a form of multiplication, ha ha) to produce a String.\n\n\n\n\n\n\nExponents on Strings\n\n\n\nIf Julia uses the * symbol for combining two characters or strings into a longer string, what do you think it might use the ^ symbol for, when applied to a character or string? Make a guess, and then play around and find out. (If you are stuck, try entering 'T'^2 and think about what the REPL returns)\n\n\nWhen you enter a String into Julia, you need to use double quotes (unlike a Char with single quotes).\n\noligo1 = \"ACGCAT\"\noligo2 = \"CCCTG\"\nligation = string(oligo1, oligo2)\n\n\"ACGCATCCCTG\"\n\n\nThe function string above concatenates different strings together.\n\n\n\n\n\n\nYour favourite species\n\n\n\nAssign a few of your favorite species to different variable names, and then combine them into a single string, with commas separating their names.\n\n\n\n\nUnicode characters\nOne fun thing about Julia is that you can use Unicode variables in variable names, strings, function names, and some operators. The motivator for this is to make code read more like humans tend to write mathematics. For example:\n\nœá¬≤ = 30.4\nŒ≤ = 2œá¬≤\n\n60.8\n\n\nTo make the Unicode symbols above, you would type \\chi tab \\^2 tab, and on the next line \\beta tab. Notice also that the expression 2œá¬≤ is evaluated the same as 2*œá¬≤ or 2 * œá¬≤.\nUnicode also allows some fun.\n\n\n\n\n\n\nPlant biology using Unicode\n\n\n\nAssign a variable a the value of a Char given by typing \\:seedling: tab. Assign a variable b the value of a Char given by typing \\:deciduous_tree: tab. Then execute this line:\nstring(a, \" grows into \", b)\n\n\nWe can also use Unicode symbols in variable names:\n\nüê¨ = 47    # write with: \\:dolphin: tab\nüê≥ = 5     # write with: \\:whale: tab\ntotalMarineMammals = üê¨ + üê≥\n\n52\n\n\nNote the use of the # symbol to make comments to the right of code.\nYou can find how to write a whole bunch of Unicode symbols by clicking here\n\n\nComparisons and Booleans\nIn programming it is often important to check if certain conditions are true or false. These values are called Booleans (of type Bool in Julia).\nThese comparison operators are used to compare two values (place to left and right of the operator), resulting in true or false:\n== : equal? (notice the two equal symbols)\n!= : not equal?\n&lt; : less than?\n&lt;= : less than or equal?\n&gt; : greater than?\n&gt;= : greater than or equal?\n\nTry a bunch of comparisons of values using the above. These are called Boolean expressions. For example:\n\nsqrt(9) == 3\n\ntrue\n\n\n\nx = 8; sqrt(x) &gt;= 3\n\nfalse\n\n\nWe can use Boolean operators to combine multiple comparisons. These are used as follows, where x and y are Boolean expression:\n!x : not x\nx && y : x and y\nx || y : x or y\n\nFor example:\n\n5 &lt;= 3 && 7 == 14/2\n\nfalse\n\n\n\n5 &lt;= 3 || 7 == 14/2\n\ntrue\n\n\n\n!(5 &lt;= 3 || 7 == 14/2)\n\nfalse\n\n\n\n\n\n\n\n\nSelect the extremes\n\n\n\nThe expression rand() gets a random number between 0 and 1. Write a series of commands that pick such a random number, and then return true if that number is either above 0.75 or below 0.25, and false otherwise.\n(If you solve the above and have time, can you figure out a way to chain your Boolean expressions into a form similar to value1 &lt; x &lt; value2 ?)\n\n\n\n\nCollections, e.g.¬†Arrays\nVariables can contain more than a single item in them. A general term for such a data structure is a collection. An array is a common type of collection used in Julia: It can be thought of as an n-dimensional lattice of boxes, where you can store something in each box. Below we create some kinds of arrays:\n\narrayA = [7.3, 3, 11.2, -5, 3.2]\n\n5-element Vector{Float64}:\n  7.3\n  3.0\n 11.2\n -5.0\n  3.2\n\n\n\narrayB = [6 5 4; 3 2 1]\n\n2√ó3 Matrix{Int64}:\n 6  5  4\n 3  2  1\n\n\nBecause these variables are more complex data structures that the simple ones we‚Äôve looked at so far, Julia tells you the type of the returned value, before showing you the actual values.\nNote that a Vector is another name (an alias) for a 1-dimensional array, and a Matrix is another name for a 2-dimensional array. Inside the curly brackets, Julia indicates the Type that each element of the array belongs to (this is Float64 in the first case, and Int64 in the second).\nWe can ask Julia to return the values in parts of an array by indexing into the array. For example:\n\narrayA[3]\n\n11.2\n\n\n\narrayA[end]\n\n3.2\n\n\nWhat do you think using begin as an index would do? Try it!\n\narrayB[2, 2:3]\n\n2-element Vector{Int64}:\n 2\n 1\n\n\nWe can even use such indexing to change the value stored one of the ‚Äúboxes‚Äù in an array:\n\narrayB[2, 2] = -129\narrayB\n\n2√ó3 Matrix{Int64}:\n 6     5  4\n 3  -129  1\n\n\nWe‚Äôre going to eventually learn a lot more about arrays, as they are super useful in data science, bioinformatics, and simulations.\n\nTuples\nAnother kind of collection is called a tuple. It is a lot like a vector (a 1-dimensional array) but is immutable. This means that once defined, you cannot change specific values stored in a particular tuple. We create them using parentheses and commas:\n\nmyTuple = (1.3, 2.7, -12)\ntypeof(myTuple)\n\nTuple{Float64, Float64, Int64}\n\n\nThe response tells us that the object we created is of Tuple type, and it tells us the types of each element in the tuple.\nWe can also create named tuples in which we give names to the values:\n\nnt = (base = \"C\", position = 35, chrom = \"Z\")\n\n(base = \"C\", position = 35, chrom = \"Z\")\n\n\nWe can get the value of a certain element by using that name, like this:\n\nnt.base\n\n\"C\"\n\n\nThe above is one of the uses of the ‚Äú.‚Äù symbol, to access a named element within a tuple. (Another use, quite different, is described after the next heading below).\nTuples are useful for storing and calling fixed bits of info together. Because they are not mutable, Julia can store and use them in a more efficient way than arrays. They are also used when calling functions (we‚Äôll explore this later).\n\n\n\nBroadcasting\nWe often want to apply an operation or function to each element of an array. In Julia this is called ‚Äúbroadcasting‚Äù and is accomplished by the humble ‚Äúdot‚Äù operator: .\nWe can put this dot in front of any arithmetic operator to make the operator apply to each element of a collection:\n\narrayB.^2\n\n2√ó3 Matrix{Int64}:\n 36     25  16\n  9  16641   1\n\n\n\n3 .* [5, -1, 3]\n\n3-element Vector{Int64}:\n 15\n -3\n  9\n\n\nWe can also put this dot right after a function to have the function apply to each element in a collection:\n\nsqrt.([64 25 36])\n\n1√ó3 Matrix{Float64}:\n 8.0  5.0  6.0\n\n\n\n\nMacros\nMacros are a kind of function that takes text as input and converts it to code that is then evaluated. They are a somewhat advanced topic in terms of developing a full undertanding. For now, I just want to mention them because some are hugely useful even when starting out. As an example, if you are doing a lot of ‚Äúdot‚Äù operations, you can use the @. macro to convert all the operators in a line to dot operators:\n\nbegin\n  data = [3 7 -4 9]\n  results = @. 2data + data^2\nend\n\n1√ó4 Matrix{Int64}:\n 15  63  8  99\n\n\nThe line with the @. macro produces the same output as:\n\nresults = 2 .* data .+ data.^2\n\n1√ó4 Matrix{Int64}:\n 15  63  8  99\n\n\nAnother useful macro is @time :\n\n@time sum(rand(1000))\n\n  0.000014 seconds (3 allocations: 7.875 KiB)\n\n\n502.73086435185957\n\n\nThe rand(x) function produces x random numbers between 0 and 1. The above returns the sum of 1000 such numbers. Julia tells you the time it took, followed by the sum.\n\n\n\n\n\n\nEven more numbers!\n\n\n\nModify the above code so that it takes the square of each of one million random numbers between 0 and 1, and then adds them up.\n\n\n\n\nDefining your own functions\nJulia facilitates the writing of your own functions. This can have huge benefits in terms of organizing your programs and making them efficient. There are several ways to define them:\n\nsumSqrtRands(x) = sum(sqrt.(rand(x)))\n\nsumSqrtRands (generic function with 1 method)\n\n\nWe‚Äôve defined that function. Now we can use it:\n\n@time sumSqrtRands(1_000_000)\n\n  0.008953 seconds (6 allocations: 15.259 MiB)\n\n\n666644.3201128445\n\n\nBelow demonstrates another way to write functions, in this case with two arguments (things you pass into the function, called parameters inside the function):\n\nfunction xSquaredPlusY(x, y)\n  x^2 + y\nend\n\nxSquaredPlusY (generic function with 1 method)\n\n\nTry calling that function a few times, with different values of x and y, e.g.:\n\nxSquaredPlusY(3, -2)\n\n7\n\n\n\n\n\n\n\n\nApply your function to many elements at once\n\n\n\nCan you figure out how to call the above function in a way where you can input a series of numbers as the first argument (for example, x = [1, 3, 7]), and -2 as the second argument? (Hint: if you get an error, reviewing the Broadcasting section above might help)\n\n\n\n\nPackages\nThousands of people around the world have contributed over 10,000 packages that extend functionality of Julia. Installing these packages is easy.\nFirst, enter the package mode of the REPL by typing the right square bracket symbol ] . You will then see the julia&gt; prompt change into a prompt that looks something like (@v1.11) pkg&gt; . Then, type a command to add a package, e.g.:\nadd Plots\nThis tells Julia to download and install the officially registered package with that name. The Plots package is a big one, so this can take some time.\nTo get out of package mode, press the ‚Äúdelete‚Äù key and this will return you to the normal Julia REPL mode.\nTo actually use the Plots package, we need to load it into the memory for this Julia session. To do that, simply write:\n\nusing Plots\n\nNow, let‚Äôs use a function called plot() that is included in this Plots package. Try:\n\nx = -5:5\ny = x .^ 2\nplot(x, y)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis will likely open another window on your computer, and show a plot. (If not, don‚Äôt worry; we‚Äôre going to set up another good way to plot in the next page.)\nIf the above worked, you can see another way to run the plot() function here:\n\nf(x) = x^2\nplot(f)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn our first use of the plot() function above, we passed in two argument, both vectors of numbers. In the second, we passed in just a mathematical function, and plot() figured out a good way to show us the mathematical relationship represented by that function.\nThis flexibility in function calls is an example of multiple dispatch, a key feature of Julia. We‚Äôll come back to this topic in the future.\n\n\nNext steps\nWe‚Äôve now learned a lot of basic concepts related to Julia programming, and it is now time to put them together in more complex ways. For that, we‚Äôll learn how to use Pluto notebooks on the next page. This will enable to write longer programs and organize and save them.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Introductory Tour of Julia"
    ]
  },
  {
    "objectID": "BuildSimulation.html",
    "href": "BuildSimulation.html",
    "title": "Build a Simulation",
    "section": "",
    "text": "Now that we‚Äôve learned a lot of programming methods, let‚Äôs build a more complex simulation. We could choose all sorts of things to simulate. Here I have chosen a somewhat whimsical example of a hypothetical biological process that has some resemblance to known examples (e.g.¬†male lizards that have three mating strategies, each of which is better than one of the others). We‚Äôll use this to explore the steps involved in building a simulation.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Build a Simulation"
    ]
  },
  {
    "objectID": "BuildSimulation.html#rockpaperscissors-on-a-landscape",
    "href": "BuildSimulation.html#rockpaperscissors-on-a-landscape",
    "title": "Build a Simulation",
    "section": "Rock‚Äîpaper‚Äîscissors on a landscape",
    "text": "Rock‚Äîpaper‚Äîscissors on a landscape\nOur task: Imagine a population of individuals spread out on a landscape. Individuals come in three possible behavioural morphs, with each having one strategy. We‚Äôll call these rock, paper, and scissors, via analogy to the popular game. Individuals move randomly on the landscape. When they encounter each other, they compete in such a way where:\n\npaper defeats rock\nscissors defeats paper\nrock defeats scissors\n\nThe losing individual disappears, and the winning individual reproduces, causing one more individual to appear of the same winning type.\nOur goal is to write a program that will carry out the simulation and allow us to see the dynamics that these simple rules produce on the landscape.\n\nFirst step: consider data structures and the high-level logic of our program\nThere are many ways to solve any particular programming problem. Our goal is to come up with something that is reasonably efficient and easily understood by others reading our code (and ourselves in the future ;). Let‚Äôs first think of how to convert the language given by our task above into more precise concepts that we can specify in code.\n‚Äúlandscape‚Äù: We could conceptualize this as a square of space (bounded by 0 and 1), with locations given by an x value and a y value (both floating-point numbers).\n‚Äúpopulation of individuals‚Äù: We could view this as a list or vector, with the first element representing the first individual, the second representing the second, and so forth. Different vectors could represent different aspects of these individuals (one vector for the x values, one for the y values, etc.).\n‚Äústrategies‚Äù: We can encode these as single letters (i.e.¬†Chars), with the strategies for the whole population being a vector of these.\n‚Äúmove randomly on the landscape‚Äù: We can move individuals by adding a random number drawn from a normal distribution (with the standard deviation specified in a way that keeps movements small).\n‚Äúencounter each other‚Äù: This is vague as stated, and there are many ways we could make this more concrete. One way is to pick a random individual that will interact, and then determine the closest individual to that first one. These two then compete.\n‚Äúcompete‚Äù: The strategies of the two individuals will be compared, and the winner determined by the rules above. Then, we need to replace the losing individual with a new individual with the strategy of the winner. (We realize though that in terms of the coding, this is the same as just changing the strategy of the losing individual. We will make use of this as it means we don‚Äôt have to eliminate cells from our data structure, only change them.)\n‚Äúsee the dynamics‚Äù: This implies we want to watch the simulation play out over a long period of time. So we need to use a loop to run the steps for many many iterations. We also need to show the results visually. We could either watch the simulation in real time or produce a movie by saving frames and then assembling them (fortunately, this is easy as we‚Äôll see below).\n\n\nNow, build the program in steps, using functions for organization\nAfter we‚Äôve spent some time (see above) thinking about how we will conceptualize our simulation in terms of data structures and tasks, we are ready to start writing code.\nWhen I started programming, I tended to write long complex programs as a single long script that does everything. I‚Äôve gradually learned that organizing programs into functions, each of which does one clear task, leads to many benefits (e.g., good logic, undertandability of code, and efficiency). In Julia, this is especially true.\nSo, let‚Äôs start writing!\n\nSet up a landscape with randomly-placed individuals, each playing one of the three strategies.\n\nN = 5000  # the number of individuals in the simulation\nx_locations = rand(N)\ny_locations = rand(N)\nstrategies = rand(['R', 'S', 'P'], N)\n\n5000-element Vector{Char}:\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n 'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n ‚ãÆ\n 'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n 'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n 'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n 'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n 'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n\n\nThe above created 3 vectors, each of length N. These three store the three pieces of info for the individuals in our simulation (x location, y location, and strategy).\n\n\nSet up a visualization of the population\nWe envision a 2-dimensional plot representing the geographic range, with dots representing individuals at their locations. We can use 3 colors to represent the three strategies. Let‚Äôs define the color key:\n\nplot_colors = Dict('R'=&gt;\"red\", 'P'=&gt;\"green2\", 'S'=&gt;\"blue\") \n\nDict{Char, String} with 3 entries:\n  'P' =&gt; \"green2\"\n  'R' =&gt; \"red\"\n  'S' =&gt; \"blue\"\n\n\nHere we used an object we might not have encountered before‚Äîa Dictionary or Dict‚Äîwhich contains key-value pairs. You can think of a Dict as a lookup table. For example we can lookup the color that we have designated for the paper strategy P like this:\n\nplot_colors['P'] \n\n\"green2\"\n\n\nNow let‚Äôs write a function to plot the population:\n\nusing Plots\nfunction show_sim(x_locations, y_locations, strategies, plot_colors)\n    sim_plot = scatter([], [])  # starts an empty plot\n    for i in unique(strategies)\n        selection = (strategies.==i)\n        scatter!(x_locations[selection], y_locations[selection]; markercolor=plot_colors[i], markersize=2, markerstrokewidth = 0, markerstrokealpha = 0, markershape = :circle, legend=false)\n    end\n    sim_plot  # shows the plot\nend\n\nshow_sim (generic function with 1 method)\n\n\nThe above simply defined our plot-showing function. Now let‚Äôs call it to show the initial state of our simulated population:\n\nplot1 = show_sim(x_locations, y_locations, strategies, plot_colors)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can see that we have succeeded in setting up a population of individuals with random locations and strategies. Hooray!\nWe now have to write some code to make individuals interact:\n\n\nWrite a function competing pairs of individuals, and determining the winner\nIDEA: MAKE THIS A CALLOUT BOX? HAVE THEM WRITE THE CODE BELOW?\n\nfunction roshambo(s1, s2)  # where s1 and s2 are strategies of individuals 1 and 2\n    if ((s1 == 'R') && (s2 == 'P')) ||\n        ((s1 == 'P') && (s2 == 'S')) ||\n        ((s1 == 'S') && (s2 == 'R'))\n        winner = 2  # s2 wins \n    elseif ((s1 == 'P') && (s2 == 'R')) ||\n        ((s1 == 'R') && (s2 == 'S')) ||\n        ((s1 == 'S') && (s2 == 'P'))\n        winner = 1  # s1 wins\n    else\n        winner = 0  # no winner (because same strategy) \n    end\n    return winner\nend \n\nroshambo (generic function with 1 method)\n\n\nTest the function above:\n\nroshambo('S', 'R')\n\n2\n\n\nWe now have a short expression that tells us which individual wins. This is an example of abstraction (a key concept in computer science).\nNow let‚Äôs build code that chooses a random individual and the individual closest to it (so that we can then compete them).\n\n\nWrite function to get the closest individual to a given individual\n\nfunction find_closest(x_locations, y_locations, ind)\n    x_focal = x_locations[ind] \n    y_focal = y_locations[ind]\n    dists = sqrt.((x_locations .- x_focal).^2 .+ (y_locations .- y_focal).^2)\n    dists[ind] = 1000  # set this individual's distance to itself very high,\n                       # so it is not chosen in the next line as closest\n    findmin(dists)[2]  # gets index for the minimum value \nend\n\nfind_closest (generic function with 1 method)\n\n\nAbove, we have developed functions for choosing the closest individual (to a given individual) and for determining the winner when those two individuals interact. We also need to build a way to move individuals on the landscape:\n\n\nWrite function to disperse an individual:\n\nsigma_disp = 0.005\nfunction disperse_ind!(x_locations, y_locations, ind, sigma_disp)\n    new_x = -9.9 # initialize with arbitrary wrong value\n    new_y = -9.9 \n    while true  # keep looping to try new locations, until in range (then break out of loop)\n        new_x = x_locations[ind] + (sigma_disp * randn())\n        new_y = y_locations[ind] + (sigma_disp * randn())\n        # check if new location is within the range\n        if (0 &lt; new_x &lt; 1) && (0 &lt; new_y &lt; 1)\n            break  # in range, so break out of loop\n        end\n    end\n    x_locations[ind] = new_x  # assign new location to individual in population\n    y_locations[ind] = new_y\nend\n\ndisperse_ind! (generic function with 1 method)\n\n\nWe include the ! symbol as part of the name of the disperse_ind!() function, to convey that the function modifies some of the input objects.\n\n\nPut the parts together, into one function that runs the whole simulation\n\nfunction run_sim!(iterations)\n    for i in 1:iterations\n        rand_ind = rand(1:length(x_locations))  #choose the index of a random individual\n        closest_ind = find_closest(x_locations, y_locations, rand_ind)\n        winner = roshambo(strategies[rand_ind], strategies[closest_ind])\n        # replace loser with winning strategy\n        if winner == 1 \n            strategies[closest_ind] = strategies[rand_ind]\n        elseif winner == 2\n            strategies[rand_ind] = strategies[closest_ind]  \n        end\n        # move these individuals a bit, but with boundary of 0 and 1\n        disperse_ind!(x_locations, y_locations, rand_ind, sigma_disp)\n        disperse_ind!(x_locations, y_locations, closest_ind, sigma_disp)\n    end\n    show_sim(x_locations, y_locations, strategies, plot_colors)\nend\n\nrun_sim! (generic function with 1 method)\n\n\nThe above function runs the simulation for a given number of iterations, modifying the population vectors as it goes. At the end it returns a plot of the state of the simulation.\nLet‚Äôs test the function above:\n\nrun_sim!(5)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThat shows us the result of the simulation after a given number of iterations. But we want to see the dynamics. Let‚Äôs make a movie!\n\n\nMake a movie of the simulation\nThe Plots package, which we have already loaded, has a wonderfully simple way of writing code that generates movies:\n\nWe use the @animate macro to initialize an Animation object and store a series of plots that are frames of the animation.\nWe use the gif() function to convert the object to an animated gif.\n\nLet‚Äôs use this by running our simulation for 100 small chunks of time, showing a frame after each chunk:\n\nanim = @animate for i in 1:100\n    plot_frame = run_sim!(5000) \nend\ngif(anim, fps=4)\n\n[ Info: Saved animation to /Users/darrenirwin/Documents/Github_repos_MacBookPro/JuliaProgrammingForBiologists/tmp.gif\n\n\n\n\n\nWe can now see the dynamics of the simulation much more clearly. We see the rock‚Äîpaper‚Äîscissors game on a landscape with limited dispersal leads to waves of each strategy replacing other strategies over time.\n\n\n\nPlay with the above\nI‚Äôve designed this example to provide a basic structure and logic for this sort of ‚Äúindividuals on a landscape‚Äù sort of simulation. You can play around with any element of the above example. For example, you try the following (starting with simple and scaling up to more challenging):\n\nChange the dispersal distance or number of individuals, and see what happens.\nMake the graph fancier, with axis labels and explanation of colors, or adding the number of iterations as text somewhere.\nAdd a fourth strategy with its own rules, and see what happens.\nStore the three population vectors in a single data structure (by using the mutable struct command to make a new type)\nChange the way the population interacts with the edge of the range‚Äìfor instance, what if individuals who move off the right side were to appear on the left side? This would make the range have no limits, but still finite space (the resulting geometry is called a torus‚Äìlike the surface of a donut in 3D space.)\nAdd something new to the simulation‚Äìfor example, what if individuals were to mate when they meet, with offspring inheriting neutral alleles (meaning no selective effects) from both parents? Could you then use this framework to track allele frequencies on the landscape over time?",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Build a Simulation"
    ]
  },
  {
    "objectID": "LoadData&Analyze&Graph.html",
    "href": "LoadData&Analyze&Graph.html",
    "title": "Load & Graph Data",
    "section": "",
    "text": "Here we‚Äôll bring together much of our Julia knowledge to actually analyze a large dataset.\nThe example here will be based on a dataset from this paper:\nMcCallum, Q., K. Askelson, F.F. Fogarty, L. Natola, E. Nikelski, A. Huang, and D. Irwin. 2024. Pronounced differentiation on the Z chromosome and parts of the autosomes in crowned sparrows contrasts with mitochondrial paraphyly: implications for speciation. Journal of Evolutionary Biology, voae004, https://doi.org/10.1093/jeb/voae004\nWe will load in a large dataset of genotypes throughout the genomes of Golden-crowned Sparrows and two forms of White-crowned Sparrows: pugetensis and gambelii. We will then use my own custom-designed Julia package called SNPlots.jl to analyze and graph aspects of this dataset.\nTo work through this example, start with a new Pluto notebook. Give it a name and save it, so your work will be continuously saved. You will need a set of files that I will send you‚Äìthese include one file for the SNPlots.jl package of functions and four data files within a folder called Sparrow_data_McCallumetal2024.\n\nSet the working directory\nFirst, set the working directory to match the folder that I sent you called JuliaPlutoDemoSNPplots :\ncd(\"PATHNAME/JuliaPlutoDemoSNPplots\") # where PATHNAME is appropriate to your computer directory structure\n(The Julia function cd() changes directory.)\nCheck that the working directory is now set correctly, using the pwd() function (print working directory):\npwd()\n\n\nLoad the SNPlots package\nI wrote this set of functions to facilitate the analysis of and graphing of genomic data. The scope is quite modest so far, mainly targeted towards producing certain figures that I wanted in our papers.\nThe SNPlots package is not yet released to the world, so please don‚Äôt spread widely yet. I anticipate releasing it when the first paper is published using figures it produces.\nWe first need to load two packages used by SNPlots:\nusing MultivariateStats # for doing Principal Compponents Analysis\nusing CairoMakie # the plotting package used by SNPlots.jl\nNow load SNPlots:\nbegin\n    include(\"SNPlots.jl\")\n    using .SNPlots\nend\nThis way of loading a package is appropriate when the source file is on your local computer (rather than being a registered Julia package).\nTo confirm that the SNPlots package is loaded, enter this:\nSNPlots.greet_SNPlots()\nYou should receive a greeting. üòÑ\n\n\nSet up the paths and data file names\nbegin\n    genotype_file_name = \"Sparrow_data_McCallumetal2024/SparrowDemo_genotypes.012\"\n    individuals_file_name = genotype_file_name * \".indv\"\n    position_file_name = genotype_file_name * \".pos\"\n    metadataFile = \"Sparrow_data_McCallumetal2024/SparrowDemo.Fst_groups.txt\"\nend\n\nLoad three more packages for importing data\nThese are for storing data as type DataFrame, and reading in delimited files:\nusing DataFrames, CSV, DelimitedFiles\n\n\n\nEnough setup, let‚Äôs load data!\nFirst import metadata about thee samples:\nmetadata = DataFrame(CSV.File(metadataFile))\nAbove, the CSV.file() function interprets the correct delimitation format of the data file, and the DataFrame() function creates a DataFrame object (a wonderful way to store data where columns are variables and rows are individuals).\nNow, Import the list of individuals (row names) of the genotype matrix:\nbegin\n    ind = DataFrame(CSV.File(individuals_file_name; header=[\"ind\"], types=[String]))\n    indNum = size(ind, 1) # number of individuals\nend\nCheck that the metadata file and .indv file have same number of individuals:\nif nrow(metadata) != indNum\n    println(\"WARNING: number of rows in metadata file different than number of individuals in .indv file\")\nelse println(\"Good news: number of rows in metadata file matches the number of individuals in .indv file\")\nend\nCombine individual names and metadata into one data structure (enabling confirmation that names match and are in correct order):\nind_with_metadata = hcat(ind, metadata)\nLoad SNP positions:\npos_whole_genome = DataFrame(CSV.File(position_file_name; header=[\"chrom\", \"position\"], types=[String, Int]))\nLoad the genotype matrix:\nbegin # read in genotype data \n    @time geno = readdlm(genotype_file_name, '\\t', Int16, '\\n')\n    loci_count = size(geno, 2) - 1   # because the first column is not a SNP (just a count from zero)\n    print(string(\"Read in genotypic data at \", loci_count,\" loci for \", indNum, \" individuals. \\n\"))\n    genosOnly = geno[:, Not(1)] #remove first column, which was just a row index\nend\nIn the data matrix, rows represent individuals and columns represent SNPs, and genotypes are as follows:\n0: homozygous reference; 1: heterozygous; 2: homozygous alternate; -1: missing genotype\n\n[If you want to filter individuals or SNPs with too much missing data, I have scripts that can be added here]\n\n\nChoose our groups to plot, and their colours\ngroups_to_plot = [\"GCSP\",\"PSWS\",\"GWCS\"]\ngroup_colors = [\"gold\",\"red\",\"blue\"]\n\n\nTo do a PCA, we first need to impute missing genotypes\nPrepare data matrix to be ready for imputation, by replacing -1 with missing data type:\nbegin\n    genosOnly_with_missing = Matrix{Union{Missing, Int16}}(genosOnly)\n    genosOnly_with_missing[genosOnly_with_missing .== -1] .= missing;\n    genosOnly_with_missing = Matrix{Union{Missing, Float32}}(genosOnly_with_missing) \nend\nLoad Impute package:\nusing Impute\nNow actually impute the missing genotype values:\n@time imputed_genos = Impute.svd(genosOnly_with_missing)\n\n\n\nLet‚Äôs make the PCA plot!\nbegin\nPCAmodel = SNPlots.plotPCA(imputed_genos, ind_with_metadata,\n        groups_to_plot, group_colors;\n        sampleSet=\"Zonotrichia sparrows\", regionText=\"whole_genome\",\n        flip1=false, flip2=false, showPlot=true)\nPCAmodel.PCAfig\nend\nGold symbols represent Golden-crowned Sparrows. Blue represent the gambelii form of White-crowned Sparrows. Red represent that the pugetensis form of White-crowned Sparrows.\n\n\nNow let‚Äôs produce a genotype-by-individual plot\nSome initial setup of parameters for the plot:\nbegin \n    group1 = \"GCSP\"   # the alleles most common in this  group will be assigned the same color in the graph\n    groupsToCompare = \"GCSP_PSWS\" # The groups to compare for the Fst filter below\n    Fst_cutoff =  0.8\n    missingFractionAllowed = 0.2\nend\nCalculate allele frequencies and sample sizes per group:\nfreqs, sampleSizes = SNPlots.getFreqsAndSampleSizes(genosOnly_with_missing,\n                            ind_with_metadata.Fst_group, groups_to_plot)\nCalculate Fst (allele frequency differentiation) between pairs of groups:\nFst, FstNumerator, FstDenominator, pairwiseNamesFst = SNPlots.getFst(freqs,\n                                            sampleSizes, groups_to_plot)\nChoose the chromosome to plot:\nbegin\n    chr = \"CM018231.2\" # the name of a scaffold in the assembly\n    regionInfo = SNPlots.chooseChrRegion(pos_whole_genome, chr) #; positionMin=1) # this gets the maximum position for the chromosome\nend\n\nOK, let‚Äôs make the plot!\nbegin\n    plotInfo = SNPlots.plotGenotypeByIndividual(groupsToCompare, Fst_cutoff,\n        missingFractionAllowed, regionInfo, pos_whole_genome, Fst, pairwiseNamesFst, \n        genosOnly_with_missing, ind_with_metadata, freqs, \n        groups_to_plot, group_colors)\n    plotInfo[1] # this outputs the plot above\nend\nThe figure shows the genotypes of individuals at SNPs that have Fst higher than Fst_cutoff in the groups being compared (given by groupsToCompare). The two alleles have different shades of purple, with triangles indicating heterozygotes. The bottom of the plot indicates the location of SNPs on the chromosome, and the blue shading indicates SNP density across the chromosome.\nIf the function works on your computer like it does on mine, it will create a separate plot window and show the figure both there and in your Pluto notebook.\n\n\n\n\n\n\nProduce such plots for a series of chromosomes\n\n\n\nCan you write a loop to cycle through a number of different chromosomes and make a plot for each? You would use a lot of the code in the previous two cells above. You could do this for these scaffolds, expressed here a a vector of strings: [\"CM018230.2\", \"CM018231.2\", \"CM018232.2\", \"CM018233.2\", \"CM018234.2\"]\n\n\n\n\n\nA take-home message:\nThe SNPlots.plotGenotypeByIndividual() function produces this complex plot from the repeated use of low-level plotting functions to simply draw lines, filled shapes, and text in the plotting window. If you learn the commands to draw such simple elements and the logic by which to determine where to draw them, you can design your own functions to make all sorts of complex figures.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Load & Graph Data"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site:\nI am a Professor of Zoology at the University of British Columbia. To learn more about my research, go to: https://www.zoology.ubc.ca/~irwin/irwinlab/\nDisclaimer: I am mostly self-taught in the area of computer science and programming, so will likely find better sources to learn about those topics. My goal here is to help other biologists learn to start programming. I have chosen the Julia language because of its easy entry, its speed and memory efficiency, and because it has been hugely useful in my own research.\nThanks: I have benefitted greatly from many excellent courses available from organizations such as Compute Canada, the Digital Alliance of Canada, and UBC Advanced Research Computing. I also thank the many YouTubers, bloggers, and book authors who provide excellent information about Julia and other languages. And of course I thank the inventors of Julia (you can learn more at https://en.wikipedia.org/wiki/Julia_(programming_language)).\nThis whole website was generated using Quarto, which allows embedding of runnable Julia code.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.",
    "crumbs": [
      "Home",
      "Basics",
      "About"
    ]
  },
  {
    "objectID": "Plots.html",
    "href": "Plots.html",
    "title": "Plots",
    "section": "",
    "text": "Plotting is a huge topic. Here I‚Äôll do my best to give you an efficient introduction to key concepts and commands, equipping you with the tools to build plots of arbitrary complexity. My emphasis here is on ‚Äòlow-level‚Äô commands (e.g.¬†draw a point, draw a line), rather than ‚Äòhigh-level‚Äô commands (e.g.¬†make a polished fancy plot in a single command). I emphasize the former because it will give you the confidence and power to develop plots to do whatever you want, and it is easy to learn the high-level commands later.\nThere are a number of different plotting packages in Julia, many of them excellent in different ways. Here we will use the ‚ÄòPlots‚Äô package because it is perhaps simplest to work with and is most integrated (or composable) with other packages in the Julia ecosystem. (After some experience with this package, a lot of your knowledge will be transferable to other packages.)\n\nAdd the Plots package\nIf you haven‚Äôt already done so (perhaps you did this several pages prior), install the Plots package as follows:\nIf using the REPL, type ] to activate the Package mode, then enter add Plots . Then press the delete key to return to the REPL, and enter using Plots.\nIf using Pluto, simply type add Plots in a code cell and then shift-enter to execute the cell.\nThese steps might take quite a bit of time because the package and its dependencies are big.\n\n\nMake a simple plot\nWe‚Äôll make a simple plot and learn some of the functions involved.\n\nDraw some lines\nLet‚Äôs define some x values and y values of points, and then plot them by connecting those points with lines:\n\nusing Plots\nxValues = [1.5, 1.8, 2.3, 2.7, 3.2, 3.5]\nyValues = [2.8, 2.5, 2.3, 2.3, 2.5, 2.8]\nplot(xValues, yValues, linewidth=3)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSo we drew some lines between the points defined those coordinates.\n\n\nDraw some points\nNow, let‚Äôs say we want to add some points to the same plot. We can use scatter!() :\n\nscatter!([2.1, 2.9], [3.5, 3.5])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe ! in the scatter!() function is used to indicate that this function will change the existing plot (rather than make a new plot).\n\n\nDraw a shape\nNow, let‚Äôs add a filled shape to the same plot:\n\nplot!(Shape([2.4, 2.5, 2.6], [2.9, 3.1, 2.9]))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere, we created a Shape object and fed that as an argument to the plot!() function.\nAs the plot was updated, you can see that the Plots package adjusted the limits of the x and y axes to fit the plotted points. We can control that ourselves:\n\nplot!(xlim = [1, 4], ylim = [2, 4])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou can change just about anything in the plot\nWe can adjust all sorts of other things about the plot. For instance, add axis labels and a title, and remove the legend:\n\np1 = plot!(title = \"A happy plot\",\n    xlabel = \"My x axis\",\n    ylabel = \"My y axis\",\n    legend = false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo find out more about attributes of plots and how to change them, type ??plot in the Julia REPL (the first ? will activate the help mode, and then enter ?plot).\nIn the last code block above, we both generate a plot and assign it to the name p1, which gives us a way to invoke it later (you‚Äôll see why further below).\n\n\n\nShow mathematical functions\nAbove, we fed the plot function a set of x and y values. We can also feed it a function, and it will do its best to provide a reasonable plot of the function:\n\nplot(sin)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can add some more functions to the plot:\n\nplot!(x -&gt; 3cos(x))\np2 = plot!(x -&gt; (x^2 - 5))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the above, the arguments given to plot!() are anonymous functions. This means they are not given names and are not stored in memory. Rather, the syntax x -&gt; f(x) simply provides a mapping of x onto y values, and the plot!() function interprets that and shows us a part of the relationship.\n\nAdd text to the plot\nWe can use the annotate!() function to add text to our plot, at the desired coordinates:\n\nannotate!(-3, 10, \"Here's some text\", :left)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis adds text at location -3, 10 and the :left indicates that it should be left-aligned to that location.\n\n\nParametric plots\nAnother way we can invoke a plot is to provide it two functions, both of which depend on a variable that ranges from a minimum value to a maximum value. We call the function in this format: plot(x_function, y_function, minimum, maximum) :\n\nplot(sin, cos, 0, 2pi)\nplot!(aspect_ratio = :equal)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot(x -&gt; x*sin(x), x -&gt; x*cos(x), 0, 2pi)\np3 = plot!(aspect_ratio = :equal, legend=false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3D plots\nWe can expand from the above to 3 dimensions:\n\ntime = 0:0.1:20\nxvals = sin.(time)\nyvals = cos.(time) \nzvals = time\np4 = plot(xvals, yvals, zvals)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSurface plots\nThis is one kind of 3D plot, where we have a value for z at every value of x and y:\n\nxes = -1:0.01:1\np5 = surface(xes, xes, (x, y) -&gt; x^2 + y^2, legend=false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere, the first argument is the x values, the second is the y values, and the third is the z values, which in this case we provided as an anonymous function relating x and y to z.\n\n\nHeatmaps\nWe can show the above as a heatmap:\n\np6 = heatmap(xes, xes, (x, y) -&gt; x^2 + y^2)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere are many other kinds of plotting commands. Keep in mind though that if it is difficult to find a high-level command to do exactly what you want, the low-level commands for plotting points, lines, and shapes along with some good logical thinking will result in anything you can imagine!\n\n\n\nLayouts\nWe can combine separate plots into one figure quite simply. We first define each plot and assign it a name, resulting in it being stored as an object in memory. Then, we assemble these into a figure.\nAbove, we defined a series of plots and gave them the names p1 through p5. We‚Äôll now call the `plot() function in a way that causes some of these to be plotted as panels in one graphing window:\n\nplot(p1, p2, p4, p5)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBecause we have provided four plots to be shown, the default assumption is that we want a 2x2 grid. We can alter this by using the layout keyword and grid() functions:\n\nplot(p1, p3, p6, layout = (1, 3))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTry switching the 3 and 1 to see what you get.\n\nplot(p3, p4, p6, p5, layout = grid(2, 2, heights=[0.4, 0.6], widths=[0.3, 0.7]))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe @layout macro\nEarlier, we learned about how the @ symbol is used to indicate a macro, something that is a tool to write non-standard code that is then re-written by the macro into actual Julia code. You can think of it as a convenient shortcut. The @layout macro is a wonderful example:\n\nplot(p1, p2, p3, p4, p5, p6, \n    layout = @layout [ s s s\n                        s s\n                         s])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAfter the @layout, we simply write brackets within which is a visual representation of the layout of the plot. The s symbol here is arbitrary‚Äìyou can use whichever letter you want‚Äìthe key thing is that the pattern of white space and line breaks between the symbols conveys to the macro what the layout arrangement should be.\nIf we want our sub-plots to take up differing amounts of space, we can add that in this way:\n\nbigPlot = plot(p4, p5, p1, p2, p3, p6, \n                layout = @layout [ s s s\n                                s{0.8w} s\n                                s{0.2h}])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe {0.8w} and {0.2h} mean that that subplot should take up 0.8 proportion of the width or 0.2 proportion of the height.\n\n\n\nSave your plot\nWe can now save the plot, and give a path/filename that ends by designating the format (e.g.¬†pdf, png, jpg):\nsavefig(bigPlot, \"myplot.pdf\")\n\n\nNext steps\nThis has been a quick intro to plotting, but I hope it gives a good idea of the rich capability of the Plots package and how to get started producing your own plots in Julia.\nNow let‚Äôs jump into a full data analysis. We‚Äôll learn how to import data into Julia, do a bunch of processing and calculations, and graph results.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Plots"
    ]
  },
  {
    "objectID": "ControlFlow.html",
    "href": "ControlFlow.html",
    "title": "Control Flow: Loops and Ifs",
    "section": "",
    "text": "So far, what we have learned might be called coding, the way your write commands that do a fixed set of instructions. To do true programming we need to know how to write scripts in which the exact sequence of commands is determined dynamically. This is called control flow.\n\nLoops: for and while\nLoops are very useful in programming, because we often want to do a set of commands multiple times. For example:\n\nfor ice in 1:10\n  iceCubed = ice^3\n  println(\"The cube of \", ice, \" is \", iceCubed)\nend\n\nThe cube of 1 is 1\nThe cube of 2 is 8\nThe cube of 3 is 27\nThe cube of 4 is 64\nThe cube of 5 is 125\nThe cube of 6 is 216\nThe cube of 7 is 343\nThe cube of 8 is 512\nThe cube of 9 is 729\nThe cube of 10 is 1000\n\n\nHere we‚Äôll use a random integer to determine how many times to do a loop:\n\nrand_times = rand(1:10)  # This returns a random integer in the range 1 to 10\nfor i in 1:rand_times\n  println(i)\nend\nprintln(\"I counted to $rand_times\")\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nI counted to 10\n\n\nNote that the $ in the last line above causes string interpolation of the expression to the right of it.\n\n\n\n\n\n\nTeach Julia to Sing\n\n\n\nWrite a script that produces the song ‚Äú99 bottles of beer on the wall.‚Äù This song goes like ‚Äú99 bottles of beer on the wall, 99 bottle of beer, you take one down and pass it around, 98 bottles of beer on the wall; 98 bottles of beer on the wall, 98 bottles of ‚Ä¶‚Äù and so forth that all the way down. (I don‚Äôt think anyone has ever completed the song . . . Can your program succeed in doing so?)\n\n\nAn interesting thing about for loops is that the iterator variable is internal to the loop (not ‚Äúknown‚Äù outside of the loop):\n\ni = 27\nprintln(\"Before the loop, i = $i\")\nfor i in 1:3\n  println(\"Inside the loop, i = $i\")\nend\nprintln(\"After the loop, i = $i\")\n\nBefore the loop, i = 27\nInside the loop, i = 1\nInside the loop, i = 2\nInside the loop, i = 3\nAfter the loop, i = 27\n\n\n\nfor loops can iterate across many kinds of collections\nYou can iterate across all sorts of things, for example a matrix of strings:\n\nspeciesGrid = [\"warblers\" \"flamebacks\" \"sticklebacks\"; \n              \"sparrows\"  \"guppies\" \"digital organisms\"] \nfor i in speciesGrid\n  println(\"We study $i.\")\nend\n\nWe study warblers.\nWe study sparrows.\nWe study flamebacks.\nWe study guppies.\nWe study sticklebacks.\nWe study digital organisms.\n\n\nInstead of the in in the for line, you can use the unicode character ‚àà (produced by typing \\in tab), which is a mathematical symbol meaning ‚Äúis an element of‚Äù. :\n\nmySet = [\"banana\", 5.3, 'üê¨']  # get the dolphin with \\:dolphin: tab\nfor thing ‚àà mySet\n  println(thing)\nend\n\nbanana\n5.3\nüê¨\n\n\n\n\nNested loops\nOften it is useful to have nested loops. For instance, to produce all dinucleotide combinations:\n\nbases = ['A', 'C', 'G', 'T']\nfor i in bases\n  for j in bases\n    print(i, j, \", \")\n  end\nend\n\nAA, AC, AG, AT, CA, CC, CG, CT, GA, GC, GG, GT, TA, TC, TG, TT, \n\n\nYou can produce the above more concisely by putting both iterator statements on the same line:\n\nbases = ['A', 'C', 'G', 'T']\nfor i in bases, j in bases\n  print(i, j, \", \")\nend \n\nAA, AC, AG, AT, CA, CC, CG, CT, GA, GC, GG, GT, TA, TC, TG, TT, \n\n\n\n\n\n\n\n\nProduce all trinucleotides\n\n\n\nCan you modify the above to produce all possible trinucleotides (i.e., 3-base nucleotides)?\n\n\n\n\nwhile loops\nLet‚Äôs say you don‚Äôt know in advance how many times you want to go through a loop. Rather, you want to stop the loop when some condition is met. The while loop is perfect for that:\n\nsum = 0\nwhile sum &lt;= 21  # inspired by a card game\n  sum = sum + rand(1:10)\n  println(sum)\nend\n\n10\n12\n16\n23\n\n\n\n\n\n\n\n\nSimulate dispersal of an organism\n\n\n\nYou are writing a simulation in which individuals move from their birth site to their breeding site, along a continuous range of length 1. The dispersal distance is drawn from a standard normal distribution, given by randn(), with the constraint that they are not allowed to move outside of the range. If an individual is born at location 0.7, write a script that determines its breeding location within the range (lowest possible value = 0; highest possible value = 1).\n\n\n\n\n\nCompound expressions\nA compound expression is a single large expression that is made up of multiple sub-expressions that are evaluated in order. When the compoud expression is evaluated, only the value generated by the last sub-expression is returned. There are basically two ways to generate compound expressions:\n\nUse a semicolon (;) chain\n\nx = 4; y = 3; x + y\n\n7\n\n\nThe above returns the value of the last subexpression, but it does remember values assigned in the earlier subexpressions. (To prove this to yourself, enter x to see its value.)\nYou can use compound expressions as part of even larger expressions, e.g.:\n\nmyVar = (x = 4; y = 3; x + y)\n\n7\n\n\nThere, the compound expression in parentheses is evaluated and the resulting value is assigned to myVar.\n\n\nUse a begin block\nThe above compound expression is equivalent to the one below:\n\nmyVar2 = begin x = 4; y = 3; x + y end\n\n7\n\n\nThe use of begin blocks is particularly useful when dividing expressions between multiple lines:\n\nbegin\n  string1 = \"Phylloscopus\"\n  string2 = \"trochiloides\"\n  string1 * \" \" * string2\nend\n\n\"Phylloscopus trochiloides\"\n\n\n\n\n\nConditional evaluation: if and ? :\nOften in our programs we want to execute some commands only if a condition is met. For this, we can use an if - elseif - else block:\n\ncoinflip = rand([\"heads\", \"tails\"])\nif coinflip == \"heads\"\n  println(\"Heads--You win!\")\nelseif coinflip == \"tails\"\n  println(\"Tails--You lose :(\")\nelse \n  println(\"The coin has a strange value\")\nend\n\nHeads--You win!\n\n\nIn an if block, the elseif and else parts are optional, but the end is essential. The indentation is customary and makes the code easier to read, but is not required. The value of the conditional expressions (e.g., just to the right of if) must be of type Bool, meaning either true or false.\n\n\n\n\n\n\nDetermine homozygote or heterozygote\n\n\n\nWrite a script in which you assign a diploid genotype to a variable, with the genotype encoded as a 2-element vector containing strings (e.g., [\"A\", \"C\"] or [\"A\", \"A\"]), and then the script tells you whether the genotype is homozygous (the two elements are the same) or heterozygous (the two elements are different). (Hint: Remember how to access one element of a vector, e.g.¬†x[1] gives just the first element of x; Remember how to ask if two things are equal: ==)\n\n\nIn Julia, if blocks return a value. You can make use if that to do something like this:\n\nhomozygote = true\ngenotype = if homozygote\n             \"TT\"\n           else\n             \"TG\"\n           end\n\n\"TT\"\n\n\n\nTernary operators\nThe ternary operator, consisting of a ? and : separating three expressions (hence ‚Äúternary‚Äù), can be thought of as a consise form of an if - else block. For instance, this is equivalent to the above:\n\nhomozygote ? \"TT\" : \"TG\"\n\n\"TT\"\n\n\nThis can be thought of as ‚ÄúTrue or false‚Äù ? ‚ÄúDo this if true‚Äù : ‚ÄúDo this if false‚Äù\n\n\n\n\n\n\nDetermine whether a number is positive or negative\n\n\n\nAssign a non-zero number to a variable, and then use a ternary operater to report whether the number is positive or negative.\n\n\n\n\n\nShort-circuit evaluation\nAnother way of constructing conditional evaluations is to use the && and || operators (which mean logical ‚Äúand‚Äù and logical ‚Äúor‚Äù). These operators come between two sub-expressions which are evaluated in order from left to right. Julia is efficient and only evaluates the rightmost sub-expression if it needs to (this is why it is called short-circuit evaluation: the evaluation doesn‚Äôt always extend to the right sub-expression). Hence:\n\nIn a && b, b is evaluated only if a is true (because otherwise the whole statement is definitely false)\nIn a || b, b is evaluated only if a is false (because otherwise the whole statement is definitely true)\n\nThe interesting thing is that the b subexpression does not have to produce true or false. Rather, it can do anything you want, and is only executed depending on whether a is true. For example:\n\nx = 5\nx &gt; 0 && println(\"x is positive\")\n\nx is positive\n\n\nTry changing x above to a negative value and run the above again.\nI think of the above construction as ‚ÄúCheck if true AND (only if true) do this thing.‚Äù\n\ny = 3.2\ny &lt;= 0 || println(\"x is positive\")\n\nx is positive\n\n\nAgain, try changing the value of y to a negative value and run again.\nI think of the above as ‚ÄúCheck if true OR (only if not true) do this thing.‚Äù\nThe above expressions may take a while to get used to. You don‚Äôt have to use them, as you might find the if block a lot more intuitive. But you may see these expressions in code that others have written, so it is good to understand them.\n\n\nNext steps\nNow that we have have developed an understanding of loops and conditional evaluation, we are ready to learn more about functions, types, and multiple dispatch in Julia. Together, these concepts can be thought of as methods of control flow. They enable powerful and fascinating approaches to programming.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Control Flow: Loops and Ifs"
    ]
  },
  {
    "objectID": "Numbers.html",
    "href": "Numbers.html",
    "title": "A Bit about Numbers",
    "section": "",
    "text": "We have now learned some about how Julia remembers numbers as belonging to different types. Why is this? Isn‚Äôt a number just a number? Well, when it comes to storing them in computer, the answer is no. To understand why, let‚Äôs learn a little about how computers store information.\n\nBinary memory\nThe great majority of computers today (and certainly your own personal computer) store information as a series of 1s and 0s. (You can equally well think of these as on/off or true/false.) A single 1/0 switch is called bit‚Äîthe smallest unit of information that a computer can store.\nA set of 8 bits is called a byte. The memory on a computer consists of gigantic grids of such bytes. When we talk about memory sizes of computers, we use terms like kilobytes (KB; 1,000 bytes, or 8,000 bits) or megabytes (MB; 1,000,000 bytes), and so forth.\n\n\nBinary counting\nSo how can numbers other than 0 and 1 be stored? As a series of 0s and 1s, which are interpreted as a group according to some rule. For example, we can simply count in binary to convert our decimal (base-10) numbers to the way computers often store integers:\nDecimal 0 can be stored as binary 0.\nDecimal 1 can be stored as binary 1.\nDecimal 2 can be stored as binary 10.\nDecimal 3 can be stored as binary 11.\nDecimal 4 can be stored as binary 100.\nDecimal 5 can be stored as binary 101.\n\nAnd so forth. You can see that storing larger integers requires more bits.\nThe take-home message here: For integers, there is a tradeoff between memory size and the range of integers that can be stored.\n\n\nWhat about non-integers?\nThe above works fine for integers, but we often want to store numbers like 7.1 or 0.005 or sqrt(2). For this, people have come up with a clever way of encoding numbers called floating-point numbers, because you can think of it as storing numbers as an integer multiplied by a number that represents the magnitude (which adjusts where the decimal point goes).\nThis floating-point number system works great, but there is a limitation: In a fixed set of bits, there is a limit to the precision of such numbers. In other words, there are only certain values such numbers can take, with gaps between them. The more bits we dedicate to storing such numbers, the smaller these gaps are.\nThe take-home message here: For floating-point numbers, there is a tradeoff between memory size and precision of the numbers stored.\n\n\nNumbers in Julia\nTo learn a bit about how numbers are represented by different Julia types, we can use the bitstring() function:\n\nbitstring(1)\n\n\"0000000000000000000000000000000000000000000000000000000000000001\"\n\n\nThis shows us that the number 1 is stored as 63 0s and then a 1. This is Julia‚Äôs default way of storing integers, as type Int64 (a 64-bit integer).\nLet‚Äôs try the same but use 1.0 instead:\n\nbitstring(1.0)\n\n\"0011111111110000000000000000000000000000000000000000000000000000\"\n\n\nHere we have quite a different representation. This is because the number is now stored as type Float64 (a 64-bit floating-point number).\n\nThe about() function\nWe can learn more about how numbers are encoded by adding a nice little package called About:\nusing Pkg; Pkg.add(\"About\")\nThis package has one function, wisely named about() as it tells us about objects (note though that it can only tell you about relatively simple objects).\n\nusing About\nabout(1)\n\nInt64 (&lt;: Signed &lt;: Integer &lt;: Real &lt;: Number &lt;: Any), occupies 8B.\n\n 0000000000000000000000000000000000000000000000000000000000000001\n = +1\n\n\nThe highlighting tells you how the number is encoded (one bit for the positive sign, the rest for the integer)\n\nabout(1.0)\n\nFloat64 (&lt;: AbstractFloat &lt;: Real &lt;: Number &lt;: Any), occupies 8B.\n\n 0011111111110000000000000000000000000000000000000000000000000000 \n ‚ï®‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n +    2^0   √ó                1.000000000000000000                \n = 1.0000000000000000\n\n\nThe result shows you which bits are for which components of the floating-point number.\n\n\n\n\n\n\nTry about() on other objects\n\n\n\nPlay around with this function to learn about how other types of things are stored. (For example, about('x'), about(\"ACGT\"), about(3//7), about(sqrt(2)), about(pi).)\n\n\n\n\n\nChoosing types wisely\nWhy does all this matter? Well, if you don‚Äôt actually need 64 bits for your numbers, then you can tell Julia to store them in fewer bits, and this can increase efficiency (i.e., reduce memory and increase speed).\nFor example, if you know that a variable will only need to store integers ranging between -128 and 127, then you can specify that variable as an 8-bit integer:\n\nx8 = Int8(39)\n\n39\n\n\n\ntypeof(x8)\n\nInt8\n\n\n\nbitstring(x8)\n\n\"00100111\"\n\n\n\nabout(x8)\n\nInt8 (&lt;: Signed &lt;: Integer &lt;: Real &lt;: Number &lt;: Any), occupies 1B.\n\n 00100111 = +39\n\n\nWe have succeeded in storing the number 39 in only 8 bits rather than 64.\nAs another example, let‚Äôs say we need to store a floating-point number but we don‚Äôt need a lot of precision. Let‚Äôs store it as a 16-bit floating-point number:\n\npi16 = Float16(3.14159)\n\nFloat16(3.14)\n\n\nJulia‚Äôs response indicates the rough level of precision that the number has been stored in (only 3.14). That may not be a wise choice for that one number, but imagine if you had millions of numbers stored in memory‚Äîperhaps that precision is good enough for what you are using them for, and cuts the memory by 75% (compared to Float64).\n\nCheck the capacity of types for your numbers\nIf you are working with integers, you can find the minimum storable integer for a type like this:\n\ntypemin(Int16)\n\n-32768\n\n\nAnd the maximum like this:\n\ntypemax(Int16)\n\n32767\n\n\nHence we know that type Int16 can store integers from -32768 to 32767.\n\n\n\n\n\n\nWeird math\n\n\n\nWhat happens if you take encode the number 32767 encoded as an Int16 and add 10 to it? Try out by entering Int16(32767) + Int16(10). Can you figure out what happened? (Hint: this is called ‚Äúoverflow‚Äù.)\n\n\n\n\n\nBeware of other weird math\nIn addition to overflow (with integers), we want to be aware of the consequences of floating-point imprecision. An example:\n\n0.1 + 0.2 == 0.3   # note the \"==\" makes this a Boolean statement, asking whether this equation is true\n\nfalse\n\n\nThe REPL returns false. What?!?\nThis is a result of the imprecision of floating-point numbers. Let‚Äôs ask what the left side of the equation is evaluated as:\n\n0.1 + 0.2\n\n0.30000000000000004\n\n\nWe see it is slightly different from 3.0. This is because both 0.1 and 0.2 are stored with a bit of imprecision, and their total is actually a smidgin bigger than 3.0.\nWe are now at risk of a deep dive into computer science, but I will pull us back from the brink. The makers of Julia have provided us biologists a solution to the above. Just use the ‚Äúapproximately equal‚Äù symbol: ‚âà (to get this, type \\approx then press the ‚Äútab‚Äù key.)\n\n0.1 + 0.2 ‚âà 0.3   # note the \"‚âà\" is the Boolean operator for approximately equal\n\ntrue\n\n\nThe REPL now says it is a true statement, within the (im)precision of the data type being used.\n(The ‚âà symbol is a short way of calling the isapprox() function‚Äìthose interested can look that up for the gory details.)\nJulia provides another solution to this situation: We can use the Rational type to encode rational numbers precisely, as ratios of integers:\n\n1//10\n\n1//10\n\n\nWe can see that Julia is treating this expression in a different way than 0.1 or 1/10 (which Julia would convert to 0.1). With 1//10, Julia is remembering both the numerator and denominator, storing this as a ratio of integers. We can check the type:\n\ntypeof(1//10)\n\nRational{Int64}\n\n\nNow that the ratios are now stored precisely, let‚Äôs check our Boolean statement:\n\n1//10 + 2//10 == 3//10\n\ntrue\n\n\nPrecise math now works! However, there is a limitation to use of the Rational type: it cannot store irrational numbers like sqrt(3) or œÄ.\n\n\nBigInt and BigFloat\nFor most uses, Int64 and Float64 provide excellent flexibility with numbers. In those rare cases where you need even bigger integers or even more precision on your floats, Julia provides BigInt and BigFloat types. These use as many bits as you need to provide the number of numbers that you want.\nFor example, let‚Äôs start with the largest integer that can be stored as an Int16:\n\nmyLargeNum1 = typemax(Int64)\n\n9223372036854775807\n\n\nIf we add 1 to that, we would have an overflow problem. Instead, let‚Äôs make it a BigInt and add 1:\n\nmyLargeNum2 = BigInt(myLargeNum1) + 1\n\n9223372036854775808\n\n\n\nabout(myLargeNum2)\n\nBigInt (mutable) (&lt;: Signed &lt;: Integer &lt;: Real &lt;: Number &lt;: Any)\n Memory footprint: 16B directly (referencing 32B in total)\n alloc::Int32       4B 00000000000000000000000000000010      2\n  size::Int32       4B 00000000000000000000000000000001      1\n     d::Ptr{UInt64} 8B 00000000000000000 ‚Ä¶ 11110010001010000 Ptr{UInt ‚Ä¶ 5231e450\n\n ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†\n        4B               4B                        8B                \n\n\nThis uses 16 bytes (128 bits), twice as much as our starting number. Its memory footprint can grow even bigger if we need it to.\nThe BigInt type can be useful for storing precise values of things like factorials:\n\nfactorial(BigInt(50))\n\n30414093201713378043612608166064768844377641568960512000000000000\n\n\n\n\nNext steps\nThinking about efficiency of number types will be particularly important when storing large numbers of numbers in Arrays or DataFrames, which we will explore on the next page.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "A Bit about Numbers"
    ]
  },
  {
    "objectID": "UseVSCode.html",
    "href": "UseVSCode.html",
    "title": "Use an Integrated Development Environment (IDE)",
    "section": "",
    "text": "We have now learned two interfaces for coding in Julia: 1) using the REPL; 2) using Pluto). The REPL is good for interactive use, using single commands or short scripts. Pluto is excellent for developing somewhat longer scripts in a stepwise manner, but still not great for really long and comnplex programs. For developing large programming projects, we often will want to use a highly capable text editor (e.g.¬†Emacs, Vim) or an Integrated Development Environment (IDE). (If you‚Äôve used RStudio, then you‚Äôve already used an IDE‚Äìbut it only works with R and Python.)\nVisual Studio Code (or VS Code for short) has become the widely recommended IDE for Julia. VS Code can be used to program in just about any language (e.g.¬†R, Python, C, HTML), so investment of time in learning it can be rewarding whatever languages you may use in the future. VS Code is highly customizable through the loading of extensions, and there are excellent and easily loaded extensions that facilitate programming in Julia using VS Code.\nOne hesitation I have in introducing VS Code is that because it is a highly capable and customizable IDE, it looks visually complex and can have a somewhat steep learning curve. For this reason, if you are enjoying the simplicity of using Julia just via the REPL and/or Pluto, then it might be wise to stick to those until you build up more experience, and then try VS Code.\n\nInstall VS Code with the Julia extension\nTo install VS Code, follow the instructions under the ‚ÄúGetting Started‚Äù heading on this web page: https://code.visualstudio.com/docs/languages/julia (Note that you already have Julia installed, so you can skip that step.) I will repeat the key steps here too:\n\nInstall VS Code for your computer here: https://code.visualstudio.com/download.\nStart VS Code, and in the top menu bar choose View-&gt;Extensions, then type in Julia in the ‚ÄúSearch Extensions‚Äù box, then select the Julia extension and click its install button.\n\n\n\nStart a Julia script file\nTo stay organized, first choose File-&gt;Open Folder, and click the New Folder button at the lower left, and name a new folder something creative like ‚ÄúMyFirstJuliaVSCodeFolder‚Äù.\nThen open a new file in the folder‚Äìthere are many ways to do this‚Äìone of these is to click on the Explorer symbol (looks like some pages of paper) at upper left, then to the right of your folder name, click on the symbol that looks like a page with a plus sign. This is the New File command. A blank space for a file name will appear, and then choose a name ending in .jl. For example, myFirstJuliaFile.jl. The last .jl part is crucial, as it tells VS Code that this file is in the Julia language.\nAfter you press return, a window to the right opens with the name of your file at the top. This window is a text editor showing the contents of your file. It is empty at the start, so put something in there! For example, this is what I typed there:\n# This is a Julia file created in VS Code\n# by Darren Irwin\n# 6 October 2024\n\nmyText = \"I can count to \"\n\nrepeats = 3\n\nfor i in 1:repeats\nprintln(myText * string(i))\nend\n\n\nRun your script\nOnce you are happy with what is there, you save (File-&gt;Save) and then run the file by clicking the right-pointing triangle at upper right of the text window. This will open a REPL window (probably at bottom of your screen), run the code in the REPL, and output the results there.\n\n\nInteract with the REPL\nAnother way to interact with the REPL is to cut-and-paste code from your script into the REPL, running individual commands as you go. In this way, you can test out commands in the REPL, and when you know they work as intended you can include them in your growing script.\n\n\nInclude a plot\nLet‚Äôs see how VS Code displays plots. Add this to your Julia file (the one you made above) and then run the file again:\nusing Plots\nf(x) = x^2 - 3\nplot(f)\nIf your computer works like mine, you see a panel to the right that shows the plot. (The plot shows an upward-opening parabola.)\n\n\nExplore VS Code\nVS Code has far more features and complexities than I can summarize here. One key to using it is to learn just enough to do what you need to do, and don‚Äôt worry about the rest. Here are a couple helpful things to note at this point:\n\nAfter you run some Julia code and have a REPL open, you should see three little circles somewhere on the left side of the screen. This is a Julia symbol. If you click on this, you will see a list of the objects in Julia‚Äôs active memory‚Äìwhich can be very useful for seeing what your code has produced. (If you‚Äôve run the above code first, you will see objects such as myText and repeats and their values.)\nAn important tool in VS Code is the Command Palette. You can find this by clicking on the symbol that looks like a gear, in the lower left of the VS Code window, and choosing Command Palette in the popup window. Then a search bar opens at the top of the page, and you can type text related to the command you are looking for‚Äìfor example, try save and then choose File: Save to save the current file you are working on.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Use an Integrated Development Environment (IDE)"
    ]
  },
  {
    "objectID": "Randomization.html",
    "href": "Randomization.html",
    "title": "Randomization in Simulation and Statistics",
    "section": "",
    "text": "The concept of random events is central to our understanding of many biological processes (e.g.¬†mutation, genetic drift) and to hypothesis testing using data from a sample. Hence, we biologists often need to use random numbers in our computer programming. Random numbers enable us to model probabilistic processes, where different outcomes occur some pre-defined proportion of the time, if we were to do the process a very large number of times.\nAn interesting fact though is that computers cannot truly pick totally random numbers. Rather, there are deterministic algorithms that do a great job of producing series of numbers that have little apparent relationship with each other, and that appear to occur with equal probability over some range of values. These are often called ‚Äòpseudorandom numbers‚Äô.\nThese algorithms start with a random number seed, and if you give a certain algorithm the same seed and run it twice, it will produce the same series of ‚Äòrandom‚Äô numbers. This can be useful if for instance you are testing a simulation and you want to ensure it produces the same output after you‚Äôve made some small change to the code. Other times though, you want your random numbers to be as unpredictable as possible. For this we can use an arbitrary seed that we have never tried before; different seeds will produce totally different random sequences. A neat trick is to look up the time on the computer‚Äôs clock and use digits representing the number of milliseconds (after the last whole second) as the random number seed; this way the programmer cannot even predict the seed before running the code.\nMost of the time though, we don‚Äôt need to think at all about the way Julia is generating random numbers, as it uses an excellent algorithm and uses an arbitrary seed based on difficult-to-predict aspects of the computer‚Äôs state. So generating random numbers in Julia is easy!\n\nThe rand() function\nTo get a random number between 0 and 1, we simply write the rand() function with no arguments:\n\nrand()\n\n0.26810545809150477\n\n\nThe output of this default use of the funtion is a floating-point number (that is, it is of type Float64).\nTry running that a few times to see that the output is indeed random.\nBetter yet, let‚Äôs run it 10 times in one command:\n\nrand(10)\n\n10-element Vector{Float64}:\n 0.45026685851651804\n 0.13999324583880635\n 0.5799138297298381\n 0.8784029986364359\n 0.8345129490486987\n 0.32966798725971935\n 0.16061003176307698\n 0.5514081889528958\n 0.7380580916819967\n 0.43204157009192967\n\n\nThis shows that including an integer as the one argument tells Julia to generate that many random numbers (each a Float64 between 0 and 1).\nBut the rand() function makes great use of multiple dispatch. If we include a type as the one argument, it gives us a random value for that type:\n\nrand(Int8)\n\n-117\n\n\nThe returned value here is a random integer within the range of possible Int8 values.\nTo randomly produce true or false:\n\nrand(Bool)\n\nfalse\n\n\nIf we instead put a range as the one argument, Julia returns a number in that range:\n\nrand(1:6)  \n\n3\n\n\nThe above simulates the role of a 6-sided die. Try it a few times.\nOr we can give a vector or tuple containing a set of values to choose from:\n\nrand([0, pi, 2pi])  # the brackets indicate a vector (i.e., an array)\n\n6.283185307179586\n\n\n\nrand(('A', 'C', 'G', 'T'))  # the parentheses indicate a tuple\n\n'G': ASCII/Unicode U+0047 (category Lu: Letter, uppercase)\n\n\nWe can even write the above example more concisely, by providing all the Chars together as a String:\n\nrand(\"ACGT\")  \n\n'C': ASCII/Unicode U+0043 (category Lu: Letter, uppercase)\n\n\nThere is great flexibility in how we can use the rand() function:\n\nrand([1, \"DNA\", false], (2,5))  \n\n2√ó5 Matrix{Any}:\n 1  \"DNA\"  \"DNA\"  \"DNA\"      1\n 1  \"DNA\"  \"DNA\"  \"DNA\"  false\n\n\nAbove, we provided as arguments both the set of possible outcomes and a tuple indicating the dimensions and size of the matrix to produce.\n\n\nSetting up to get random numbers that are reproducible (!?!)\nIf we want our code to produce and use the same sequence of ‚Äòrandom‚Äô numbers, we need to load the Random package:\n\nusing Random\n\nThe rand() function can accept an optional first argument that specifies the random number generator. Here, we will use the Xoshiro algorithm (now the default in Julia) and give it an arbitrary seed of 321:\n\nrand(Xoshiro(321), 5)\n\n5-element Vector{Float64}:\n 0.6893036297831823\n 0.22036324422357434\n 0.7799494887616285\n 0.2330428384897486\n 0.8716295743088799\n\n\nLet‚Äôs see if we run that again:\n\nrand(Xoshiro(321), 5)\n\n5-element Vector{Float64}:\n 0.6893036297831823\n 0.22036324422357434\n 0.7799494887616285\n 0.2330428384897486\n 0.8716295743088799\n\n\nWe get the same sequence of numbers. The numbers are ‚Äòrandom‚Äô in some sense, but repeatable. Try changing the value of the seed, and see what happens.\nInstead of setting up a random number generator each time we call the rand() function, we might want to set up a random number generator and then use that throughout our program. That way, the set of numbers in our program is never repeated within our program, but the whole program will run the same each time. For this, we set up a random number generator (‚Äòrng‚Äô) and use that each time:\n\nrng = Xoshiro(321)\nrand(rng, 5)\n\n5-element Vector{Float64}:\n 0.6893036297831823\n 0.22036324422357434\n 0.7799494887616285\n 0.2330428384897486\n 0.8716295743088799\n\n\n\nrand(rng, 5)\n\n5-element Vector{Float64}:\n 0.02894933089311269\n 0.07474632097497813\n 0.38509511194135615\n 0.6081412740086088\n 0.17766823446325286\n\n\nNow our two sets of numbers above are different (so ‚Äòrandom‚Äô with respect to each other), but reproducible on a larger level. (You can test this by rerunning the three lines of code above.)\nWe can use our generator to choose among specified options using a construction like this:\n\nrand(rng, [\"yes\",\"no\",\"maybe\"], 5)\n\n5-element Vector{String}:\n \"maybe\"\n \"maybe\"\n \"no\"\n \"yes\"\n \"maybe\"\n\n\n\n\n\n\n\n\nMake some DNA\n\n\n\nWrite a function that produces a pseudo-random DNA sequence (using the letters A, C, G, T), of a length provided to the function. Ensure that your function always provides the same sequence, such that the only thing that differs between function calls is the length of the sequence. (You might find this useful: the function join() useful, as it assembles a string out of elements in a vector, e.g.¬†join([2,\"A\"]) returns \"2A\".)\n\n\n\n\nNormally-distributed random numbers\nOften in the context of biology, we want normally-disributed random numbers. To draw from a normal distribution with mean 0 and standard deviation 1, use this function:\n\nrandn()\n\n-0.3293554516913429\n\n\n\n\n\n\n\n\nMake a cell move\n\n\n\nMake a graph showing the path of a cell that has moved randomly in 2-dimensional space. (Hint: Start the cell at a certain location give by an x and y value, and then alter the x and y values by adding independent random values)\n\n\n\n\nMake a null distribution\nNow that we know how to randomly sample from a set of outcomes, we can generate our own null distributions and use them in statistical tests of our data. Here is a simple example, borrowed from the UBC BIOL 300 teaching material (thanks to Mike Whitlock) and based on the data in this paper:\nHill, RA, and RA Burton 2005. Red enhances human performance in contests. Nature 435:293\nIn the 2004 olympics, athletes in four combat sports (boxing, taekwondo, Greco-Roman wrestling, and freestyle wrestling) were randomly assigned red or blue clothing. Given the random assignment, if color has no effect on the probability of winnning, then we expect about half of matches to be won by each color. In actuality, there were more red than blue winners in 16 rounds of competition, and more blue than red winners in only 4 rounds. Is this convincing enough evidence that color had a psychological effect on the athletes, or is it plausible that this outcome was just by chance?\nWell, let‚Äôs generate a null distribution for the number of rounds won by red (out of 20 rounds), assuming color had no actual effect. To do this we can simulate red randomly winning or losing, do that 20 times, and record the number of red wins as one possible result when color has no effect. We can then do that whole process a large number of times and observe the proportion of times that we get a result of 16 red wins or something equally or more extreme. (This is an estimate of the P-value.)\n\nfunction getSimulatedRedWins()\n    redWins = 0  # initialize the counter at zero\n    for i in 1:20  # loop through 20 rounds\n        winner = rand([\"red\",\"blue\"])  # pick a random winner for one round\n        if winner == \"red\"  # if red winner, add one to the count of red wins\n            redWins = redWins + 1 \n        end\n    end\n    return redWins\nend\n\ngetSimulatedRedWins()\n\n9\n\n\n\n\n\n\n\n\nTry another way of writing the above function\n\n\n\nA fun thing about programming is there are many ways to solve a problem. Try different approaches for writing the function above. Can you figure out a way that doesn‚Äôt use a for loop?\nAlso, can you make the above function more general in some way? For instance, can you make it such that the number of rounds (20) is not fixed but can entered as an argument to the function?\n\n\nWe now have a function to get one simulated value for the number of red wins under the null hypothesis of no advantage for red. Lets run this many many times and generate a null distribution:\n\nfunction getManySimResults(numSims)\n    simRedWins = Vector{Int8}(undef, numSims) \n    for i in 1:numSims  # loop through simulations\n        simRedWins[i] = getSimulatedRedWins()\n    end\n    return simRedWins\nend\n\nnullValues = getManySimResults(1_000_000)\n\nusing Plots\n\nhistogram(nullValues, bins = (0:21) .- 0.5, legend=false, xlabel = \"Number of red wins\",\n    ylabel = \"Number of simulations\",)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe graph shows the distribution of the number of red wins out of 20 trials, under the null hypothesis that the probabilities of red vs.¬†blue winning are both 50%.\n\n\nEstimate a P-value\nWe can now compare our real data (16/20 wins were for red) and ask how much of our null distribution is that extreme or even more extreme. Hence we‚Äôll add up the proportion of simulations with 16 or more red wins. Then, we‚Äôll multiply by 2 to include the other extremes on the blue-winning side (making this a two-tailed test):\n\nnumExtremeSims = 2sum(nullValues .&gt;= 16)\n\n11742\n\n\nOur estimated P-value will be that number divided by the number of simulations:\n\npValue = numExtremeSims / length(nullValues)\n\n0.011742\n\n\nIf you have a statistics background, you might have noticed the above situation is perfectly suited for a binomial test. In fact, the distribution that we simulated is extremely close to a binomial distribution. The only reason it differs is because our number of simulated outcomes is finite‚Äìmeaning there are chance differences between or simulated distribution and the theoretical distribution, which is given by the binomial theorem.\nWe can compare our estimated P-value above with the P-value produce by a binomial test. For this, we‚Äôll add a package to our Julia environment and then use it:\nusing Pkg  # this loads the Pkg package\nPkg.add(\"HypothesisTests\")  # this downloads and installs the HypothesisTests package \n\nusing HypothesisTests\nBinomialTest(16, 20, 0.5)\n\nBinomial test\n-------------\nPopulation details:\n    parameter of interest:   Probability of success\n    value under h_0:         0.5\n    point estimate:          0.8\n    95% confidence interval: (0.5634, 0.9427)\n\nTest summary:\n    outcome with 95% confidence: reject h_0\n    two-sided p-value:           0.0118\n\nDetails:\n    number of observations: 20\n    number of successes:    16\n\n\nThis command shows that the p-value of a precise binomial test (0.0118) is extremely close to our estimate based on a large number of simulations. (Doing an even larger number of simulations will tend to make the estimate even closer to the precise value from the binomial test.)\nThe P-value is below the usual significance threshold of 0.05, so the authors rejected the null of no effect of colour on winning, and concluded there is an advantage provided by wearing red rather than blue.\n\n\nPermutation (or Randomization) test\nAbove, we used simulated data sets to generate a null distribution for a single variable (number of red wins out of 20 trials). We can use a related approach when interested in the association of two variables. We do this by assuming the null hypothesis of no association is true, and then repeatedly and randomly shuffle the values in the dataset to make a bunch of new datasets. We calculate a summary statistic from each shuffled dataset, and the distribution of those summary statistics is our null distribution for that statistic. If the statistic from our real data is in the extreme tails of that distribution, we can then reject the null and conclude that there is in fact an association between the variables. This procedure is called a permutation test or randomization test.\nLet‚Äôs do a permutation test on data from this publication:\nJohnson et al. (1999) Female remating propensity contingent on sexual cannibalism in sagebrush crickets,¬†Cyphoderris strepitans: a mechanism of cryptic female choice. Behavioral Ecology 10: 227-233.\nWhen these crickets mate, the male offers his hindwings for the female to eat. The question was: Why would they do such a thing?!? One idea: if the females get some nutrients from the wings, maybe they wait longer to remate (with another male), the implication being that males who feed females their wings might father more offspring.\nLet‚Äôs load a dataset containing times to remating for two experimental groups of females: those mated initially with a winged male (and who mostly ate his wings) and those mated initially with a wingless male (where wings had been surgically removed).\n\nusing CSV, DataFrames\ncricketData = DataFrame(CSV.File(\"example_data/cricketData.csv\"))\n\n25√ó2 DataFrame\n\n\n\nRow\nMale_state\nLog_remating_time\n\n\n\nString15\nFloat64\n\n\n\n\n1\nMale_wingless\n0.0\n\n\n2\nMale_wingless\n0.7\n\n\n3\nMale_wingless\n0.7\n\n\n4\nMale_wingless\n1.4\n\n\n5\nMale_wingless\n1.6\n\n\n6\nMale_wingless\n1.8\n\n\n7\nMale_wingless\n1.9\n\n\n8\nMale_wingless\n1.9\n\n\n9\nMale_wingless\n1.9\n\n\n10\nMale_wingless\n2.2\n\n\n11\nMale_wingless\n2.1\n\n\n12\nMale_wingless\n2.1\n\n\n13\nMale_winged\n1.4\n\n\n14\nMale_winged\n1.6\n\n\n15\nMale_winged\n1.9\n\n\n16\nMale_winged\n2.3\n\n\n17\nMale_winged\n2.6\n\n\n18\nMale_winged\n2.8\n\n\n19\nMale_winged\n2.8\n\n\n20\nMale_winged\n2.8\n\n\n21\nMale_winged\n3.1\n\n\n22\nMale_winged\n3.8\n\n\n23\nMale_winged\n3.9\n\n\n24\nMale_winged\n4.5\n\n\n25\nMale_winged\n4.7\n\n\n\n\n\n\nLet‚Äôs make some quick histograms showing the distribution of remating time for each group:\n\n#times = cricketData.Log_remating_time[cricketData.Male_state .== \"Male_wingless\"]\nusing Plots\np1 = histogram(cricketData.Log_remating_time[cricketData.Male_state .== \"Male_wingless\"], bins=0:0.5:5, xlims=[0,5], title=\"females mated to wingless males\", ylabel=\"frequency\")\n\np2 = histogram(cricketData.Log_remating_time[cricketData.Male_state .== \"Male_winged\"], bins=0:0.5:5, xlims=[0,5], title=\"females mated to winged males\", xlabel=\"Remating time\", ylabel=\"frequency\")\n\nplot(p1, p2,\n    layout = @layout [p\n                      p])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIf we want to test whether the two groups differ (beyond chance differences due to sampling error), we might be uncomfortable with a 2-sample t-test because that would require assumptions of normality and equal variance. Instead, we can do a permutation test.\nThe permutation test assumes nothing about the underlying distributions, simply holding up the null hypothesis of no difference in distributions between the two categories. We‚Äôll test this by generating a null distribution for the difference in mean remating time between the two categories, and then compare our real difference to that null distribution.\nLet‚Äôs make a function to calculate the difference in means:\n\nfunction calculateCricketMeanDiffs(data::DataFrame)\n    winged = subset(data, :Male_state =&gt; x -&gt; x .== \"Male_winged\").Log_remating_time\n    wingless = subset(data, :Male_state =&gt; x -&gt; x .== \"Male_wingless\").Log_remating_time\n    sum(winged)/length(winged) - sum(wingless)/length(wingless)\nend\n\ncalculateCricketMeanDiffs (generic function with 1 method)\n\n\nNow use that to calculate the difference in real group means:\n\nrealDiff = calculateCricketMeanDiffs(cricketData)\n\n1.4134615384615383\n\n\nSo we have our real difference. Let‚Äôs comnpare that to possible differences we get if there is no real association between male state and remating time. We‚Äôll shuffle the values of one variable (using the well-named shuffle() function) and construct a null distribution of mean differences:\n\nusing Random  # needed for the shuffle() function\nfunction permuteOnce(data::DataFrame)\n    permutedData = copy(data)  # this makes a copy of the dataframe, so original not altered\n    shuffle!(permutedData.Log_remating_time)  # can specify a random number generator as a first argument, if desired\n    return permutedData\nend\n\n# Test the function above:\npermuteOnce(cricketData)\n\n25√ó2 DataFrame\n\n\n\nRow\nMale_state\nLog_remating_time\n\n\n\nString15\nFloat64\n\n\n\n\n1\nMale_wingless\n3.1\n\n\n2\nMale_wingless\n2.8\n\n\n3\nMale_wingless\n2.1\n\n\n4\nMale_wingless\n0.7\n\n\n5\nMale_wingless\n1.9\n\n\n6\nMale_wingless\n1.4\n\n\n7\nMale_wingless\n2.6\n\n\n8\nMale_wingless\n4.7\n\n\n9\nMale_wingless\n2.3\n\n\n10\nMale_wingless\n2.8\n\n\n11\nMale_wingless\n2.8\n\n\n12\nMale_wingless\n2.1\n\n\n13\nMale_winged\n1.9\n\n\n14\nMale_winged\n0.0\n\n\n15\nMale_winged\n1.6\n\n\n16\nMale_winged\n3.9\n\n\n17\nMale_winged\n1.4\n\n\n18\nMale_winged\n1.6\n\n\n19\nMale_winged\n1.9\n\n\n20\nMale_winged\n1.8\n\n\n21\nMale_winged\n2.2\n\n\n22\nMale_winged\n3.8\n\n\n23\nMale_winged\n1.9\n\n\n24\nMale_winged\n4.5\n\n\n25\nMale_winged\n0.7\n\n\n\n\n\n\n\nfunction permuteMany(data::DataFrame, reps::Int)\n    nullDiffs = Vector{Float64}(undef, reps) \n    for i in 1:reps\n        permutedData = permuteOnce(data)\n        nullDiffs[i] = calculateCricketMeanDiffs(permutedData)\n    end\n    return nullDiffs\nend\n\npermutedDiffs = permuteMany(cricketData, 10_000)\n\n10000-element Vector{Float64}:\n  0.5480769230769231\n -0.301282051282052\n -0.42948717948717885\n  0.6602564102564101\n  0.019230769230769607\n -0.22115384615384626\n -0.6057692307692311\n -0.10897435897435903\n  0.8685897435897436\n  0.27564102564102555\n -0.38141025641025683\n -0.34935897435897445\n -0.23717948717948678\n  ‚ãÆ\n -0.49358974358974406\n -0.044871794871795156\n  0.27564102564102555\n  0.612179487179487\n -0.028846153846153744\n  0.339743589743589\n -0.28525641025641013\n -0.7019230769230764\n  0.22756410256410264\n  0.275641025641026\n  1.1891025641025639\n -0.5897435897435896\n\n\nNow let‚Äôs plot our null distribution and our real value:\n\nhistogram(permutedDiffs)\nplot!([realDiff, realDiff], [0, 200], color=\"red\", width=5)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSo our real value (shown in red) is quite extreme compared to the null distribution of our test statistic, given the null hypothesis of no association between the experimental group and the response variable. This causes us to doubt the null. We can estimate the p-value by determining how many simulated values were beyond our actual value (times 2 to make it a 2-tailed test):\n\npValue = 2sum(permutedDiffs .&gt;= realDiff) / length(permutedDiffs)\n\n0.0016\n\n\nOur estimate of the p-value tends to become more precise if we increase the number of permutations (see several cells up, where we called the permuteMany() function).\nThe p-value is far below the usual standard alpha of 0.05, so we are comfortable in rejecting the null and concluding that experimental removal of male hindwings does appear to shorten the remating time of females mated to that male (at least in this species of cricket).\n\n\nHave fun with randomness!\nI find experimenting with randomness can be one of the most enjoyable aspects of writing computer simulations. I think this is one reason humans enjoy games of chance‚Äìthere is a surprising aspect to randomness, but also a strange sense of order can go along with it. Using functions like rand(), randn(), and shuffle(), I encourage you to have fun incorporating randomness into your programming.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Randomization in Simulation and Statistics"
    ]
  },
  {
    "objectID": "ArraysAndDataFrames.html",
    "href": "ArraysAndDataFrames.html",
    "title": "Arrays & DataFrames",
    "section": "",
    "text": "Two Julia object types are especially useful for storing and manipulating datasets are Arrays (which we learned some about in the quick introduction) and DataFrames. On this page we‚Äôll build understanding about each of these.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Arrays & DataFrames"
    ]
  },
  {
    "objectID": "ArraysAndDataFrames.html#arrays",
    "href": "ArraysAndDataFrames.html#arrays",
    "title": "Arrays & DataFrames",
    "section": "Arrays",
    "text": "Arrays\nYou can think of an Array as a big box that contains one or more small boxes in a grid arrangement. They can have zero dimensions (i.e., one small box), one dimension (i.e., a stack of small boxes; also called a Vector), two dimensions (i.e., a grid of small boxes; also called a Matrix), or even more dimensions. We can store things in each small box, and refer to what is in that box by its indices (the box number along each dimension).\nFor example, here we create a 2-dimensional array of 3 by 4 dimensions:\n\nA = [11 21 31 41\n     0 0 0 0\n     99 88 77 66]\n\n3√ó4 Matrix{Int64}:\n 11  21  31  41\n  0   0   0   0\n 99  88  77  66\n\n\nJulia shows us the type of this object as being Matrix{Int64} meaning that it is a Matrix (a 2-dimensional Array) with elements of type Int64.\nLet‚Äôs look in just one box using indexing:\n\nA[3,2]\n\n88\n\n\nThat gives us the value in row 3 and column 2.\nOr we can take a slice of the array:\n\nA[1:3,2:3]\n\n3√ó2 Matrix{Int64}:\n 21  31\n  0   0\n 88  77\n\n\n\nCreating arrays\nOften in programming, it is good practice to set up an array and then later fill it with meaningful values. This promotes efficiency (minimizing memory use and maximizing speed) compared to building an array by small pieces at a time.\nWe can initialize arrays in a number of ways. Here are a few of the possibilities:\n\nB = ones(3, 7)\n\n3√ó7 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0\n\n\n\nC = zeros(1,5)\n\n1√ó5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n\n\n\nD = fill(3.7, 3, 5, 2)\n\n3√ó5√ó2 Array{Float64, 3}:\n[:, :, 1] =\n 3.7  3.7  3.7  3.7  3.7\n 3.7  3.7  3.7  3.7  3.7\n 3.7  3.7  3.7  3.7  3.7\n\n[:, :, 2] =\n 3.7  3.7  3.7  3.7  3.7\n 3.7  3.7  3.7  3.7  3.7\n 3.7  3.7  3.7  3.7  3.7\n\n\nThis last one is a 3-dimensional array. You can think of the dimensions as rows, columns, and pages or layers.\nThere are many times when we don‚Äôt care what the initial values in our array are. A time-saving method is to declare an array with an arbitrary value determined by the bit values already in the memory being accessed:\n\n@time E = Array{Float64}(undef, 1000, 1000)\n\n  0.000005 seconds (3 allocations: 7.629 MiB)\n\n\n1000√ó1000 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  ‚Ä¶  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  ‚Ä¶  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  ‚Ä¶  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n ‚ãÆ                        ‚ãÆ              ‚ã±            ‚ãÆ                   \n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  ‚Ä¶  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  ‚Ä¶  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\n\n\n@time F = ones(1000,1000)\n\n  0.003587 seconds (3 allocations: 7.629 MiB)\n\n\n1000√ó1000 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  ‚Ä¶  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  ‚Ä¶  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  ‚Ä¶  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n ‚ãÆ                        ‚ãÆ              ‚ã±            ‚ãÆ                   \n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  ‚Ä¶  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  ‚Ä¶  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\n\n\nThose two commands both create the same sized objects of type Matrix{Float64}, but the second takes longer to run because it has to change all the values to 1.0.\n\n\nArrays can store just about anything!\n\nG = [1 1.0 \"one\"\n     1//1 '1' BigInt(1)]\n\n2√ó3 Matrix{Any}:\n  1    1.0    \"one\"\n 1//1   '1'  1\n\n\nIn fact, you can even put an array inside an array:\n\nG[1,1] = [1 0\n          0 1]\nG\n\n2√ó3 Matrix{Any}:\n   [1 0; 0 1]  1.0    \"one\"\n 1//1           '1'  1\n\n\nThe object G is of type Matrix{Any} which means that it is a matrix that can store anything in its small boxes. In contrast, the object A (which we created far above) is of type Matrix{Int64} which means that it can only store integers. If we try to put something else in its boxes, we get an error:\nA[2,3] = \"A string, not an integer\"\nJulia responds: MethodError: Cannot `convert` an object of type String to an object of type Int64\nThe error arises because A is set up as a matrix of integers, and we cannot put a string into it. We can fix this though be changing the type of the array:\n\nA = convert(Matrix{Any}, A)  # converts A to type Matrix{Any}\nA[2,3] = \"A string, not an integer\"\nA\n\n3√ó4 Matrix{Any}:\n 11  21  31                            41\n  0   0    \"A string, not an integer\"   0\n 99  88  77                            66\n\n\n\n\nMemory and speed efficiency of arrays\nWhen we created the arrays A and G, Julia made a best guess as to what types it should allow in the boxes. In the case of A, when we first created it we put in only integers, so Julia made the assumption that we would always want only integers in it. Why would it make that limitation? Well, there are huge benefits in terms of the way the array is stored in memory. If only integers will be stored, then Julia knows how much memory to allocate. If anything could be stored in an array, then it has to set it up in memory in a more flexible way that is not as efficient.\nJulia gives us the option of thinking a lot about efficiency in our coding, but it is also quite fast even when you don‚Äôt write efficient code, by making its best guess about how to store data. As you become a better programmer and work with larger datasets, it will become more useful to think about storing data efficiently.\nAs one example, let‚Äôs say we need to store a big matrix of random values, lets say 10,000 rows by 10,000 columns, so 100 million values. We could just venture forth with a simple command, like this:\n\nbigMatrix = fill(1, 10_000, 10_000)    \n\n10000√ó10000 Matrix{Int64}:\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n ‚ãÆ              ‚ãÆ              ‚ãÆ        ‚ã±        ‚ãÆ              ‚ãÆ           \n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n\n\nThis creates a 10,000 by 10,000 array and fills it with the 1s. We can check the memory size of this array like this:\n\nsizeof(bigMatrix)   \n\n800000000\n\n\nThis tells us that bigMatrix uses 800 million bytes of memory. This makes sense, because it is of type Matrix{Int64} meaning that each element is stored as a 64-bit integer, meaning it uses 8 bytes (there are 8 bits in a byte).\nIf we think about our needs though, we might realize we will not need to store any big or small integers in this matrix. If our matrix will only be used to store integers ranging from -128 and 127, then those integers can all be stored in only 8 bits (1 byte). So let‚Äôs tell Julia that we want our Matrix set up like that:\n\nbigMatrix2 = fill(Int8(1), 10_000, 10_000)   \n\n10000√ó10000 Matrix{Int8}:\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n ‚ãÆ              ‚ãÆ              ‚ãÆ        ‚ã±        ‚ãÆ              ‚ãÆ           \n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n\n\nNow, we have filled our new matrix with Int8(1) which is the value 1 encoded as type Int8, meaning it takes up 8 bits, or 1 byte:\n\nsizeof(bigMatrix2)   \n\n100000000\n\n\nThis matrix takes 1/8 the memory of the first, but encodes exactly the same information. (But we have more limitation on what numbers it can store.)\nUsually, information stored with lower memory footprint will also be quicker to access, meaning your programs will be faster.\n\nBitArrays\nA super efficient way to store a set of binary values (e.g.¬†true/false, 1/0, on/off) is as a BitArray, wherein each element is stored as a single bit (the smallest memory unit in a computer). This means we can store 64 values in the same memory space as a default integer stored as Int64 would take:\n\nmyBitArray = trues(10_000, 10_000)  # trues() sets up a BitArray with all values set to 1\n\n10000√ó10000 BitMatrix:\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n ‚ãÆ              ‚ãÆ              ‚ãÆ        ‚ã±        ‚ãÆ              ‚ãÆ           \n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1  ‚Ä¶  1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1  1  1  1  1  1     1  1  1  1  1  1  1  1  1  1  1  1\n\n\n\nsizeof(myBitArray)\n\n12500000\n\n\nNow our array of 1s takes only 12.5 million bytes, which is 1/64 the memory size of our bigMatrix of 1s above.\n\n\n\nLogical indexing\nOne way to choose specific elements from arrays is using logical indexing, in which a series of true/false values (or as 1/0 values in a BitArray) are used to indicate the elements to choose. To show this, let‚Äôs start with a simple matrix:\n\nm1 = reshape(1:16, 4, 4)  # reshape() turns a Vector into a Matrix\n\n4√ó4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\n\nNow we can use a vector of Boolean values to choose rows:\n\nm1[[true, false, true, false], :]\n\n2√ó4 Matrix{Int64}:\n 1  5   9  13\n 3  7  11  15\n\n\nOr choose rows and columns like this:\n\nm1[[true, false, true, false], [false, true, true, false]]\n\n2√ó2 Matrix{Int64}:\n 5   9\n 7  11\n\n\nAn equivalent expression using BitVectors is:\n\nm1[BitVector([1, 0, 1, 0]), BitVector([0, 1, 1, 0])]\n\n2√ó2 Matrix{Int64}:\n 5   9\n 7  11\n\n\nThis lets us do things like choose the even rows and odd columns:\n\nm1[iseven.(1:4), isodd.(1:4)]\n\n2√ó2 Matrix{Int64}:\n 2  10\n 4  12\n\n\nIn the above expression, iseven.(1:4) produces a BitVector that indicates whether each integer from 1 to 4 is even. See that here:\n\niseven.(1:4)\n\n4-element BitVector:\n 0\n 1\n 0\n 1\n\n\nAbove we used logical indexing to determine the rows and columns to include. We can also use it to pick elements more directly:\n\nselectionMask = (m1 .% 3 .== 0)  # Chooses values divisible by 3\n\n4√ó4 BitMatrix:\n 0  0  1  0\n 0  1  0  0\n 1  0  0  1\n 0  0  1  0\n\n\nThe above made a BitMatrix indicating which elements satisfied the condition. Now let‚Äôs use that to choose those elements:\n\nm1[selectionMask]\n\n5-element Vector{Int64}:\n  3\n  6\n  9\n 12\n 15\n\n\nThis method‚Äîof specifying a condition for elements to satisfy, constructing a BitMatrix, and using that BitMatrix to index the array‚Äîis used often in data analysis.\n\n\n\n\n\n\nBuild a structure for storing genotypes\n\n\n\nYour research involves genotypic data, and you want to efficiently keep track of both real and simulated diploid genotypes for multiple individuals and loci (i.e., genes). You can assume that there are only two alleles at each locus. Can you come up with a data object to store your data, and then store some example data in your object? (Hint: you have 3 dimensions of data: individuals, loci, and the two alleles at each locus.)\nIf that goes well, then write code that will choose only the heterozygous individuals at a given locus.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Arrays & DataFrames"
    ]
  },
  {
    "objectID": "ArraysAndDataFrames.html#dataframes",
    "href": "ArraysAndDataFrames.html#dataframes",
    "title": "Arrays & DataFrames",
    "section": "DataFrames",
    "text": "DataFrames\nThese are also hugely useful in biological data analysis. A DataFrame can be thought of as a series of same-length Vectors arranged as columns into a single table of data. Usually, each row represents an individual, whereas each column represents a distinct variable. Importantly, the different columns can have different types of elements (for example, one column might have Strings, one might have Ints, another might have Float64s, etc.). DataFrames store these different types of vectors efficiently. Furthermore, we can designate names for each column and refer to them by those names.\nTo use DataFrames, we must download and install a package. Type ] to enter the package mode, then enter this:\nadd DataFrames\nNow press delete or backspace to enter the normal REPL mode, and enter this:\n\nusing DataFrames\n\nLet‚Äôs enter some example data:\n\ndata = DataFrame(species = [\"warbler\", \"wren\", \"sparrow\", \"flameback\"],\n          mass_g = [11, 9, 28, 300],\n          random_num = rand(4))\n\n4√ó3 DataFrame\n\n\n\nRow\nspecies\nmass_g\nrandom_num\n\n\n\nString\nInt64\nFloat64\n\n\n\n\n1\nwarbler\n11\n0.600277\n\n\n2\nwren\n9\n0.10777\n\n\n3\nsparrow\n28\n0.616053\n\n\n4\nflameback\n300\n0.253371\n\n\n\n\n\n\nThe REPL now shows us our dataframe in a nice table format. We see it has interpreted our input data as we would like, with the three columns containing elements of type String, Int64, and Float64.\nWe can now refer to columns in a convenient way:\n\ndata.species\n\n4-element Vector{String}:\n \"warbler\"\n \"wren\"\n \"sparrow\"\n \"flameback\"\n\n\n\ndata.mass_g\n\n4-element Vector{Int64}:\n  11\n   9\n  28\n 300\n\n\nThis convenient reference allows us to choose subsets of the data, borrowing our knowledge from the Logical Indexing section above:\n\ndata.species[data.mass_g .&gt; 20]\n\n2-element Vector{String}:\n \"sparrow\"\n \"flameback\"\n\n\nWe can add a new column quite easily:\n\ndata.size_category = fill(\"undetermined\", size(data, 1))  # the size(data,1) function gets the number of rows.\ndata\n\n4√ó4 DataFrame\n\n\n\nRow\nspecies\nmass_g\nrandom_num\nsize_category\n\n\n\nString\nInt64\nFloat64\nString\n\n\n\n\n1\nwarbler\n11\n0.600277\nundetermined\n\n\n2\nwren\n9\n0.10777\nundetermined\n\n\n3\nsparrow\n28\n0.616053\nundetermined\n\n\n4\nflameback\n300\n0.253371\nundetermined\n\n\n\n\n\n\nNow let‚Äôs fill in our new column with meaningful values:\n\ndata.size_category[data.mass_g .&gt; 100] .= \"BIG\"\ndata.size_category[100 .&gt; data.mass_g .&gt; 15] .= \"medium\"\ndata.size_category[15 .&gt; data.mass_g] .= \"small\"\ndata\n\n4√ó4 DataFrame\n\n\n\nRow\nspecies\nmass_g\nrandom_num\nsize_category\n\n\n\nString\nInt64\nFloat64\nString\n\n\n\n\n1\nwarbler\n11\n0.600277\nsmall\n\n\n2\nwren\n9\n0.10777\nsmall\n\n\n3\nsparrow\n28\n0.616053\nmedium\n\n\n4\nflameback\n300\n0.253371\nBIG\n\n\n\n\n\n\nThe DataFrames.jl package is extremely capable, and we are just touching the surface here of what it can do. A good source to learn more is: https://dataframes.juliadata.org/stable/man/basics/#First-Steps-with-DataFrames.jl",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Arrays & DataFrames"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Julia Programming For Biologists",
    "section": "",
    "text": "Welcome! I am starting this website on January 11, 2024, for the purpose of teaching tutorials about the Julia programming language, in the context of biology.\nJulia is a relatively new programming language (started around 2012; first official release in 2018) that is both highly readable (by humans) and fast. This is intended to solve the ‚Äú2-language‚Äù problem, a common workflow in which development of a new program is done first in a highly readable language (e.g., R or Python) and then converted by an expert programmer into a fast language (e.g., C), such that the resulting code can be difficult to read by non-experts. Hence Julia aims to be a language that provides easy entry for new programmers while also having the power and efficiency to appeal to experts. It is used by NASA, Moderna, Pfizer, and many other organizations, and is used widely by scientists doing climate modelling of Earth and imaging black holes in distant galaxies.\nIf you are in doubt that you need a faster or more readable language than the one you are using, ask yourself this: Have you ever heard other scientists mention how long their bioinformatic processing or evolutionary simulations can take? It is often on the scale of days, weeks, months. What if that were instead minutes, hours, days? How might that accelerate your research, and allow you to expand the scope of your science? Have you ever heard someone say ‚ÄúI can‚Äôt program‚Äù? Did they decide that because they are fundamentally unable to learn the logic of programming, or because many of the languages often taught in programming are really difficult to learn?\nI have used Julia in my own work for about 3 years now, after having much experience with Matlab and then R, and dabbling a bit in Python, C, C++, and Java. The developers of Julia have praise for aspects of all of these languages, and their goal was to combine all the good aspects into one efficient and readable language. I think they have succeeded marvelously. (I am not the only one‚Äîsee this paper in Nature Methods for a discussion of the merits of using Julia in biology.)\nMy intended audience with these tutorials is biologists with no or little previous programming experience, who are interested in building their data science, bioinformatic, and statistics skills, or who even want to design their own mathematical models and simulations. In particular, I am using these to teach a new graduate-level course ‚ÄúComputer Programming for Biologists‚Äù at UBC in November 2024. My goal is to get students programming quickly, giving just enough underlying explanation of computer science principles to enable fast progress.\nThese tutorials are a work in progress, and there will be additions and revisions from time to time . . .\n\n\n\n\n\nTo advance through pages of the tutorial, click on the right arrow below.",
    "crumbs": [
      "Home",
      "Basics",
      "Home"
    ]
  },
  {
    "objectID": "PlutoNotebooks.html",
    "href": "PlutoNotebooks.html",
    "title": "Pluto Notebooks",
    "section": "",
    "text": "Now that we know how to use the Julia REPL to interact with Julia and are building our understanding of programming, we likely want an environment in which we can compose programs and save them for use later. Pluto notebooks provides a reactive notebook environment for doing this.\n\nInstall Pluto\nPluto is a package that we install into Julia in the same way as we did with the Plots package (on the last page):\nType ] to enter the package mode, then input this:\nadd Pluto\nThis downloads and installs everything needed for Pluto to run (which is quite a bit, so may take some time).\nWhen done, press ‚Äúdelete‚Äù to return from package mode to the REPL. Then type these two commands:\nimport Pluto\nPluto.run()\nEventually (and if your computer works the same as mine), a browser window will open that says ‚Äúwelcome to Pluto.jl‚Äù at the top.\n\n\nCreate your first notebook\nClick on ‚ÄúCreate a new notebook‚Äù (Under the heading ‚ÄúMy Work‚Äù).\nYou will then see a mostly blank page that says ‚ÄúPluto.jl‚Äù in the upper left. Below that there is a line with faint text that says ‚ÄúEnter cell code‚Äù. Try entering a simple Julia expression there to assign a value to a variable (e.g.¬†something like a = 7^2) and then press Shift + Enter to tell Pluto to evaluate the cell.\nPluto then returns the result of your expression above the cell.\nLet‚Äôs add another cell by clicking the little ‚Äú+‚Äù sign below the first cell. In this new cell, enter an expression that creates a second variable and assigns to it a calculation involving your first variable (e.g.¬†b = a - 3). You will see again see the result above the cell.\nNow, edit the first cell to change the value assigned to a, and press Shift + Enter. You will see the returned value of a change, and the value of b changes too. This is what it means to be reactive: any change in your notebook propogates through the entire notebook in a logical way. The whole notebook then is like a single program.\n\nPluto notebooks are not dependent on cell order\nTry switching the order of your two cells, by simply hovering your pointer to the left of one of the cells, and then dragging it up or down. Now play around with the code in the cells. You will see that the results do not depend on cell order.\nThis allows you to organize notebooks in whatever way you want. You have the option of having the final result at the top, with supporting code lower down.\n\n\nConsequences of movable cell blocks\nThere are a couple important consequence of the above. One is that we cannot have two statements that assign to the same variable in two different cells. For instance, if you say a = 1 in one cell and a = a + 1. (Try it! Pluto will respond with an error and suggest a solution.) Instead, we can use begin-end blocks to group code in which a single variable is assigned a series of values in succession:\n\nbegin\n    myVar = 1\n    myVar = myVar + 5\nend\n\n6\n\n\nA related principle is that each cell block can only contain a single expression. (However, an expression can be quite big if it contain a begin-end block.) This ensures Julia can figure out which cells depend on which.\n\n\n\nSave your notebook\nLet‚Äôs save our notebook so we can open it later and use it again. At the top of the page, click on ‚ÄúSave notebook‚Äù. You can then choose a folder and enter a file name (e.g.¬†something like ‚ÄúMyFirstPlutoNotebook.jl‚Äù wouldn‚Äôt be a terrible choice). It is good to give your notebook a ‚Äú.jl‚Äù extension, which indicates a file written in Julia.\nIf you now leave your notebook by clicking on the ‚ÄúPluto.jl‚Äù logo in the upper left, you should see that the notebook you just saved is listed under ‚ÄúMy Work‚Äù. Click on that notebook name, and it will open your notebook again.\n\n\nPluto files are valid Julia files\nA nice thing about working in Pluto is that the file that you are saving is 100% runnable as a Julia file (without using Pluto).\n\n\nPluto has no ‚Äúhidden state‚Äù\nA way that Pluto differs from some other notebook environments (e.g.¬†Jupyter) is that the program state is completely described by the code in the notebook. You don‚Äôt have to wonder if each cell has been executed‚Äìthe entire notebook is affected by any change you make (although Julia is clever and for efficiency figures out what cells depend on that change).\n\n\nMake a plot in Pluto\nPluto can show all sorts of output from your code. For instance, try making a plot. We first need to install the Plots package into our Pluto environment:\n\nusing Plots\n\nIf you have not downloaded the Plots package, Pluto will nicely do it for you.\nNow, lets generate some data and graph it:\n\nbegin\n  numPoints = 10\n  xValues = randn(numPoints) # random draw from standard normal distribution\n  yValues = xValues .+ 0.5 .* randn(numPoints)\n  scatter(xValues, yValues)\nend\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou will likely see a scatter plot of 10 data points. The data generation involved random draws from a standard normal distribution, so your graph won‚Äôt look exactly the same as the one shown here.\n\n\n\n\n\n\nAdd a lot more points\n\n\n\nCan you figure out how to modify the above to get 1000 data points? Try it!\nIf wanting a bigger challenge: Can you figure out how to make the cloud of points more like a round cloud, where the xValues and yValues are not so strongly associated?\n\n\n\n\nAdd text using Markdown\nYou can add headers and comments to your notebook using Markdown, simply by entering md and then double quotes surrounding your text. Create a new cell at the top of your notebook and enter this:\nmd\"# _Welcome to my notebook!_ \n\nThis is a Pluto notebook for programming in the Julia language. Pluto notebooks are **reactive** to changes you make.\n\"\nYou can hide the code producing that text by clicking on the little eye symbol left of the code cell.\nWe can incorporate Julia expressions into our Markdown comments by preceding it with a $ symbol:\nmd\"There are $numPoints data points in the graph\"\nnum = 4; md\"The square of $num is $(num^2) .\"\n[Note that if you want the above Markdown commands to work outside of Pluto, e.g.¬†in a regular Julia REPL, you have to add the Markdown.jl package. Enter package mode with ], then enter add Markdown, then press ‚Äúdelete‚Äù to return to REPL, then enter using Markdown.]\n\n\nNext steps\nNow that we have a good envirnoment set up to write and save more complex programs, we‚Äôll learn about control flow, the way you can design a program to do different sets of code depending on the state of one or more variables.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Pluto Notebooks"
    ]
  },
  {
    "objectID": "InstallJulia.html",
    "href": "InstallJulia.html",
    "title": "Download and Install Julia",
    "section": "",
    "text": "To download and install Julia, go to this URL and follow instructions: https://julialang.org/downloads/\nThat website will likely detect your operating system and suggest the right approach.\nIf you have a Mac: The above will direct you to simply open a Terminal window (look for the Terminal application in your Applications/Utilities directory) and type the command below at the Terminal prompt:\ncurl -fsSL https://install.julialang.org | sh\nIf you have a PC: I think the above will direct you to simply open a command-line interface window (using e.g., Windows Powershell or Windows Terminal) and type the command below at the prompt:\nwinget install julia -s msstore\nThe above commands (whether Mac or PC) install the Juliaup installation manager, which is a wonderful tool to help update Julia and keep different versions (if you wish) available on your computer.\n\n\n\n\n\n\nIf desired: update Julia\n\n\n\nIf you already have Julia and Juliaup installed, and you want to update Julia to the latest available stable version, use the command juliaup update. (You can see other useful Juliaup commands here)\n\n\n\nNow, run Julia!\nIn the Terminal window, type julia at the prompt. After some time (only the first time you do this), you should see a julia logo and a prompt saying julia&gt; . This means Julia is installed and running.\nTry typing a simple calculation, e.g.¬†1 + 3 then Enter or Return, and see what happens.\nNow try entering \"Hello, nice to meet you\" (make sure you put the quotes).\nWith the above, you are using the REPL, the Read-Evaluate-Print-Loop. This is a common way of running Julia. (Another way is to save scripts and execute them, but that is usually for more advanced use.)\nNow, go to the next page to learn more about interacting with Julia.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Download and Install Julia"
    ]
  },
  {
    "objectID": "MultipleDispatch.html",
    "href": "MultipleDispatch.html",
    "title": "Types and Multiple Dispatch",
    "section": "",
    "text": "If you‚Äôve worked through the material in the previous pages, you now have the tools to write all sorts of reasonably complex programs to do interesting things. You might take a pause here and build up your skills in combining those tools in ways you find interesting. After spending some time doing that, come back to this page and continue below.\nHere, we‚Äôll build up to an understanding of one of the most powerful features of Julia: multiple dispatch. Rather than define that at the start, we‚Äôll build up an understanding. We‚Äôll start with better understanding of type specifications of objects, then learn how to define our own types of data structures, then learn about single dispatch, and finally explore multiple dispatch.\n\nSpecifying types of objects\nSeveral pages back we learned about how Julia has dynamic typing meaning you often don‚Äôt need to think about the types of objects. But as your programming skills increase, it becomes increasingly beneficial to think about types. This facilitates organized code, interpretation of error messages, reading of documentation, and defining and using functions effectively.\nWe can specify the type of an object using the :: operator, which can be thought of as meaning ‚Äúis an instance of‚Äù:\n\nx::Int64 = 6\n\n6\n\n\nThe above declares an object x as being of type Int64, and then assigns the value 6 to it. If you try to assign something like 6.3 to it, you will get an error (try it!). However, Julia tries to be friendly so if you assign something that can be converted to Int64 it works:\n\ny::Int64 = 6.0\ny\n\n6\n\n\n\nprintln(typeof(6.0))\nprintln(typeof(y))\n\nFloat64\nInt64\n\n\nWhy would you want to force a variable to have a type, when Julia can usually type things correctly on the fly? Maybe you want to make sure that the code is working as you want it to, or you want to prevent code designed for one type of data to be accidentally used for another.\n\n\nCreate your own types: struct\nYou can create your own data structures, which have their own types, using the struct keyword. For instance, let‚Äôs say we are working with shapes:\n\nstruct Circle\n    radius\nend\n\nSo now we have defined a new type (Circle) that has one field (radius). We can now create (‚Äúinstantiate‚Äù or ‚Äúconstruct‚Äù) an actual object that is of this type by calling Circle like a function:\n\ncircA = Circle(1)\n\nCircle(1)\n\n\n\ntypeof(circA)\n\nCircle\n\n\nSo now, circA is a specific object in memory of type Circle. To get its radius (its only field), we type the name of the object then a . and then the field name:\n\ncircA.radius\n\n1\n\n\nLet‚Äôs define and instantiate another kind of shape:\n\nstruct Square\n    side\nend\nsq1 = Square(5)\n\nSquare(5)\n\n\n\n\n\n\n\n\nMore shapes!\n\n\n\nCan you define a new Rectangle type? It needs to have two fields: length and width. Then, create a specific rectangle.\n\n\n\nMutable vs.¬†immutable types\nThe types defined above by the struct keyword are used to instatiate immutable objects. This means we get an error if we try to alter a field within an object:\nsq1.side = 7\nThe REPL responds with an error saying ‚Äúimmutable struct of type Square cannot be changed‚Äù. To set up the ability to change our objects after they are created, we need to use the mutable struct phrase to define the type:\n\nmutable struct SquareMutable\n  side\nend\n\n\nsqA = SquareMutable(3.5)\n\nSquareMutable(3.5)\n\n\n\nsqA.side = 9.7\n\n9.7\n\n\n\n\n\nDefining functions for specific types\nNow that we have some shape objects, let‚Äôs do something with them. Functions are great at doing things with objects, so let‚Äôs define a function:\n\ngetArea(x::Circle) = œÄ * (x.radius)^2    # write œÄ with: \\pi tab\n\ngetArea (generic function with 1 method)\n\n\nWe have now defined a function that requires a Circle object as input, and returns the area of the circle based on the radius field. We can call it on our actual objects in memory:\n\ngetArea(circA)\n\n3.141592653589793\n\n\nWe also want to get areas of squares. So, we can define a function with the same name but applies only to Squares:\n\ngetArea(x::Square) = x.side^2\n\ngetArea (generic function with 2 methods)\n\n\nNow here is where it gets really neat. Let‚Äôs call the getArea() function on our our actual square object in memory:\n\ngetArea(sq1)\n\n25\n\n\nAnd now let‚Äôs call the same named function on our circle:\n\ngetArea(circA)\n\n3.141592653589793\n\n\nIn each case, Julia applies the correct formula (for a square vs.¬†a circle) because we‚Äôve set up our function to have two actual methods, and it chooses the method to apply based on the type of the argument.\n\n\n\n\n\n\nAdd a method\n\n\n\nCan you define another method for the getArea() function, this time applying to the Rectangle type (which you defined above)? Then call the function using the specific Rectangle you instantiated above.\n\n\n\n\nMultiple Dispatch: When a method depends on multiple arguments to a function\nIn the above example using shapes, we had an example of single dispatch, when the method of a function depends on the type of a single argument. This is common in a variety of computer languages. Julia is unusual in having the concept of multiple dispatch at its core. This is when the method of a function depends on the types of multiple arguments. We‚Äôll develop this idea using an example:\n\nInteracting cats and dogs\n\nstruct Dog\n  name::String\n  age::Int  # Int is an general type for all integer types (e.g. Int64)\n  sound::String \nend\n\nThe above creates a Dog type. Now let‚Äôs make two actual Dogs:\n\nrosie = Dog(\"Rosie\", 3, \"woof\")\nleah = Dog(\"Leah\", 4, \"howl\")\n\nDog(\"Leah\", 4, \"howl\")\n\n\nWe can learn about what is within a certain object in memory by using the ‚Äòdump()‚Äô function (which can be thought of as ‚Äúdumping‚Äù or showing everything in the object):\n\ndump(rosie)\n\nDog\n  name: String \"Rosie\"\n  age: Int64 3\n  sound: String \"woof\"\n\n\nNow let‚Äôs make a Cat type and two instantiated Cats:\n\nstruct Cat\n  name::String\n  age::Int  # Int is an general type for all integer types (e.g. Int64)\n  sound::String \nend\n\nfluffy = Cat(\"Fluffy\", 6, \"meow\")\nmilo = Cat(\"Milo\", 11, \"rarr\")\n\nCat(\"Milo\", 11, \"rarr\")\n\n\nNow that we‚Äôve made some dogs and cats, let‚Äôs define the rules by which they interact:\n\nfunction interact(x::Dog, y::Dog)\n  println(\"$(x.name) wags tail and makes a $(x.sound) toward $(y.name).\")\nend\n\ninteract (generic function with 1 method)\n\n\n\nfunction interact(x::Dog, y::Cat)\n  println(\"$(x.name) chases $(y.name).\")\nend\n\ninteract (generic function with 2 methods)\n\n\n\nfunction interact(x::Cat, y::Dog)\n  println(\"$(x.name) runs from $(y.name).\")\nend\n\ninteract (generic function with 3 methods)\n\n\n\nfunction interact(x::Cat, y::Cat)\n  println(\"$(x.name) stretches and says $(x.sound).\")\nend\n\ninteract (generic function with 4 methods)\n\n\nNow, let‚Äôs call our function:\n\ninteract(rosie, leah)\ninteract(rosie, fluffy)\ninteract(fluffy, rosie)\ninteract(fluffy, milo)\n\nRosie wags tail and makes a woof toward Leah.\nRosie chases Fluffy.\nFluffy runs from Rosie.\nFluffy stretches and says meow.\n\n\nThe above display that the interact() function has four different methods depending on the types of the two input arguments. This is multiple dispatch.\n\n\nImportance of multiple dispatch\nThe examples above are just an initial look at the power of multiple dispatch. If Julia did not have multiple dispatch, then the method of the function call would depend only the first argument (i.e., single dispatch). You could still write a general interact() function code that checks whether the second argument is a Cat, a Dog, etc., and have if statements to govern what to do in the different cases. But multiple dispatch provides an efficient, concise way to ensure just the appropriate code is evaluated, without explicit if statements.\nOne reason it is important to understand multiple dispatch is that it helps you understand how to use built-in Julia functions, and helps you understand errors when you get them. For example, enter this incorrect expression:\nsqrt([9, 4])\nThe REPL responds by saying: ERROR: MethodError: no method matching sqrt(::Vector{Int64})\nIt is telling you that there is no method for the ‚Äòsqrt‚Äô function that uses an input an object of type Vector{Int64} (meaning a vector of integers). If we can understand this message, we might then realize that we have to either enter a single number as input (sqrt(9)) or broadcast over all elements of the vector using the dot operator (sqrt.([9, 4])).\nIf we want to see what methods a function can use, we can use the methods() function:\n\nmethods(interact)\n\n# 4 methods for generic function interact from \u001b[35mMain\u001b[39m: interact(x::Cat, y::Cat) in Main at In[25]:1  interact(x::Cat, y::Dog) in Main at In[24]:1  interact(x::Dog, y::Cat) in Main at In[23]:1  interact(x::Dog, y::Dog) in Main at In[22]:1 \n\n\nThe REPL then tells us that there are four methods and summarizes what types go into them.\nIf curious, you can try this on any function‚Äìfor instance, try methods(+) to see that there are at least 189 methods for the +() function depending on the arguments passed into it.\n\n\n\nNext steps\nThis and the previous pages have brought you through what I consider to be an introductory tour of the central concepts needed to program in Julia. You can use these building blocks to compose programs that do all sorts of complex things‚Äìvirtually anything you can imagine, as long as you can think through the logic of what you want your program to do.\nTwo things though that we have not said much about yet are 1) how to make nice plots, and 2) how to import data in order to analyze and graph it. We will now explore those two topics on the next pages.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Types and Multiple Dispatch"
    ]
  }
]