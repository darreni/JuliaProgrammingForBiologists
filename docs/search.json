[
  {
    "objectID": "IntroToJulia.html",
    "href": "IntroToJulia.html",
    "title": "Quick Introduction to Julia",
    "section": "",
    "text": "Now that we have Julia running, we can learn how to enter expressions that Julia will evaluate.\nThe simplest expressions are just a single number or string of text, e.g.¬†try entering something like:\n\n5\n\n5\n\n\nAfter you type 5 at the julia&gt; prompt and press enter, Julia responds with 5, the returned value of your expression.\nYou can do a little more complex expression:\n\n7 * (6 - 1)\n\n35\n\n\n\nArithmetic operators\nPlay around with other simple mathematical expressions. These are some of the main arithmetic operators, which you are likely familiar with: + , -, *, /, ^. Try using parentheses to control the order of operations (for example: compare the returned value of 3 + 5 / 2^3 and (3 + 5) / 2^3).\nOne that operator that you might be less familiar with is the remainder operator % which gives the remainder of a division. Try it out:\n\n7 % 2\n\n1\n\n\nAnother is the √∑ operator, which produces just the integer part of a division (without the decimal part). You aren‚Äôt likely to use √∑ very often, but I include it here as an example of Julia‚Äôs use of unicode characters (more on this below). To type that character at the Julia prompt, enter \\div followed by the tab key.\n\n\nFunctions\nWe can also use some functions in our expressions. A function is something that does a specific thing defined by code already loaded into memory. You can recognize a function in Julia by the fact that it will be a string of text followed immediately by parentheses, perhaps with inputs to the function inside the parentheses. Here we use the sqrt() function, which produces a square root of the number in the parentheses.\n\nsqrt(16)\n\n4.0\n\n\n\n\nAssigning values to variable names\nEach of the above expressions returns a value that we can give a name and store in memory, using the equal sign =, the assignment operator. For example:\n\nx = 2sqrt(9)\n\n6.0\n\n\nThe above command does several interesting things:\n\nIt evaluates the expression on the right side of the equal sign.\nIt checks whether there is already an object in memory with the name given on the left side of the equal sign (in this case, x). If not, it creates that object.\nIt assigns the value produced by the right side to the object named by the left side.\n\nWe can then use that named object‚Äôs value in subsequent expressions:\n\n4x\n\n24.0\n\n\nAssigning values to named objects allows us to save values in memory and then combine them in our calcuations:\n\npop1 = 50; pop2 = 200; totalPop = pop1 + pop2\n\n250\n\n\nThe semicolons above are used to separate distinct expressions that Julia should evaluate before continuing to the next. This is called a compound expresssion and is a convenient to enter several commands on the same line. Another way to enter a compound expression is with a begin-end block:\n\nbegin\n  x = 17\n  y = x^2\nend\n\n289\n\n\n\n\n\n\n\n\nCalculate the area of a circular forest patch\n\n\n\nPick a number for the radius (in km) of a circle, and assign that to a variable name and store that in Julia‚Äôs memory. Then in a separate command, use that variable to calculate the area of the circle (the standard formula for this is œÄ\\(r^{2}\\); to write the exponent of ‚Äò2‚Äô though, you‚Äôll need to use ‚Äò^2‚Äô). A neat thing is that Julia already knows the value of œÄ; to get it, just type pi or alternatively \\pi then tab.\n\n\n\n\nDifferent Types of numbers\nWhen computers store numbers, they can do it in different ways, each with their advantages and disadvantages. Two main ways that Julia can store numbers are as integers or as floating-point numbers. Integers have exact values but are quite limited in the values they can take, whereas floating-point numbers can take many more values but have a disadvantage that they are not exact.\nWe can learn about the Type that Julia uses to store values by using the typeof() function:\n\ntypeof(3)\n\nInt64\n\n\nJulia responds by saying that the value 3 is of the Int64 type. This means that it is an integer stored in memory using 64 bits. (No worries if you don‚Äôt know what this means.) Now compare to this:\n\ntypeof(3.0)\n\nFloat64\n\n\nJulia responds by sayng 3.0 is of the Float64 type. This means a 64-bit floating-point number. By writing the .0 after the 3 we have told Julia we want this number treated as a floating-point number.\nMuch of the time, we don‚Äôt need to think about variable types, because Julia is smart and handles types through something called dynamic typing. Here‚Äôs an example:\n\na = 2\nb = 3.0\nc = a + b\ntypeof(c)\n\nFloat64\n\n\nAbove, Julia figures that by entering b = 3.0 you are indicating that you want b treated as a floating-point number, so when it adds the integer 2 to this, it returns a floating-point number.\nJulia has all sort of other useful Types of numbers. One that I will point out here is the Rational number type, which you can construct with the // operator and do exact calculations using ratios:\n\nratio1 = 1//3\nratio2 = 5//7\nproduct = ratio1 * ratio2\n\n5//21\n\n\nAs your Julia skills increase, there are large benefits to being somewhat aware of types; this can help you write efficient programs and help with debugging your code. You can even define your own Types.\n\n\nRanges\nJulia has a neat data structure (i.e.¬†a type) to store arithmetic series of numbers:\n\nrangeOfNums = 1:100\nprintln(rangeOfNums)\ntypeof(rangeOfNums)\n\n1:100\n\n\nUnitRange{Int64}\n\n\nJulia stores this range efficiently, until the actual numbers are needed. If we want to actually convert it to the numbers themselves, we could enter something like collect(rangeOfNums)\nIf we want only the even numbers, we enter something like collect(0:2:30).\n\n\n\n\n\n\nCreate a descending vector\n\n\n\nYou have a population of 30 individuals that is decreasing by 3 individuals in each time step. Use the collect() function to create a list of numbers (a.k.a. a vector) representing the population sizes at each time step (until the population goes extinct).\n\n\n\n\nCharacters and Strings\nProgramming in biology often involves manipulating text such as ‚ÄúACGT‚Äù. For this, we can use two other variable types in Julia: characters (officially Char) and strings (officially String), which are usually made up of a series of characters (imagine beads of letters on a string, ha ha).\nWe enter characters with single quotes, and can combine them to make strings:\n\nnucleotide1 = 'T'\nnucleotide2 = 'C'\ndinucleotide = nucleotide1 * nucleotide2\n\n\"TC\"\n\n\nAbove, we create two variables of type Char and combined them (yes, Julia views combining characters or strings as a form of multiplication, ha ha) to produce a String.\n\n\n\n\n\n\nExponents on Strings\n\n\n\nIf Julia uses the * symbol for combining two characters or strings into a longer string, what do you think it might use the ^ symbol for, when applied to a character or string? Make a guess, and then play around and find out.\n\n\nWhen you enter a String into Julia, you need to use double quotes (unlike a Char with single quotes).\n\noligo1 = \"ACGCAT\"\noligo2 = \"CCCTG\"\nligation = string(oligo1, oligo2)\n\n\"ACGCATCCCTG\"\n\n\nThe function string above concatenates different strings together.\n\n\n\n\n\n\nYour favourite species\n\n\n\nAssign a few of your favorite species to different variable names, and then combine them into a single string, with commas separating their names.\n\n\n\n\nUnicode characters\nOne fun thing about Julia is that you can use unicode variables in variable names, strings, function names, and some operators. The motivator for this is to make code read more like humans tend to write mathematics. For example:\n\nœá¬≤ = 30.4\nŒ≤ = 2œá¬≤\n\n60.8\n\n\nTo make the unicode symbols above, you would type \\chi tab \\^2 tab, and on the next line \\beta tab. Notice also that the expression 2œá¬≤ is evaluated the same as 2*œá¬≤ or 2 * œá¬≤.\nUnicode also allows some fun.\n\n\n\n\n\n\nPlant biology using Unicode\n\n\n\nAssign a variable a the value of a Char given by typing \\:seedling: tab. Assign a variable b the value of a Char given by typing \\:deciduous_tree: tab. Then execute this line:\nstring(a, \" grows into \", b)\n\n\nWe can also use unicode symbols in variable names:\n\nüê¨ = 47    # write with: \\:dolphin: tab\nüê≥ = 5     # write with: \\:whale: tab\ntotalMarineMammals = üê¨ + üê≥\n\n52\n\n\nNote the use of the # symbol to make comments to the right of code.\nYou can find how to write a whole bunch of unicode symbols here: https://docs.julialang.org/en/v1/manual/unicode-input/\n\n\nComparisons and Booleans\nIn programming it is often important to check if certain conditions are true or false. These values are called Booleans (of type Bool in Julia).\nThese comparison operators are used to compare two values (place to left and right of the operator), resulting in true or false:\n== : equal?\n!= : not equal?\n&lt; : less than?\n&lt;= : less than or equal?\n&gt; : greater than?\n&gt;= : greater than or equal?\n\nTry a bunch of comparisons of values using the above. These are called Boolean expressions. For example:\n\nsqrt(9) == 3\n\ntrue\n\n\n\nx = 8; sqrt(x) &gt;= 3\n\nfalse\n\n\nWe can use Boolean operators to combine multiple comparisons. These are used as follows, where x and y are Boolean expression:\n!x : not x\nx && y : x and y\nx || y : x or y\n\nFor example:\n\n5 &lt;= 3 && 7 == 14/2\n\nfalse\n\n\n\n5 &lt;= 3 || 7 == 14/2\n\ntrue\n\n\n\n!(5 &lt;= 3 || 7 == 14/2)\n\nfalse\n\n\n\n\n\n\n\n\nSelect the extremes\n\n\n\nWrite a series of commands in which you pick a random number between 0 and 1 with the rand() function, and return true if that number is either above 0.75 or below 0.25, and false otherwise.\n(If you solve the above and have time, can you figure out a way to chain your Boolean expressions into a form similar to value1 &lt; x &lt; value2 ?)\n\n\n\n\nCollections, e.g.¬†Arrays\nVariables can contain more than a single item in them. A general term for such a data structure is a collection. An array is a common type of collection used in Julia: It can be thought of as an n-dimensional lattice of boxes, where you can store something in each box. Below we create some kinds of arrays:\n\narrayA = [7.3, 3, 11.2, -5, 3.2]\n\n5-element Vector{Float64}:\n  7.3\n  3.0\n 11.2\n -5.0\n  3.2\n\n\n\narrayB = [6 5 4; 3 2 1]\n\n2√ó3 Matrix{Int64}:\n 6  5  4\n 3  2  1\n\n\nBecause these variables are more complex data structures that the simple ones we‚Äôve looked at so far, Julia tells you the type of the returned value, before showing you the actual values.\nNote that a Vector is another name (an alias) for a 1-dimensional array, and a Matrix is another name for a 2-dimensional array. Inside the curly brackets, Julia indicates the Type that each element of the array belongs to (this is Float64 in the first case, and Int64 in the second).\nWe can ask Julia to return the values in parts of an array by indexing into the array. For example:\n\narrayA[3]\n\n11.2\n\n\n\narrayA[end]\n\n3.2\n\n\n\narrayB[2, 2:3]\n\n2-element Vector{Int64}:\n 2\n 1\n\n\nWe can even use such indexing to change the value stored one of the ‚Äúboxes‚Äù in an array:\n\narrayB[2, 2] = -129\narrayB\n\n2√ó3 Matrix{Int64}:\n 6     5  4\n 3  -129  1\n\n\nWe‚Äôre going to eventually learn a lot more about arrays, as they are super useful in data science, bioinformatics, and simulations.\n\nTuples\nAnother kind of collection is called a tuple. It is a lot like a vector (a 1-dimensional array) but is immutable. This means that once defined, you cannot change specific values stored in a particular tuple. We create them using parentheses and commas:\n\nmyTuple = (1.3, 2.7, -12)\ntypeof(myTuple)\n\nTuple{Float64, Float64, Int64}\n\n\nThe response tells us that the object we created is of Tuple type, and it tells us the types of each element in the tuple.\nWe can also create named tuples in which we give names to the values:\n\nnt = (base = \"C\", position = 35, chrom = \"Z\")\n\n(base = \"C\", position = 35, chrom = \"Z\")\n\n\nWe can get the value of a certain element by using that name, like this:\n\nnt.base\n\n\"C\"\n\n\nThe above is one of the uses of the ‚Äú.‚Äù symbol, to access a named element within a tuple. (Another use, quite different, is described after the next heading below).\nTuples are useful for storing and calling fixed bits of info together. Because they are not mutable, Julia can store and use them in a more efficient way than arrays. They are also used when calling functions (we‚Äôll explore this later).\n\n\n\nBroadcasting\nWe often want to apply an operation or function to each element of an array. In Julia this is called ‚Äúbroadcasting‚Äù and is accomplished by the humble ‚Äúdot‚Äù operator: .\nWe can put this dot in front of any arithmetic operator to make the operator apply to each element of a collection:\n\narrayB.^2\n\n2√ó3 Matrix{Int64}:\n 36     25  16\n  9  16641   1\n\n\n\n3 .* [5, -1, 3]\n\n3-element Vector{Int64}:\n 15\n -3\n  9\n\n\nWe can also put this dot right after a function to have the function apply to each element in a collection:\n\nsqrt.([64 25 36])\n\n1√ó3 Matrix{Float64}:\n 8.0  5.0  6.0\n\n\n\n\nMacros\nMacros are a kind of function that takes text as input and converts it to code that is then evaluated. They are a somewhat advanced topic in terms of developing a full undertanding. For now, I just want to mention them because some are hugely useful even when starting out. As an example, if you are doing a lot of ‚Äúdot‚Äù operations, you can use the @. macro to convert all the operators in a line to dot operators:\n\nbegin\n  data = [3 7 -4 9]\n  results = @. 2data + data^2\nend\n\n1√ó4 Matrix{Int64}:\n 15  63  8  99\n\n\nThe line with the @. macro produces the same output as:\n\nresults = 2 .* data .+ data.^2\n\n1√ó4 Matrix{Int64}:\n 15  63  8  99\n\n\nAnother useful macro is @time :\n\n@time sum(rand(1000))\n\n  0.000015 seconds (1 allocation: 7.938 KiB)\n\n\n495.52857724767836\n\n\nThe rand(x) function produces x random numbers between 0 and 1. The above returns the sum of 1000 such numbers. Julia tells you the time it took, followed by the sum.\n\n\n\n\n\n\nEven more numbers!\n\n\n\nModify the above code so that it takes the square of each of one million random numbers between 0 and 1, and then adds them up.\n\n\n\n\nDefining your own functions\nJulia facilitates the writing of your own functions. This can have huge benefits in terms of organizing your programs and making them efficient. There are several ways to define them:\n\nsumSqrtRands(x) = sum(sqrt.(rand(x)))\n\nsumSqrtRands (generic function with 1 method)\n\n\nWe‚Äôve defined that function. Now we can use it:\n\n@time sumSqrtRands(1_000_000)\n\n  0.008989 seconds (4 allocations: 15.259 MiB)\n\n\n666713.0488122834\n\n\nBelow demonstrates another way to write functions, in this case with two arguments (things you pass into the function, called parameters inside the function):\n\nfunction xSquaredPlusY(x, y)\n  x^2 + y\nend\n\nxSquaredPlusY (generic function with 1 method)\n\n\nTry calling that function a few times, with different values of x and y, e.g.:\n\nxSquaredPlusY(3, -2)\n\n7\n\n\n\n\n\n\n\n\nApply your function to many elements at once\n\n\n\nCan you figure out how to call the above function in a way where you can input a series of numbers as the first argument (for example, x = [1, 3, 7]), and -2 as the second argument? (Hint: if you get an error, reviewing the Broadcasting section above might help)\n\n\n\n\nPackages\nThousands of people around the world have contributed over 10,000 packages that extend functionality of Julia. Installing these packages is easy.\nFirst, enter the package mode of the REPL by typing the right square bracket symbol ] . You will then see the julia&gt; prompt change into a prompt that looks something like (@v1.10) pkg&gt; . Then, type a command to add a package, e.g.:\nadd Plots\nThis tells Julia to download and install the officially registered package with that name. The Plots package is a big one, so this can take some time.\nTo get out of package mode, press the ‚Äúdelete‚Äù key and this will return you to the normal Julia REPL mode.\nTo actually use the Plots package, we need to load it into the memory for this Julia session. To do that, simply write:\n\nusing Plots\n\nNow, let‚Äôs use a function called plot() that is included in this Plots package. Try:\n\nx = -5:5\ny = x .^ 2\nplot(x, y)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis will likely open another window on your computer, and show a plot. (If not, don‚Äôt worry; we‚Äôre going to set up another good way to plot in the next page.)\nIf the above worked, you can see another way to run the plot() function here:\n\nf(x) = x^2\nplot(f)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn our first use of the plot() function above, we passed in two argument, both vectors of numbers. In the second, we passed in just a mathematical function, and plot() figured out a good way to show us the mathematical relationship represented by that function.\nThis flexibility in function calls is an example of multiple dispatch, a key feature of Julia. We‚Äôll come back to this topic in the future.\n\n\nNext steps\nWe‚Äôve now learned a lot of basic concepts related to Julia programming, and it is now time to put them together in more complex ways. For that, we‚Äôll learn how to use Pluto notebooks on the next page. This will enable to write longer programs and organize and save them.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Quick Introduction to Julia"
    ]
  },
  {
    "objectID": "InstallJulia.html",
    "href": "InstallJulia.html",
    "title": "Download and Install Julia",
    "section": "",
    "text": "To download and install Julia, go to this URL and follow instructions: https://julialang.org/downloads/\nThat website will likely detect your operating system and suggest the right approach.\nIf you have a Mac, the above will direct you to simply open a Terminal window (look for the Terminal application in your Applications/Utilities directory) and type the command below at the Terminal prompt:\ncurl -fsSL https://install.julialang.org | sh\nThe above command installs the Juliaup installation manager, which is a wonderful tool to help update Julia and keep different versions (if you wish) available on your computer.\n\nNow, run Julia!\nIn the Terminal window, type julia at the prompt. After some time (only the first time you do this), you should see a julia logo and a prompt saying julia&gt; . This means Julia is installed and running.\nTry typing a simple calculation, e.g.¬†1 + 3 then Enter or Return, and see what happens.\nNow try entering \"Hello, nice to meet you\" (make sure you put the quotes).\nWith the above, you are using the REPL, the Read-Evaluate-Print-Loop. This is a common way of running Julia. (Another way is to save scripts and execute them, but that is usually for more advanced use.)\nNow, go to the next page to learn more about interacting with Julia.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Download and Install Julia"
    ]
  },
  {
    "objectID": "PlutoNotebooks.html",
    "href": "PlutoNotebooks.html",
    "title": "Pluto Notebooks",
    "section": "",
    "text": "Now that we know how to use the Julia REPL to interact with Julia and are building our understanding of programming, we likely want an environment in which we can compose programs and save them for use later. Pluto notebooks provides a reactive notebook environment for doing this.\n\nInstall Pluto\nPluto is a package that we install into Julia in the same way as we did with the Plots package (on the last page):\nType ] to enter the package mode, then input this:\nadd Pluto\nThis downloads and installs everything needed for Pluto to run (which is quite a bit, so may take some time).\nWhen done, press ‚Äúdelete‚Äù to return from package mode to the REPL. Then type these two commands:\nimport Pluto\nPluto.run()\nEventually (and if your computer works the same as mine), a browser window will open that says ‚Äúwelcome to Pluto.jl‚Äù at the top.\n\n\nCreate your first notebook\nClick on ‚ÄúCreate a new notebook‚Äù (Under the heading ‚ÄúMy Work‚Äù).\nYou will then see a mostly blank page that says ‚ÄúPluto.jl‚Äù in the upper left. Below that there is a line with faint text that says ‚ÄúEnter cell code‚Äù. Try entering a simple Julia expression there to assign a value to a variable (e.g.¬†something like a = 7^2) and then press Shift + Enter to tell Pluto to evaluate the cell.\nPluto then returns the result of your expression above the cell.\nLet‚Äôs add another cell by clicking the little ‚Äú+‚Äù sign below the first cell. In this new cell, enter an expression that creates a second variable and assigns to it a calculation involving your first variable (e.g.¬†b = a - 3). You will see again see the result above the cell.\nNow, edit the first cell to change the value assigned to a, and press Shift + Enter. You will see the returned value of a change, and the value of b changes too. This is what it means to be reactive: any change in your notebook propogates through the entire notebook in a logical way. The whole notebook then is like a single program.\n\nPluto notebooks are not dependent on cell order\nTry switching the order of your two cells, by simply hovering your pointer to the left of one of the cells, and then dragging it up or down. Now play around with the code in the cells. You will see that the results do not depend on cell order.\nThis allows you to organize notebooks in whatever way you want. You have the option of having the final result at the top, with supporting code lower down.\n\n\nConsequences of movable cell blocks\nThere are a couple important consequence of the above. One is that we cannot have two statements that assign to the same variable in two different cells. For instance, if you say a = 1 in one cell and a = a + 1. (Try it! Pluto will respond with an error and suggest a solution.) Instead, we can use begin-end blocks to group code in which a single variable is assigned a series of values in succession:\n\nbegin\n    myVar = 1\n    myVar = myVar + 5\nend\n\n6\n\n\nA related principle is that each cell block can only contain a single expression. (However, an expression can be quite big if it contain a begin-end block.) This ensures Julia can figure out which cells depend on which.\n\n\n\nSave your notebook\nLet‚Äôs save our notebook so we can open it later and use it again. At the top of the page, click on ‚ÄúSave notebook‚Äù. You can then choose a folder and enter a file name (e.g.¬†something like ‚ÄúMyFirstPlutoNotebook.jl‚Äù wouldn‚Äôt be a terrible choice). It is good to give your notebook a ‚Äú.jl‚Äù extension, which indicates a file written in Julia.\nIf you now leave your notebook by clicking on the ‚ÄúPluto.jl‚Äù logo in the upper left, you should see that the notebook you just saved is listed under ‚ÄúMy Work‚Äù. Click on that notebook name, and it will open your notebook again.\n\n\nPluto files are valid Julia files\nA nice thing about working in Pluto is that the file that you are saving is 100% runnable as a Julia file (without using Pluto).\n\n\nPluto has no ‚Äúhidden state‚Äù\nA way that Pluto differs from some other notebook environments (e.g.¬†Jupyter) is that the program state is completely described by the code in the notebook. You don‚Äôt have to wonder if each cell has been executed‚Äìthe entire notebook is affected by any change you make (although Julia is clever and for efficiency figures out what cells depend on that change).\n\n\nMake a plot in Pluto\nPluto can show all sorts of output from your code. For instance, try making a plot. We first need to install the Plots package into our Pluto environment:\n\nusing Plots\n\nIf you have not downloaded the Plots package, Pluto will nicely do it for you.\nNow, lets generate some data and graph it:\n\nbegin\n  numPoints = 10\n  xValues = randn(numPoints) # random draw from standard normal distribution\n  yValues = xValues .+ 0.5 .* randn(numPoints)\n  scatter(xValues, yValues)\nend\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou will likely see a scatter plot of 10 data points. The data generation involved random draws from a standard normal distribution, so your graph won‚Äôt look exactly the same as the one shown here.\n\n\n\n\n\n\nAdd a lot more points\n\n\n\nCan you figure out how to modify the above to get 1000 data points? Try it!\n\n\n\n\nAdd text using Markdown\nYou can add headers and comments to your notebook using Markdown, simply by entering md and then double quotes surrounding your text. Create a new cell at the top of your notebook and enter this:\nmd\"# _Welcome to my notebook!_ \n\nThis is a Pluto notebook for programming in the Julia language. Pluto notebooks are **reactive** to changes you make.\n\"\nYou can hide the code producing that text by clicking on the little eye symbol left of the code cell.\nWe can incorporate Julia expressions into our Markdown comments by preceding it with a $ symbol:\nmd\"There are $numPoints data points in the graph\"\nnum = 4; md\"The square of $num is $(num^2) .\"\n[Note that if you want the above Markdown commands to work outside of Pluto, e.g.¬†in a regular Julia REPL, you have to add the Markdown.jl package. Enter package mode with ], then enter add Markdown, then press ‚Äúdelete‚Äù to return to REPL, then enter using Markdown.]\n\n\nNext steps\nNow that we have a good envirnoment set up to write and save more complex programs, we‚Äôll learn about control flow, the way you can design a program to do different sets of code depending on the state of one or more variables.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Pluto Notebooks"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Julia Programming For Biologists",
    "section": "",
    "text": "Welcome! I am starting this website on January 11, 2024, for the purpose of teaching tutorials about the Julia programming language, in the context of biology.\nJulia is a relatively new programming language (started around 2012; first official release in 2018) that is both highly readable (by humans) and fast. This is intended to solve the ‚Äú2-language‚Äù problem, a common workflow in which development of a new program is done first in a highly readable language (e.g., R or Python) and then converted by an expert programmer into a fast language (e.g., C), such that the resulting code can be difficult to read by non-experts. Hence Julia aims to be a language that provides easy entry for new programmers while also having the power and efficiency to appeal to experts. It is used by NASA, Moderna, Pfizer, and many other organizations, and is used widely by scientists doing climate modelling of Earth and imaging black holes in distant galaxies.\nIf you are in doubt that you need a faster or more readable language than the one you are using, ask yourself this: Have you ever heard other scientists mention how long their bioinformatic processing or evolutionary simulations can take? It is often on the scale of days, weeks, months. What if that were instead minutes, hours, days? How might that accelerate your research, and allow you to expand the scope of your science? Have you ever heard someone say ‚ÄúI can‚Äôt program‚Äù? Did they decide that because they are fundamentally unable to learn the logic of programming, or because many of the languages often taught in programming are really difficult to learn?\nI have used Julia in my own work for about 2 years now, after having much experience with Matlab and then R, and dabbling a bit in Python, C, C++, and Java. The developers of Julia have praise for aspects of all of these languages, and their goal was to combine all the good aspects into one efficient and readable language. I think they have succeeded marvelously.\nMy intended audience with these tutorials is biologists with no or little previous programming experience, who are interested in building their data science, bioinformatic, and statistics skills, or who even want to design their own mathematical models and simulations. My goal is to get you programming quickly, givig just enough underlying explanation of computer science principles to enable fast progress.\nThis is a work in progress, and we‚Äôll see where it goes . . .\n\n\n\n\n\nTo advance through pages of the tutorial, click on the right arrow below.",
    "crumbs": [
      "Home",
      "Basics",
      "Home"
    ]
  },
  {
    "objectID": "ControlFlow.html",
    "href": "ControlFlow.html",
    "title": "Control Flow: Loops and Ifs",
    "section": "",
    "text": "So far, what we have learned might be called coding, the way your write commands that do a fixed set of instructions. To do true programming we need to know how to write scripts in which the exact sequence of commands is determined dynamically. This is called control flow.\n\nLoops: for and while\nLoops are very useful in programming, because we often want to do a set of commands multiple times. For example:\n\nfor ice in 1:10\n  iceCubed = ice^3\n  println(\"The cube of \", ice, \" is \", iceCubed)\nend\n\nThe cube of 1 is 1\nThe cube of 2 is 8\nThe cube of 3 is 27\nThe cube of 4 is 64\nThe cube of 5 is 125\nThe cube of 6 is 216\nThe cube of 7 is 343\nThe cube of 8 is 512\nThe cube of 9 is 729\nThe cube of 10 is 1000\n\n\nHere we‚Äôll use a random integer to determine how many times to do a loop:\n\nrand_times = rand(1:10)  # This returns a random integer in the range 1 to 10\nfor i in 1:rand_times\n  println(i)\nend\nprintln(\"I counted to $rand_times\")\n\n1\n2\n3\n4\n5\n6\nI counted to 6\n\n\nNote that the $ in the last line above causes string interpolation of the expression to the right of it.\n\n\n\n\n\n\nTeach Julia to Sing\n\n\n\nWrite a script that produces the song ‚Äú99 bottles of beer on the wall.‚Äù This song goes like ‚Äú99 bottles of beer on the wall, 99 bottle of beer, you take one down and pass it around, 98 bottles of beer on the wall; 98 bottles of beer on the wall, 98 bottles of ‚Ä¶‚Äù and so forth that all the way down. (I don‚Äôt think anyone has ever completed the song . . . Can your program succeed in doing so?)\n\n\nAn interesting thing about for loops is that the iterator variable is internal to the loop (not ‚Äúknown‚Äù outside of the loop):\n\ni = 27\nprintln(\"Before the loop, i = $i\")\nfor i in 1:3\n  println(\"Inside the loop, i = $i\")\nend\nprintln(\"After the loop, i = $i\")\n\nBefore the loop, i = 27\nInside the loop, i = 1\nInside the loop, i = 2\nInside the loop, i = 3\nAfter the loop, i = 27\n\n\n\nfor loops can iterate across many kinds of collections\nYou can iterate across all sorts of things, for example a matrix of strings:\n\nspeciesGrid = [\"warblers\" \"flamebacks\" \"sticklebacks\"; \n              \"sparrows\"  \"guppies\" \"digital organisms\"] \nfor i in speciesGrid\n  println(\"We study $i.\")\nend\n\nWe study warblers.\nWe study sparrows.\nWe study flamebacks.\nWe study guppies.\nWe study sticklebacks.\nWe study digital organisms.\n\n\nInstead of the in in the for line, you can use the unicode character ‚àà (produced by typing \\in tab), which is a mathematical symbol meaning ‚Äúis an element of‚Äù. :\n\nmySet = [\"banana\", 5.3, 'üê¨']  # get the dolphin with \\:dolphin: tab\nfor thing ‚àà mySet\n  println(thing)\nend\n\nbanana\n5.3\nüê¨\n\n\n\n\nNested loops\nOften it is useful to have nested loops. For instance, to produce all dinucleotide combinations:\n\nbases = ['A', 'C', 'G', 'T']\nfor i in bases\n  for j in bases\n    print(i, j, \", \")\n  end\nend\n\nAA, AC, AG, AT, CA, CC, CG, CT, GA, GC, GG, GT, TA, TC, TG, TT, \n\n\nYou can produce the above more concisely by putting both iterator statements on the same line:\n\nbases = ['A', 'C', 'G', 'T']\nfor i in bases, j in bases\n  print(i, j, \", \")\nend \n\nAA, AC, AG, AT, CA, CC, CG, CT, GA, GC, GG, GT, TA, TC, TG, TT, \n\n\n\n\n\n\n\n\nProduce all trinucleotides\n\n\n\nCan you modify the above to produce all possible trinucleotides (i.e., 3-base nucleotides)?\n\n\n\n\nwhile loops\nLet‚Äôs say you don‚Äôt know in advance how many times you want to go through a loop. Rather, you want to stop the loop when some condition is met. The while loop is perfect for that:\n\nsum = 0\nwhile sum &lt;= 21  # inspired by a card game\n  sum = sum + rand(1:10)\n  println(sum)\nend\n\n8\n11\n20\n29\n\n\n\n\n\n\n\n\nSimulate dispersal of an organism\n\n\n\nYou are writing a simulation in which individuals move from their birth site to their breeding site, along a continuous range of length 1. The dispersal distance is drawn from a standard normal distribution, given by randn(), with the constraint that they are not allowed to move outside of the range. If an individual is born at location 0.7, write a script that determines its breeding location within the range (lowest possible value = 0; highest possible value = 1).\n\n\n\n\n\nCompound expressions\nA compound expression is a single large expression that is made up of multiple sub-expressions that are evaluated in order. When the compoud expression is evaluated, only the value generated by the last sub-expression is returned. There are basically two ways to generate compound expressions:\n\nUse a semicolon (;) chain\n\nx = 4; y = 3; x + y\n\n7\n\n\nThe above returns the value of the last subexpression, but it does remember values assigned in the earlier subexpressions. (To prove this to yourself, enter x to see its value.)\nYou can use compound expressions as part of even larger expressions, e.g.:\n\nmyVar = (x = 4; y = 3; x + y)\n\n7\n\n\nThere, the compound expression in parentheses is evaluated and the resulting value is assigned to myVar.\n\n\nUse a begin block\nThe above compound expression is equivalent to the one below:\n\nmyVar2 = begin x = 4; y = 3; x + y end\n\n7\n\n\nThe use of begin blocks is particularly useful when dividing expressions between multiple lines:\n\nbegin\n  string1 = \"Phylloscopus\"\n  string2 = \"trochiloides\"\n  string1 * \" \" * string2\nend\n\n\"Phylloscopus trochiloides\"\n\n\n\n\n\nConditional evaluation: if and ? :\nOften in our programs we want to execute some commands only if a condition is met. For this, we can use an if - elseif - else block:\n\ncoinflip = rand([\"heads\", \"tails\"])\nif coinflip == \"heads\"\n  println(\"Heads--You win!\")\nelseif coinflip == \"tails\"\n  println(\"Tails--You lose :(\")\nelse \n  println(\"The coin has a strange value\")\nend\n\nHeads--You win!\n\n\nIn an if block, the elseif and else parts are optional, but the end is essential. The indentation is customary and makes the code easier to read, but is not required. The value of the conditional expressions (e.g., just to the right of if) must be of type Bool, meaning either true or false.\n\n\n\n\n\n\nDetermine homozygote or heterozygote\n\n\n\nWrite a script in which you assign a diploid genotype to a variable, with the genotype encoded as a 2-element vector containing strings (e.g., [\"A\", \"C\"] or [\"A\", \"A\"]), and then the script tells you whether the genotype is homozygous (the two elements are the same) or heterozygous (the two elements are different). (Hint: Remember how to access one element of a vector, e.g.¬†x[1] gives just the first element of x; Remember how to ask if two things are equal: ==)\n\n\nIn Julia, if blocks return a value. You can make use if that to do something like this:\n\nhomozygote = true\ngenotype = if homozygote\n             \"TT\"\n           else\n             \"TG\"\n           end\n\n\"TT\"\n\n\n\nTernary operators\nThe ternary operator, consisting of a ? and : separating three expressions (hence ‚Äúternary‚Äù), can be thought of as a consise form of an if - else block. For instance, this is equivalent to the above:\n\nhomozygote ? \"TT\" : \"TG\"\n\n\"TT\"\n\n\nThis can be thought of as ‚ÄúTrue or false‚Äù ? ‚ÄúDo this if true‚Äù : ‚ÄúDo this if false‚Äù\n\n\n\n\n\n\nDetermine whether a number is positive or negative\n\n\n\nAssign a non-zero number to a variable, and then use a ternary operater to report whether the number is positive or negative.\n\n\n\n\n\nShort-circuit evaluation\nAnother way of constructing conditional evaluations is to use the && and || operators (which mean logical ‚Äúand‚Äù and logical ‚Äúor‚Äù). These operators come between two sub-expressions which are evaluated in order from left to right. Julia is efficient and only evaluates the rightmost sub-expression if it needs to (this is why it is called short-circuit evaluation: the evaluation doesn‚Äôt always extend to the right sub-expression). Hence:\n\nIn a && b, b is evaluated only if a is true (because otherwise the whole statement is definitely false)\nIn a || b, b is evaluated only if a is false (because otherwise the whole statement is definitely true)\n\nThe interesting thing is that the b subexpression does not have to produce true or false. Rather, it can do anything you want, and is only executed depending on whether a is true. For example:\n\nx = 5\nx &gt; 0 && println(\"x is positive\")\n\nx is positive\n\n\nTry changing x above to a negative value and run the above again.\nI think of the above construction as ‚ÄúCheck if true AND (only if true) do this thing.‚Äù\n\ny = 3.2\ny &lt;= 0 || println(\"x is positive\")\n\nx is positive\n\n\nAgain, try changing the value of y to a negative value and run again.\nI think of the above as ‚ÄúCheck if true OR (only if not true) do this thing.‚Äù\nThe above expressions may take a while to get used to. You don‚Äôt have to use them, as you might find the if block a lot more intuitive. But you may see these expressions in code that others have written, so it is good to understand them.\n\n\nNext steps\nNow that we have have developed an understanding of loops and conditional evaluation, we are ready to learn more about functions, types, and multiple dispatch in Julia. Together, these concepts can be thought of as methods of control flow. They enable powerful and fascinating approaches to programming.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Control Flow: Loops and Ifs"
    ]
  },
  {
    "objectID": "Plots.html",
    "href": "Plots.html",
    "title": "Plots",
    "section": "",
    "text": "Plotting is a huge topic. Here I‚Äôll do my best to give you an efficient introduction to key concepts and commands, equipping you with the tools to build plots of arbitrary complexity. My emphasis here is on ‚Äòlow-level‚Äô commands (e.g.¬†draw a point, draw a line), rather than ‚Äòhigh-level‚Äô commands (e.g.¬†make a polished fancy plot in a single command). I emphasize the former because it will give you the confidence and power to develop plots to do whatever you want, and it is easy to learn the high-level commands later.\nThere are a number of different plotting packages in Julia, many of them excellent in different ways. Here we will use the ‚ÄòPlots‚Äô package because it is perhaps simplest to work with and is most integrated (or composable) with other packages in the Julia ecosystem. (After some experience with this package, a lot of your knowledge will be transferable to other packages.)\n\nAdd the Plots package\nIf you haven‚Äôt already done so (perhaps you did this several pages prior), install the Plots package as follows:\nIf using the REPL, type ] to activate the Package mode, then enter add Plots . Then press the delete key to return to the REPL, and enter using Plots.\nIf using Pluto, simply type add Plots in a code cell and then shift-enter to execute the cell.\nThese steps might take quite a bit of time because the package and its dependencies are big.\n\n\nMake a simple plot\nWe‚Äôll make a simple plot and learn some of the functions involved.\n\nDraw some lines\nLet‚Äôs define some x values and y values of points, and then plot them by connecting those points with lines:\n\nusing Plots\nxValues = [1.5, 1.8, 2.3, 2.7, 3.2, 3.5]\nyValues = [2.8, 2.5, 2.3, 2.3, 2.5, 2.8]\nplot(xValues, yValues, linewidth=3)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSo we drew some lines between the points defined those coordinates.\n\n\nDraw some points\nNow, let‚Äôs say we want to add some points to the same plot. We can use scatter!() :\n\nscatter!([2.1, 2.9], [3.5, 3.5])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe ! in the scatter!() function is used to indicate that this function will change the existing plot (rather than make a new plot).\n\n\nDraw a shape\nNow, let‚Äôs add a filled shape to the same plot:\n\nplot!(Shape([2.4, 2.5, 2.6], [2.9, 3.1, 2.9]))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere, we created a Shape object and fed that as an argument to the plot!() function.\nAs the plot was updated, you can see that the Plots package adjusted the limits of the x and y axes to fit the plotted points. We can control that ourselves:\n\nplot!(xlim = [1, 4], ylim = [2, 4])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou can change just about anything in the plot\nWe can adjust all sorts of other things about the plot. For instance, add axis labels and a title, and remove the legend:\n\np1 = plot!(title = \"A happy plot\",\n    xlabel = \"My x axis\",\n    ylabel = \"My y axis\",\n    legend = false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo find out more about attributes of plots and how to change them, type ??plot in the Julia REPL (the first ? will activate the help mode, and then enter ?plot).\nIn the last code block above, we both generate a plot and assign it to the name p1, which gives us a way to invoke it later (you‚Äôll see why further below).\n\n\n\nShow mathematical functions\nAbove, we fed the plot function a set of x and y values. We can also feed it a function, and it will do its best to provide a reasonable plot of the function:\n\nplot(sin)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can add some more functions to the plot:\n\nplot!(x -&gt; 3cos(x))\np2 = plot!(x -&gt; (x^2 - 5))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the above, the arguments given to plot!() are anonymous functions. This means that are not given names and are not stored in memory. Rather, the syntax x -&gt; f(x) simply provides a mapping of x onto y values, and the plot!() function interprets that and shows us a part of the relationship.\n\nAdd text to the plot\nWe can use the annotate!() function to add text to our plot, at the desired coordinates:\n\nannotate!(-3, 10, \"Here's some text\", :left)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis adds text at location -3, 10 and the :left indicates that it should be left-aligned to that location.\n\n\nParametric plots\nAnother way we can invoke a plot is to provide it two functions, both of which depend on a variable that ranges from a minimum value to a maximum value. We call the function in this format: plot(x_function, y_function, minimum, maximum) :\n\nplot(sin, cos, 0, 2pi)\nplot!(aspect_ratio = :equal)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot(x -&gt; x*sin(x), x -&gt; x*cos(x), 0, 2pi)\np3 = plot!(aspect_ratio = :equal, legend=false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3D plots\nWe can expand from the above to 3 dimensions:\n\ntime = 0:0.1:20\nxvals = sin.(time)\nyvals = cos.(time) \nzvals = time\np4 = plot(xvals, yvals, zvals)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSurface plots\nThis is one kind of 3D plot, where we have a value for z at every value of x and y:\n\nxes = -1:0.01:1\np5 = surface(xes, xes, (x, y) -&gt; x^2 + y^2, legend=false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere, the first argument is the x values, the second is the y values, and the third is the z values, which in this case we provided as an anonymous function relating x and y to z.\n\n\nHeatmaps\nWe can show the above as a heatmap:\n\np6 = heatmap(xes, xes, (x, y) -&gt; x^2 + y^2)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\nThere are many other kinds of plotting commands. Keep in mind though that if it is difficult to find a high-level command to do exactly what you want, the low-level commands for plotting points, lines, and shapes along with some good logical thinking will result in anything you can imagine!\n\n\n\nLayouts\nWe can combine separate plots into one figure quite simply. We first define each plot and assign it a name, resulting in it being stored as an object in memory. Then, we assemble these into a figure.\nAbove, we defined a series of plots and gave them the names p1 through p5. We‚Äôll now call the `plot() function in a way that causes some of these to be plotted as panels in one graphing window:\n\nplot(p1, p2, p4, p5)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBecause we have provided four plots to be shown, the default assumption is that we want a 2x2 grid. We can alter this by using the layout keyword and grid() functions:\n\nplot(p1, p3, p6, layout = (1, 3))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\nTry switching the 3 and 1 to see what you get.\n\nplot(p3, p4, p6, p5, layout = grid(2, 2, heights=[0.4, 0.6], widths=[0.3, 0.7]))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe @layout macro\nEarlier, we learned about how the @ symbol is used to indicate a macro, something that is a tool to write non-standard code that is then re-written by the macro into actual Julia code. You can think of it as a convenient shortcut. The @layout macro is a wonderful example:\n\nplot(p1, p2, p3, p4, p5, p6, \n    layout = @layout [ s s s\n                        s s\n                         s])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\nAfter the @layout, we simply write brackets within which is a visual representation of the layout of the plot. The s symbol here is arbitrary‚Äìyou can use whichever letter you want‚Äìthe key thing is that the pattern of white space and line breaks between the symbols conveys to the macro what the layout arrangement should be.\nIf we want our sub-plots to take up differing amounts of space, we can add that in this way:\n\nbigPlot = plot(p4, p5, p1, p2, p3, p6, \n                layout = @layout [ s s s\n                                s{0.8w} s\n                                s{0.2h}])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\nThe {0.8w} and {0.2h} mean that that subplot should take up 0.8 proportion of the width or 0.2 proportion of the height.\n\n\n\nSave your plot\nWe can now save the plot, and give a path/filename that ends by designating the format (e.g.¬†pdf, png, jpg):\nsavefig(bigPlot, \"myplot.pdf\")\n\n\nNext steps\nThis has been a quick intro to plotting, but I hope it gives a good idea of the rich capability of the Plots package and how to get started producing your own plots in Julia.\nNow let‚Äôs jump into a full data analysis. We‚Äôll learn how to import data into Julia, do a bunch of processing and calculations, and graph results.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Plots"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site:\nI am a Professor of Zoology at the University of British Columbia. To learn more about my research, go to: https://www.zoology.ubc.ca/~irwin/irwinlab/\nDisclaimer: I am mostly self-taught in the areas of programming and computer science, so there are definitely better sources to learn about those topics. My goal here is to convey the usefulness of Julia to other biologists.\nThanks: I have benefitted greatly from many excellent courses available from organizations such as Compute Canada, the Digital Alliance of Canada, and UBC Advanced Research Computing. I also thank the many YouTubers, bloggers, and book authors who provide excellent information about Julia and other languages. And of course I thank the inventors of Julia (you can learn more at https://en.wikipedia.org/wiki/Julia_(programming_language)).\nThis whole website was generated using Quarto, which allows embedding of runnable Julia code.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.",
    "crumbs": [
      "Home",
      "Basics",
      "About"
    ]
  },
  {
    "objectID": "LoadData&Analyze&Graph.html",
    "href": "LoadData&Analyze&Graph.html",
    "title": "Load & Graph Data",
    "section": "",
    "text": "Here we‚Äôll bring together much of our Julia knowledge to actually analyze a large dataset.\nThe example here will be based on a dataset from this paper:\nMcCallum, Q., K. Askelson, F.F. Fogarty, L. Natola, E. Nikelski, A. Huang, and D. Irwin. 2024. Pronounced differentiation on the Z chromosome and parts of the autosomes in crowned sparrows contrasts with mitochondrial paraphyly: implications for speciation. Journal of Evolutionary Biology, voae004, https://doi.org/10.1093/jeb/voae004\nWe will load in a large dataset of genotypes throughout the genomes of Golden-crowned Sparrows and two forms of White-crowned Sparrows: pugetensis and gambelii. We will then use my own custom-designed Julia package called SNPlots.jl to analyze and graph aspects of this dataset.\nTo work through this example, start with a new Pluto notebook. Give it a name and save it, so your work will be continuously saved. You will need a set of files that I will send you‚Äìthese include one file for the SNPlots.jl package of functions and four data files within a folder called Sparrow_data_McCallumetal2024.\n\nSet the working directory\nFirst, set the working directory to match the folder that I sent you called JuliaPlutoDemoSNPplots :\ncd(\"PATHNAME/JuliaPlutoDemoSNPplots\") # where PATHNAME is appropriate to your computer directory structure\n(The Julia function cd() changes directory.)\nCheck that the working directory is now set correctly, using the pwd() function (print working directory):\npwd()\n\n\nLoad the SNPlots package\nI wrote this set of functions to facilitate the analysis of and graphing of genomic data. The scope is quite modest so far, mainly targeted towards producing certain figures that I wanted in our papers.\nThe SNPlots package is not yet released to the world, so please don‚Äôt spread widely yet. I anticipate releasing it when the first paper is published using figures it produces.\nWe first need to load two packages used by SNPlots:\nusing MultivariateStats # for doing Principal Compponents Analysis\nusing CairoMakie # the plotting package used by SNPlots.jl\nNow load SNPlots:\nbegin\n    include(\"SNPlots.jl\")\n    using .SNPlots\nend\nThis way of loading a package is appropriate when the source file is on your local computer (rather than being a registered Julia package).\nTo confirm that the SNPlots package is loaded, enter this:\nSNPlots.greet_SNPlots()\nYou should receive a greeting. üòÑ\n\n\nSet up the paths and data file names\nbegin\n    genotype_file_name = \"Sparrow_data_McCallumetal2024/SparrowDemo_genotypes.012\"\n    individuals_file_name = genotype_file_name * \".indv\"\n    position_file_name = genotype_file_name * \".pos\"\n    metadataFile = \"Sparrow_data_McCallumetal2024/SparrowDemo.Fst_groups.txt\"\nend\n\nLoad three more packages for importing data\nThese are for storing data as type DataFrame, and reading in delimited files:\nusing DataFrames, CSV, DelimitedFiles\n\n\n\nEnough setup, let‚Äôs load data!\nFirst import metadata about thee samples:\nmetadata = DataFrame(CSV.File(metadataFile))\nAbove, the CSV.file() function interprets the correct delimitation format of the data file, and the DataFrame() function creates a DataFrame object (a wonderful way to store data where columns are variables and rows are individuals).\nNow, Import the list of individuals (row names) of the genotype matrix:\nbegin\n    ind = DataFrame(CSV.File(individuals_file_name; header=[\"ind\"], types=[String]))\n    indNum = size(ind, 1) # number of individuals\nend\nCheck that the metadata file and .indv file have same number of individuals:\nif nrow(metadata) != indNum\n    println(\"WARNING: number of rows in metadata file different than number of individuals in .indv file\")\nelse println(\"Good news: number of rows in metadata file matches the number of individuals in .indv file\")\nend\nCombine individual names and metadata into one data structure (enabling confirmation that names match and are in correct order):\nind_with_metadata = hcat(ind, metadata)\nLoad SNP positions:\npos_whole_genome = DataFrame(CSV.File(position_file_name; header=[\"chrom\", \"position\"], types=[String, Int]))\nLoad the genotype matrix:\nbegin # read in genotype data \n    @time geno = readdlm(genotype_file_name, '\\t', Int16, '\\n')\n    loci_count = size(geno, 2) - 1   # because the first column is not a SNP (just a count from zero)\n    print(string(\"Read in genotypic data at \", loci_count,\" loci for \", indNum, \" individuals. \\n\"))\n    genosOnly = geno[:, Not(1)] #remove first column, which was just a row index\nend\nIn the data matrix, rows represent individuals and columns represent SNPs, and genotypes are as follows:\n0: homozygous reference; 1: heterozygous; 2: homozygous alternate; -1: missing genotype\n\n[If you want to filter individuals or SNPs with too much missing data, I have scripts that can be added here]\n\n\nChoose our groups to plot, and their colours\ngroups_to_plot = [\"GCSP\",\"PSWS\",\"GWCS\"]\ngroup_colors = [\"gold\",\"red\",\"blue\"]\n\n\nTo do a PCA, we first need to impute missing genotypes\nPrepare data matrix to be ready for imputation, by replacing -1 with missing data type:\nbegin\n    genosOnly_with_missing = Matrix{Union{Missing, Int16}}(genosOnly)\n    genosOnly_with_missing[genosOnly_with_missing .== -1] .= missing;\n    genosOnly_with_missing = Matrix{Union{Missing, Float32}}(genosOnly_with_missing) \nend\nLoad Impute package:\nusing Impute\nNow actually impute the missing genotype values:\n@time imputed_genos = Impute.svd(genosOnly_with_missing)\n\n\n\nLet‚Äôs make the PCA plot!\nbegin\nPCAmodel = SNPlots.plotPCA(imputed_genos, ind_with_metadata,\n        groups_to_plot, group_colors;\n        sampleSet=\"Zonotrichia sparrows\", regionText=\"whole_genome\",\n        flip1=false, flip2=false, showPlot=true)\nPCAmodel.PCAfig\nend\nGold symbols represent Golden-crowned Sparrows. Blue represent the gambelii form of White-crowned Sparrows. Red represent that the pugetensis form of White-crowned Sparrows.\n\n\nNow let‚Äôs produce a genotype-by-individual plot\nSome initial setup of parameters for the plot:\nbegin \n    group1 = \"GCSP\"   # the alleles most common in this  group will be assigned the same color in the graph\n    groupsToCompare = \"GCSP_PSWS\" # The groups to compare for the Fst filter below\n    Fst_cutoff =  0.8\n    missingFractionAllowed = 0.2\nend\nCalculate allele frequencies and sample sizes per group:\nfreqs, sampleSizes = SNPlots.getFreqsAndSampleSizes(genosOnly_with_missing,\n                            ind_with_metadata.Fst_group, groups_to_plot)\nCalculate Fst (allele frequency differentiation) between pairs of groups:\nFst, FstNumerator, FstDenominator, pairwiseNamesFst = SNPlots.getFst(freqs,\n                                            sampleSizes, groups_to_plot)\nChoose the chromosome to plot:\nbegin\n    chr = \"CM018231.2\" # the name of a scaffold in the assembly\n    regionInfo = SNPlots.chooseChrRegion(pos_whole_genome, chr) #; positionMin=1) # this gets the maximum position for the chromosome\nend\n\nOK, let‚Äôs make the plot!\nbegin\n    plotInfo = SNPlots.plotGenotypeByIndividual(groupsToCompare, Fst_cutoff,\n        missingFractionAllowed, regionInfo, pos_whole_genome, Fst, pairwiseNamesFst, \n        genosOnly_with_missing, ind_with_metadata, freqs, \n        groups_to_plot, group_colors)\n    plotInfo[1] # this outputs the plot above\nend\nThe figure shows the genotypes of individuals at SNPs that have Fst higher than Fst_cutoff in the groups being compared (given by groupsToCompare). The two alleles have different shades of purple, with triangles indicating heterozygotes. The bottom of the plot indicates the location of SNPs on the chromosome, and the blue shading indicates SNP density across the chromosome.\nIf the function works on your computer like it does on mine, it will create a separate plot window and show the figure both there and in your Pluto notebook.\n\n\n\n\n\n\nProduce such plots for a series of chromosomes\n\n\n\nCan you write a loop to cycle through a number of different chromosomes and make a plot for each? You would use a lot of the code in the previous two cells above. You could do this for these scaffolds, expressed here a a vector of strings: [\"CM018230.2\", \"CM018231.2\", \"CM018232.2\", \"CM018233.2\", \"CM018234.2\"]\n\n\n\n\n\nA take-home message:\nThe SNPlots.plotGenotypeByIndividual() function produces this complex plot from the repeated use of low-level plotting functions to simply draw lines, filled shapes, and text in the plotting window. If you learn the commands to draw such simple elements and the logic by which to determine where to draw them, you can design your own functions to make all sorts of complex figures.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Load & Graph Data"
    ]
  },
  {
    "objectID": "MultipleDispatch.html",
    "href": "MultipleDispatch.html",
    "title": "Types and Multiple Dispatch",
    "section": "",
    "text": "If you‚Äôve worked through the material in the previous pages, you now have the tools to write all sorts of reasonably complex programs to do interesting things. You might take a pause here and build up your skills in combining those tools in ways you find interesting. After spending some time doing that, come back to this page and continue below.\nHere, we‚Äôll build up to an understanding of one of the most powerful features of Julia: multiple dispatch. Rather than define that at the start, we‚Äôll build up an understanding. We‚Äôll start with better understanding of type specifications of objects, then learn how to define our own types of data structures, then learn about single dispatch, and finally explore multiple dispatch.\n\nSpecifying types of objects\nSeveral pages back we learned about how Julia has dynamic typing meaning you often don‚Äôt need to think about the types of objects. But as your programming skills increase, it becomes increasingly beneficial to think about types. This facilitates organized code, interpretation of error messages, reading of documentation, and defining and using functions effectively.\nWe can specify the type of an object using the :: operator, which can be thought of as meaning ‚Äúis an instance of‚Äù:\n\nx::Int64 = 6\n\n6\n\n\nThe above declares an object x as being of type Int64, and then assigns the value 6 to it. If you try to assign something like 6.3 to it, you will get an error (try it!). However, Julia tries to be friendly so if you assign something that can be converted to Int64 it works:\n\ny::Int64 = 6.0\ny\n\n6\n\n\n\nprintln(typeof(6.0))\nprintln(typeof(y))\n\nFloat64\nInt64\n\n\nWhy would you want to force a variable to have a type, when Julia can usually type things correctly on the fly? Maybe you want to make sure that the code is working as you want it to, or you want to prevent code designed for one type of data to be accidentally used for another.\n\n\nCreate your own types: struct\nYou can create your own data structures, which have their own types, using the struct keyword. For instance, let‚Äôs say we are working with shapes:\n\nstruct Circle\n    radius\nend\n\nSo now we have defined a new type (Circle) that has one field (radius). We can now create (‚Äúinstantiate‚Äù or ‚Äúconstruct‚Äù) an actual object that is of this type by calling Circle like a function:\n\ncircA = Circle(1)\n\nCircle(1)\n\n\n\ntypeof(circA)\n\nCircle\n\n\nSo now, circA is a specific object in memory of type Circle. To get its radius (its only field), we type the name of the object then a . and then the field name:\n\ncircA.radius\n\n1\n\n\nLet‚Äôs define and instantiate another kind of shape:\n\nstruct Square\n    side\nend\nsq1 = Square(5)\n\nSquare(5)\n\n\n\n\n\n\n\n\nMore shapes!\n\n\n\nCan you define a new Rectangle type? It needs to have two fields: length and width. Then, create a specific rectangle.\n\n\n\n\nDefining functions for specific types\nNow that we have some shape objects, let‚Äôs do something with them. Functions are great at doing things with objects, so let‚Äôs define a function:\n\ngetArea(x::Circle) = œÄ * (x.radius)^2    # write œÄ with: \\pi tab\n\ngetArea (generic function with 1 method)\n\n\nWe have now defined a function that requires a Circle object as input, and returns the area of the circle based on the radius field. We can call it on our actual objects in memory:\n\ngetArea(circA)\n\n3.141592653589793\n\n\nWe also want to get areas of squares. So, we can define a function with the same name but applies only to Squares:\n\ngetArea(x::Square) = x.side^2\n\ngetArea (generic function with 2 methods)\n\n\nNow here is where it gets really neat. Let‚Äôs call the getArea() function on our our actual square object in memory:\n\ngetArea(sq1)\n\n25\n\n\nAnd now let‚Äôs call the same named function on our circle:\n\ngetArea(circA)\n\n3.141592653589793\n\n\nIn each case, Julia applies the correct formula (for a square vs.¬†a circle) because we‚Äôve set up our function to have two actual methods, and it chooses the method to apply based on the type of the argument.\n\n\n\n\n\n\nAdd a method\n\n\n\nCan you define another method for the getArea() function, this time applying to the Rectangle type (which you defined above)? Then call the function using the specific Rectangle you instantiated above.\n\n\n\n\nMultiple Dispatch: When a method depends on multiple arguments to a function\nIn the above example using shapes, we had an example of single dispatch, when the method of a function depends on the type of a single argument. This is common in a variety of computer languages. Julia is unusual in having the concept of multiple dispatch at its core. This is when the method of a function depends on the types of multiple arguments. We‚Äôll develop this idea using an example:\n\nInteracting cats and dogs\n\nstruct Dog\n  name::String\n  age::Int  # Int is an general type for all integer types (e.g. Int64)\n  sound::String \nend\n\nThe above creates a Dog type. Now let‚Äôs make two actual Dogs:\n\nrosie = Dog(\"Rosie\", 3, \"woof\")\nleah = Dog(\"Leah\", 4, \"howl\")\n\nDog(\"Leah\", 4, \"howl\")\n\n\nWe can learn about what is within a certain object in memory by using the ‚Äòdump()‚Äô function (which can be thought of as ‚Äúdumping‚Äù or showing everything in the object):\n\ndump(rosie)\n\nDog\n  name: String \"Rosie\"\n  age: Int64 3\n  sound: String \"woof\"\n\n\nNow let‚Äôs make a Cat type and two instantiated Cats:\n\nstruct Cat\n  name::String\n  age::Int  # Int is an general type for all integer types (e.g. Int64)\n  sound::String \nend\n\nfluffy = Cat(\"Fluffy\", 6, \"meow\")\nmilo = Cat(\"Milo\", 11, \"rarr\")\n\nCat(\"Milo\", 11, \"rarr\")\n\n\nNow that we‚Äôve made some dogs and cats, let‚Äôs define the rules by which they interact:\n\nfunction interact(x::Dog, y::Dog)\n  println(\"$(x.name) wags tail and makes a $(x.sound) toward $(y.name).\")\nend\n\ninteract (generic function with 1 method)\n\n\n\nfunction interact(x::Dog, y::Cat)\n  println(\"$(x.name) chases $(y.name).\")\nend\n\ninteract (generic function with 2 methods)\n\n\n\nfunction interact(x::Cat, y::Dog)\n  println(\"$(x.name) runs from $(y.name).\")\nend\n\ninteract (generic function with 3 methods)\n\n\n\nfunction interact(x::Cat, y::Cat)\n  println(\"$(x.name) stretches and says $(x.sound).\")\nend\n\ninteract (generic function with 4 methods)\n\n\nNow, let‚Äôs call our function:\n\ninteract(rosie, leah)\ninteract(rosie, fluffy)\ninteract(fluffy, rosie)\ninteract(fluffy, milo)\n\nRosie wags tail and makes a woof toward Leah.\nRosie chases Fluffy.\nFluffy runs from Rosie.\nFluffy stretches and says meow.\n\n\nThe above display that the interact() function has four different methods depending on the types of the two input arguments. This is multiple dispatch.\n\n\nImportance of multiple dispatch\nThe examples above are just an initial look at the power of multiple dispatch. If Julia did not have multiple dispatch, then the method of the function call would depend only the first argument (i.e., single dispatch). You could still write a general interact() function code that checks whether the second argument is a Cat, a Dog, etc., and have if statements to govern what to do in the different cases. But multiple dispatch provides an efficient, concise way to ensure just the appropriate code is evaluated, without explicit if statements.\nOne reason it is important to understand multiple dispatch is that it helps you understand how to use built-in Julia functions, and helps you understand errors when you get them. For example, enter this incorrect expression:\nsqrt([9, 4])\nThe REPL responds by saying: ERROR: MethodError: no method matching sqrt(::Vector{Int64})\nIt is telling you that there is no method for the ‚Äòsqrt‚Äô function that uses an input an object of type Vector{Int64} (meaning a vector of integers). If we can understand this message, we might then realize that we have to either enter a single number as input (sqrt(9)) or broadcast over all elements of the vector using the dot operator (sqrt.([9, 4])).\nIf we want to see what methods a function can use, we can use the methods() function:\n\nmethods(interact)\n\n# 4 methods for generic function interact from \u001b[35mMain\u001b[39m: interact(x::Cat, y::Cat) in Main at In[22]:1  interact(x::Cat, y::Dog) in Main at In[21]:1  interact(x::Dog, y::Cat) in Main at In[20]:1  interact(x::Dog, y::Dog) in Main at In[19]:1 \n\n\nThe REPL then tells us that there are four methods and summarizes what types go into them.\nIf curious, you can try this on any function‚Äìfor instance, try methods(+) to see that there are at least 189 methods for the +() function depending on the arguments passed into it.\n\n\n\nNext steps\nThis and the previous pages have brought you through what I consider to be an introductory tour of the central concepts needed to program in Julia. You can use these building blocks to compose programs that do all sorts of complex things‚Äìvirtually anything you can imagine, as long as you can think through the logic of what you want your program to do.\nTwo things though that we have not said much about yet are 1) how to make nice plots, and 2) how to import data in order to analyze and graph it. We will now explore those two topics on the next pages.",
    "crumbs": [
      "Home",
      "Julia tutorials",
      "Types and Multiple Dispatch"
    ]
  }
]