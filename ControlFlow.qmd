---
title: "Control Flow: Loops and Ifs"
author: "Darren Irwin"
execute:
  echo: true
format:
  html:
    code-fold: false
jupyter: julia-1.10
---

So far, what we have learned might be called _coding_, the way your write commands that do a fixed set of instructions. To do true _programming_ we need to know how to write scripts in which the exact sequence of commands is determined dynamically. This is called _control flow_.

### Loops: `for` and `while`

Loops are very useful in programming, because we often want to do a set of commands multiple times. For example:

```{julia}
for ice in 1:10
  iceCubed = ice^3
  println("The cube of ", ice, " is ", iceCubed)
end
```

Here we'll use a random integer to determine how many times to do a loop:

```{julia}
rand_times = rand(1:10)
for i in 1:rand_times
  println(i)
end
println("I counted to $rand_times")
```

Note that the `$` in the last line above causes _string interpolation_ of the expression to the right of it.

::: {.callout-tip}
## Teach Julia to Sing
Write a script that produces the song "99 bottles of beer on the wall." This song goes like "99 bottles of beer on the wall, 99 bottle of beer, you take one down and pass it around, 98 bottles of beer on the wall; 98 bottles of beer on the wall, 98 bottles of ..." and so forth that all the way down. (I don't think anyone has ever completed the song . . . Can your program succeed in doing so?)
:::

An interesting thing about `for` loops is that the iterator variable is internal to the loop (not "known" outside of the loop):

```{julia}
i = 27
println("Before the loop, i = $i")
for i in 1:3
  println("Inside the loop, i = $i")
end
println("After the loop, i = $i")
```

#### `for` loops can iterate across many kinds of collections

You can iterate across all sorts of things, for example a matrix of strings:

```{julia}
speciesGrid = ["warblers" "flamebacks" "sticklebacks"; 
              "sparrows"  "guppies" "digital organisms"] 
for i in speciesGrid
  println("We study $i.")
end
```

Instead of the `in` in the `for` line, you can use the unicode character `‚àà` (produced by typing `\in` tab), which is a mathematical symbol meaning "is an element of". :

```{julia}
mySet = ["banana", 5.3, 'üê¨']  # get the dolphin with \:dolphin: tab
for thing ‚àà mySet
  println(thing)
end
``` 

#### Nested loops

Often it is useful to have nested loops. For instance, to produce all dinucleotide combinations:

```{julia}
bases = ['A', 'C', 'G', 'T']
for i in bases
  for j in bases
    print(i, j, ", ")
  end
end
```

You can produce the above more concisely by putting both iterator statements on the same line:
```{julia}
bases = ['A', 'C', 'G', 'T']
for i in bases, j in bases
  print(i, j, ", ")
end 
```

::: {.callout-tip}
## Produce all trinucleotides
Can you modify the above to produce all possible trinucleotides (i.e., 3-base nucleotides)? 
:::

#### `while` loops

Let's say you don't know in advance how many times you want to go through a loop. Rather, you want to stop the loop when some condition is met. The `while` loop is perfect for that:

```{julia}
sum = 0
while sum <= 21  # inspired by a card game
  sum = sum + rand(1:10)
  println(sum)
end
```

::: {.callout-tip}
## Simulate dispersal of an organism
You are writing a simulation in which individuals move from their birth site to their breeding site, along a continuous range of length 1. The dispersal distance is drawn from a standard normal distribution, given by `randn()`, with the constraint that they are not allowed to move outside of the range. If an individual is born at location 0.7, write a script that determines its breeding location within the range (lowest possible value = 0; highest possible value = 1).
:::

### Compound expressions

A _compound expression_ is a single large expression that is made up of multiple sub-expressions that are evaluated in order. When the compoud expression is evaluated, only the value generated by the last sub-expression is returned. There are basically two ways to generate compound expressions:

#### Use a semicolon (`;`) chain 

```{julia}
x = 4; y = 3; x + y
```

The above _returns_ the value of the last subexpression, but it does remember values assigned in the earlier subexpressions. (To prove this to yourself, enter `x` to see its value.)

You can use compound expressions as part of even larger expressions, e.g.:

```{julia}
myVar = (x = 4; y = 3; x + y)
```

There, the compound expression in parentheses is evaluated and the resulting value is assigned to `myVar`.

#### Use a `begin` block

The above compound expression is equivalent to the one below:

```{julia}
myVar2 = begin x = 4; y = 3; x + y end
```

The use of `begin` blocks is particularly useful when dividing expressions between multiple lines:

```{julia}
begin
  string1 = "Phylloscopus"
  string2 = "trochiloides"
  string1 * " " * string2
end
```

### Conditional evaluation: `if` and `? :`

Often in our programs we want to execute some commands only if a condition is met. For this, we can use an `if` - `elseif` - `else` block:

```{julia}
coinflip = rand(["heads", "tails"])
if coinflip == "heads"
  println("Heads--You win!")
elseif coinflip == "tails"
  println("Tails--You lose :(")
else 
  println("The coin has a strange value")
end
```

In an `if` block, the `elseif` and `else` parts are optional, but the `end` is essential. The indentation is customary and makes the code easier to read, but is not required. The value of the conditional expressions (e.g., just to the right of `if`) must be of type `Bool`, meaning either `true` or `false`. 

::: {.callout-tip}
## Determine homozygote or heterozygote
Write a script in which you assign a diploid genotype to a variable, with the genotype encoded as a 2-element vector containing strings (e.g., `["A", "C"]` or `["A", "A"]`), and then the script tells you whether the genotype is homozygous (the two elements are the same) or heterozygous (the two elements are different). (_Hint_: Remember how to access one element of a vector, e.g. `x[1]` gives just the first element of `x`; Remember how to ask if two things are equal: `==`)
:::

In Julia, `if` blocks return a value. You can make use if that to do something like this:

```{julia}
homozygote = true
genotype = if homozygote
             "TT"
           else
             "TG"
           end
```

#### Ternary operators

The _ternary operator_, consisting of a `?` and `:` separating three expressions (hence "ternary"), can be thought of as a consise form of an `if` - `else` block. For instance, this is equivalent to the above:

```{julia}
homozygote ? "TT" : "TG"
```

This can be thought of as "True or false" ? "Do this if true" : "Do this if false"

::: {.callout-tip}
## Determine whether a number is positive or negative 
Assign a non-zero number to a variable, and then use a ternary operater to report whether the number is positive or negative.
:::

### Short-circuit evaluation

Another way of constructing conditional evaluations is to use the `&&` and `||` operators (which mean logical "and" and logical "or"). These operators come between two sub-expressions which are evaluated in order from left to right. Julia is efficient and only evaluates the rightmost sub-expression if it needs to (this is why it is called _short-circuit evaluation_: the evaluation doesn't always extend to the right sub-expression). Hence:

* In `a && b`, `b` is evaluated only if `a` is `true` (because otherwise the whole statement is definitely `false`)
* In `a || b`, `b` is evaluated only if `a` is `false` (because otherwise the whole statement is definitely `true`)

The interesting thing is that the `b` subexpression does not have to produce `true` or `false`. Rather, it can do anything you want, and is only executed depending on whether `a` is true. For example:

```{julia}
x = 5
x > 0 && println("x is positive")
```

Try changing `x` above to a negative value and run the above again.

I think of the above construction as "Check if true AND (only if true) do this thing."

```{julia}
y = 3.2
y <= 0 || println("x is positive")
```

Again, try changing the value of `y` to a negative value and run again.

I think of the above as "Check if true OR (only if not true) do this thing."

The above expressions may take a while to get used to. You don't have to use them, as you might find the `if` block a lot more intuitive. But you may see these expressions in code that others have written, so it is good to understand them. 

### Next steps

Now that we have have developed an understanding of loops and conditional evaluation, we are ready to learn more about functions, types, and multiple dispatch in Julia. Together, these concepts can be thought of as methods of control flow. They enable powerful and fascinating approaches to programming.












[This is all I've prepared so far. More coming . . .]

Next page:

Structs and multiple dispatch (example with dog and cat structs, with names and sounds, with different versions of interact function based on types)







