---
title: "Control Flow: Loops and Ifs"
author: "Darren Irwin"
execute:
  echo: true
format:
  html:
    code-fold: false
jupyter: julia-1.10
---

So far, what we have learned might be called _coding_, the way your write commands that do a fixed set of instructions. To do true _programming_ we need to know how to write scripts in which the exact sequence of commands is determined dynamically. This is called _control flow_.

### Loops: `for` and `while`

Loops are very useful in programming, because we often want to do a set of commands multiple times. For example:

```{julia}
for ice in 1:10
  iceCubed = ice^3
  println("The cube of ", ice, " is ", iceCubed)
end
```

Here we'll use a random integer to determine how many times to do a loop:

```{julia}
rand_times = rand(1:10)
for i in 1:rand_times
  println(i)
end
println("I counted to $rand_times")
```

Note that the `$` in the last line above causes _string interpolation_ of the expression to the right of it.

::: {.callout-tip}
## Teach Julia to Sing
Write a script that produces the song "99 bottles of beer on the wall." This song goes like "99 bottles of beer on the wall, 99 bottle of beer, you take one down and pass it around, 98 bottles of beer on the wall; 98 bottles of beer on the wall, 98 bottles of ..." and so forth that all the way down. (I don't think anyone has ever completed the song . . . Can your program succeed in doing so?)
:::

An interesting thing about `for` loops is that the iterator variable is internal to the loop (not "known" outside of the loop):

```{julia}
i = 27
println("Before the loop, i = $i")
for i in 1:3
  println("Inside the loop, i = $i")
end
println("After the loop, i = $i")
```

#### `for` loops can iterate across many kinds of collections

You can iterate across all sorts of things, for example a matrix of strings:

```{julia}
speciesGrid = ["warblers" "flamebacks" "sticklebacks"; 
              "sparrows"  "guppies" "digital organisms"] 
for i in speciesGrid
  println("We study $i.")
end
```

Instead of the `in` in the `for` line, you can use the unicode character `‚àà` (produced by typing `\in` tab), which is a mathematical symbol meaning "is an element of". :

```{julia}
mySet = ["banana", 5.3, 'üê¨']  # get the dolphin with \:dolphin: tab
for thing ‚àà mySet
  println(thing)
end
``` 

#### Nested loops

Often it is useful to have nested loops. For instance, to produce all dinucleotide combinations:

```{julia}
bases = ['A', 'C', 'G', 'T']
for i in bases
  for j in bases
    print(i, j, ", ")
  end
end
```

You can produce the above more concisely by putting both iterator statements on the same line:
```{julia}
bases = ['A', 'C', 'G', 'T']
for i in bases, j in bases
  print(i, j, ", ")
end 
```

::: {.callout-tip}
## Produce all trinucleotides
Can you modify the above to produce all possible trinucleotides (i.e., 3-base nucleotides)? 
:::

#### `while` loops

Let's say you don't know in advance how many times you want to go through a loop. Rather, you want to stop the loop when some condition is met. The `while` loop is perfect for that:

```{julia}
sum = 0
while sum <= 21  # inspired by a card game
  sum = sum + rand(1:10)
  println(sum)
end
```

::: {.callout-tip}
## Simulate dispersal of an organism
You are writing a simulation in which individuals move from their birth site to their breeding site, along a continuous range of length 1. The dispersal distance is drawn from a standard normal distribution, given by `randn()`, with the constraint that they are not allowed to move outside of the range. If an individual is born at location 0.7, write a script that determines its breeding location within the range (lowest possible value = 0; highest possible value = 1).
:::

### Compound expressions

A _compound expression_ is a single large expression that is made up of multiple sub-expressions that are evaluated in order. When the compoud expression is evaluated, only the value generated by the last sub-expression is returned. There are basically two ways to generate compound expressions:

#### Use a semicolon (`;`) chain 

```{julia}
x = 4; y = 3; x + y
```

The above _returns_ the value of the last subexpression, but it does remember values assigned in the earlier subexpressions. (To prove this to yourself, enter `x` to see its value.)

You can use compound expressions as part of even larger expressions, e.g.:

```{julia}
myVar = (x = 4; y = 3; x + y)
```

There, the compound expression in parentheses is evaluated and the resulting value is assigned to `myVar`.

#### Use a `begin` block

The above compound expression is equivalent to the one below:

```{julia}
myVar2 = begin x = 4; y = 3; x + y end
```

The use of `begin` blocks is particularly useful when dividing expressions between multiple lines:

```{julia}
begin
  string1 = "Phylloscopus"
  string2 = "trochiloides"
  string1 * " " * string2
end
```




[This is all I've prepared so far. More coming . . .]


Conditional evaluation
  If-elseif-else (example checking if het-hom-het genotype)
  (ternary operator)
  (short-circuit evaluation)

Some exercise to practice with above

Next page:

Structs and multiple dispatch (example with dog and cat structs, with names and sounds, with different versions of interact function based on types)







